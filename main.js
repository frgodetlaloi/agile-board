/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgileBoardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/constants/layouts.ts
var BUILT_IN_LAYOUTS = {
  /**
   * Matrice d'Eisenhower - 4 quadrants pour la priorisation
   * Grille 2x2 de 12x12 chacun
   */
  layout_eisenhower: [
    { title: "Urgent et Important", x: 0, y: 0, w: 12, h: 12 },
    { title: "Pas urgent mais Important", x: 12, y: 0, w: 12, h: 12 },
    { title: "Urgent mais Pas important", x: 0, y: 12, w: 12, h: 12 },
    { title: "Ni urgent ni important", x: 12, y: 12, w: 12, h: 12 }
  ],
  /**
   * Tableau Kanban classique - 3 colonnes
   * Colonnes de 8 unités de large sur toute la hauteur
   */
  layout_kanban: [
    { title: "\xC0 faire", x: 0, y: 0, w: 8, h: 24 },
    { title: "En cours", x: 8, y: 0, w: 8, h: 24 },
    { title: "Termin\xE9", x: 16, y: 0, w: 8, h: 24 }
  ],
  /**
   * Getting Things Done (GTD) - 6 sections
   * Organisation selon la méthode GTD de David Allen
   */
  layout_gtd: [
    { title: "Inbox", x: 0, y: 0, w: 12, h: 8 },
    { title: "Actions suivantes", x: 12, y: 0, w: 12, h: 8 },
    { title: "En attente", x: 0, y: 8, w: 8, h: 8 },
    { title: "Projets", x: 8, y: 8, w: 8, h: 8 },
    { title: "Someday Maybe", x: 16, y: 8, w: 8, h: 8 },
    { title: "R\xE9f\xE9rence", x: 0, y: 16, w: 24, h: 8 }
  ],
  /**
   * Planificateur hebdomadaire - 7 sections
   * 5 jours de travail + weekend + notes
   */
  layout_weekly: [
    { title: "Lundi", x: 0, y: 0, w: 6, h: 12 },
    { title: "Mardi", x: 6, y: 0, w: 6, h: 12 },
    { title: "Mercredi", x: 12, y: 0, w: 6, h: 12 },
    { title: "Jeudi", x: 18, y: 0, w: 6, h: 12 },
    { title: "Vendredi", x: 0, y: 12, w: 8, h: 12 },
    { title: "Weekend", x: 8, y: 12, w: 8, h: 12 },
    { title: "Notes", x: 16, y: 12, w: 8, h: 12 }
  ],
  /**
   * Board simple - 2 colonnes
   * Idéal pour des comparaisons ou du brainstorming
   */
  layout_simple: [
    { title: "Ideas", x: 0, y: 0, w: 12, h: 24 },
    { title: "Actions", x: 12, y: 0, w: 12, h: 24 }
  ],
  /**
   * Notes Cornell - 3 sections organisées
   * Méthode de prise de notes structurée
   */
  layout_cornell: [
    { title: "Notes", x: 0, y: 0, w: 16, h: 18 },
    { title: "Mots-cl\xE9s", x: 16, y: 0, w: 8, h: 18 },
    { title: "R\xE9sum\xE9", x: 0, y: 18, w: 24, h: 6 }
  ],
  /**
   * Planificateur quotidien - 6 sections
   * Organisation détaillée pour une journée
   */
  layout_daily: [
    { title: "Objectifs du jour", x: 0, y: 0, w: 12, h: 8 },
    { title: "T\xE2ches prioritaires", x: 12, y: 0, w: 12, h: 8 },
    { title: "Planning", x: 0, y: 8, w: 8, h: 8 },
    { title: "Notes", x: 8, y: 8, w: 8, h: 8 },
    { title: "Apprentissages", x: 16, y: 8, w: 8, h: 8 },
    { title: "R\xE9flexions", x: 0, y: 16, w: 24, h: 8 }
  ],
  /**
   * Gestion de projet - 6 sections
   * Vue d'ensemble complète d'un projet
   */
  layout_project: [
    { title: "Vue d'ensemble", x: 0, y: 0, w: 24, h: 6 },
    { title: "Objectifs", x: 0, y: 6, w: 8, h: 9 },
    { title: "\xC9tapes", x: 8, y: 6, w: 8, h: 9 },
    { title: "Ressources", x: 16, y: 6, w: 8, h: 9 },
    { title: "Risques", x: 0, y: 15, w: 12, h: 9 },
    { title: "Suivi", x: 12, y: 15, w: 12, h: 9 }
  ],
  /**
   * Dashboard Tasks (intégration plugin Tasks)
   * Optimisé pour les requêtes Tasks
   */
  layout_tasks_dashboard: [
    { title: "T\xE2ches du jour", x: 0, y: 0, w: 8, h: 12 },
    { title: "Cette semaine", x: 8, y: 0, w: 8, h: 12 },
    { title: "En retard", x: 16, y: 0, w: 8, h: 12 },
    { title: "Projets actifs", x: 0, y: 12, w: 12, h: 12 },
    { title: "Statistiques", x: 12, y: 12, w: 12, h: 12 }
  ],
  /**
   * Analytics Dataview (intégration plugin Dataview)
   * Optimisé pour les requêtes Dataview
   */
  layout_dataview_analytics: [
    { title: "M\xE9triques g\xE9n\xE9rales", x: 0, y: 0, w: 12, h: 8 },
    { title: "Tendances", x: 12, y: 0, w: 12, h: 8 },
    { title: "Top tags", x: 0, y: 8, w: 8, h: 8 },
    { title: "Fichiers r\xE9cents", x: 8, y: 8, w: 8, h: 8 },
    { title: "Liens bris\xE9s", x: 16, y: 8, w: 8, h: 8 },
    { title: "Donn\xE9es d\xE9taill\xE9es", x: 0, y: 16, w: 24, h: 8 }
  ]
};
var LAYOUT_INFO = {
  layout_eisenhower: {
    name: "layout_eisenhower",
    displayName: "Matrice d'Eisenhower",
    description: "Priorisez vos t\xE2ches selon urgence et importance",
    sections: ["Urgent et Important", "Pas urgent mais Important", "Urgent mais Pas important", "Ni urgent ni important"],
    blockCount: 4,
    category: "productivity"
  },
  layout_kanban: {
    name: "layout_kanban",
    displayName: "Tableau Kanban",
    description: "Visualisez le flux de travail en 3 colonnes",
    sections: ["\xC0 faire", "En cours", "Termin\xE9"],
    blockCount: 3,
    category: "workflow"
  },
  layout_gtd: {
    name: "layout_gtd",
    displayName: "Getting Things Done",
    description: "Organisez selon la m\xE9thode GTD de David Allen",
    sections: ["Inbox", "Actions suivantes", "En attente", "Projets", "Someday Maybe", "R\xE9f\xE9rence"],
    blockCount: 6,
    category: "productivity"
  },
  layout_weekly: {
    name: "layout_weekly",
    displayName: "Planificateur Hebdomadaire",
    description: "Planifiez votre semaine jour par jour",
    sections: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Weekend", "Notes"],
    blockCount: 7,
    category: "planning"
  },
  layout_daily: {
    name: "layout_daily",
    displayName: "Planificateur Quotidien",
    description: "Structurez votre journ\xE9e en d\xE9tail",
    sections: ["Objectifs du jour", "T\xE2ches prioritaires", "Planning", "Notes", "Apprentissages", "R\xE9flexions"],
    blockCount: 6,
    category: "planning"
  },
  layout_project: {
    name: "layout_project",
    displayName: "Gestion de Projet",
    description: "Vue d'ensemble compl\xE8te d'un projet",
    sections: ["Vue d'ensemble", "Objectifs", "\xC9tapes", "Ressources", "Risques", "Suivi"],
    blockCount: 6,
    category: "project"
  },
  layout_simple: {
    name: "layout_simple",
    displayName: "Board Simple",
    description: "Deux colonnes pour comparaisons ou brainstorming",
    sections: ["Ideas", "Actions"],
    blockCount: 2,
    category: "basic"
  },
  layout_cornell: {
    name: "layout_cornell",
    displayName: "Notes Cornell",
    description: "M\xE9thode de prise de notes structur\xE9e",
    sections: ["Notes", "Mots-cl\xE9s", "R\xE9sum\xE9"],
    blockCount: 3,
    category: "notes"
  },
  layout_tasks_dashboard: {
    name: "layout_tasks_dashboard",
    displayName: "Dashboard Tasks",
    description: "Int\xE9gration avanc\xE9e avec le plugin Tasks",
    sections: ["T\xE2ches du jour", "Cette semaine", "En retard", "Projets actifs", "Statistiques"],
    blockCount: 5,
    category: "integration"
  },
  layout_dataview_analytics: {
    name: "layout_dataview_analytics",
    displayName: "Analytics Dataview",
    description: "Tableaux de bord avec le plugin Dataview",
    sections: ["M\xE9triques g\xE9n\xE9rales", "Tendances", "Top tags", "Fichiers r\xE9cents", "Liens bris\xE9s", "Donn\xE9es d\xE9taill\xE9es"],
    blockCount: 6,
    category: "integration"
  }
};

// src/services/LayoutService.ts
var LayoutService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.models = /* @__PURE__ */ new Map();
  }
  load() {
    console.log("\u{1F4D0} Chargement des layouts int\xE9gr\xE9s...");
    this.models.clear();
    let loadedCount = 0;
    for (const [name, layout] of Object.entries(BUILT_IN_LAYOUTS)) {
      console.log(`\u{1F50D} Chargement du layout "${name}"...`);
      if (this.validateModel(name, layout)) {
        this.models.set(name, layout);
        loadedCount++;
        console.log(`\u2705 Layout "${name}" charg\xE9 (${layout.length} blocs)`);
      } else {
        console.warn(`\u274C Mod\xE8le "${name}" invalide`);
      }
    }
    console.log(`\u{1F4D0} ${loadedCount} layouts charg\xE9s`);
    this.logAvailableLayouts();
  }
  validateModel(name, layout) {
    const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
    let isValid = true;
    for (const block of layout) {
      if (!this.isValidBlock(block)) {
        console.warn(`\u274C [${name}] Bloc invalide :`, block);
        isValid = false;
        continue;
      }
      if (!this.isBlockInBounds(block)) {
        console.warn(`\u274C [${name}] Bloc hors limites :`, block);
        isValid = false;
        continue;
      }
      if (!this.checkOverlap(grid, block, name)) {
        isValid = false;
      }
    }
    return isValid;
  }
  isValidBlock(block) {
    return typeof block.title === "string" && typeof block.x === "number" && typeof block.y === "number" && typeof block.w === "number" && typeof block.h === "number";
  }
  isBlockInBounds(block) {
    return block.x >= 0 && block.y >= 0 && block.w > 0 && block.h > 0 && block.x + block.w <= 24 && block.y + block.h <= 100;
  }
  checkOverlap(grid, block, modelName) {
    for (let x = block.x; x < block.x + block.w; x++) {
      for (let y = block.y; y < block.y + block.h; y++) {
        if (grid[x][y]) {
          console.warn(`\u274C [${modelName}] Chevauchement d\xE9tect\xE9 au bloc "${block.title}" \xE0 (${x}, ${y})`);
          return false;
        }
        grid[x][y] = true;
      }
    }
    return true;
  }
  logAvailableLayouts() {
    const layouts = Array.from(this.models.keys());
    console.log("\u{1F4CB} Layouts disponibles:", layouts);
    for (const [name, layout] of this.models) {
      const sections = layout.map((b) => b.title).join(", ");
      console.log(`  \u2022 ${name}: ${layout.length} sections (${sections})`);
    }
  }
  getModel(name) {
    return this.models.get(name);
  }
  getAllModelNames() {
    return Array.from(this.models.keys());
  }
  getLayoutDisplayName(layoutName) {
    const layoutInfo = LAYOUT_INFO[layoutName];
    return layoutInfo ? layoutInfo.displayName : layoutName;
  }
  getModelInfo(name) {
    const model = this.models.get(name);
    if (!model)
      return void 0;
    const info = LAYOUT_INFO[name];
    return info || {
      name,
      displayName: name,
      description: "Layout personnalis\xE9",
      sections: model.map((block) => block.title),
      blockCount: model.length,
      category: "custom"
    };
  }
  getAllModelsInfo() {
    return Array.from(this.models.keys()).map((name) => this.getModelInfo(name)).filter((info) => info !== void 0);
  }
};

// src/services/FileService.ts
var FileService = class {
  constructor(app) {
    this.app = app;
  }
  async parseSections(file) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = {};
    let currentSection = null;
    let sectionStart = 0;
    console.log("\u{1F4D6} Parsing sections du fichier:", file.basename);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const headerMatch = line.match(/^# ([^\n#].*?)\s*$/);
      if (headerMatch) {
        if (currentSection !== null) {
          const sectionLines = lines.slice(sectionStart + 1, i);
          sections[currentSection] = {
            start: sectionStart,
            end: i,
            lines: sectionLines
          };
          console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
        }
        currentSection = headerMatch[1].trim();
        sectionStart = i;
      }
    }
    if (currentSection !== null) {
      const sectionLines = lines.slice(sectionStart + 1);
      sections[currentSection] = {
        start: sectionStart,
        end: lines.length,
        lines: sectionLines
      };
      console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
    }
    console.log("\u2705 Sections trouv\xE9es:", Object.keys(sections));
    return sections;
  }
  async createMissingSections(file, layout) {
    console.log("\u{1F527} V\xE9rification des sections manquantes...");
    const sections = await this.parseSections(file);
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = requiredSections.filter((section) => !existingSections.includes(section));
    if (missingSections.length === 0) {
      console.log("\u2705 Toutes les sections sont pr\xE9sentes");
      return false;
    }
    console.log("\u{1F4DD} Sections manquantes d\xE9tect\xE9es:", missingSections);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const insertionPoint = this.findInsertionPoint(lines);
    const newSectionLines = [];
    for (const sectionTitle of missingSections) {
      newSectionLines.push("");
      newSectionLines.push(`# ${sectionTitle}`);
      newSectionLines.push("");
    }
    const updatedLines = [
      ...lines.slice(0, insertionPoint),
      ...newSectionLines,
      ...lines.slice(insertionPoint)
    ];
    await this.app.vault.modify(file, updatedLines.join("\n"));
    console.log(`\u2705 ${missingSections.length} sections ajout\xE9es:`, missingSections);
    return true;
  }
  findInsertionPoint(lines) {
    let frontmatterEnd = 0;
    let inFrontmatter = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (i === 0 && line === "---") {
        inFrontmatter = true;
        continue;
      }
      if (inFrontmatter && line === "---") {
        frontmatterEnd = i + 1;
        break;
      }
    }
    if (frontmatterEnd === 0) {
      return 0;
    }
    return frontmatterEnd;
  }
  async updateSection(file, sectionName, newContent) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = await this.parseSections(file);
    const section = sections[sectionName];
    if (!section)
      return;
    const newLines = [
      ...lines.slice(0, section.start + 1),
      ...newContent.split("\n"),
      ...lines.slice(section.end)
    ];
    await this.app.vault.modify(file, newLines.join("\n"));
  }
  getMissingSections(existingSections, requiredSections) {
    return requiredSections.filter((section) => !existingSections.includes(section));
  }
};

// src/views/BoardView.ts
var import_obsidian = require("obsidian");

// src/components/MarkdownFrame.ts
var MarkdownFrame = class {
  constructor(app, container, file, section, onChange) {
    this.app = app;
    this.container = container;
    this.file = file;
    this.section = section;
    this.onChange = onChange;
    this.isEditing = false;
    this.content = section.lines.join("\n");
    this.initializeFrame();
  }
  initializeFrame() {
    this.setupContainer();
    this.createPreviewContainer();
    this.createEditorContainer();
    this.showPreview();
  }
  setupContainer() {
    this.container.empty();
    this.container.style.cssText = `
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    `;
  }
  createPreviewContainer() {
    this.previewContainer = this.container.createDiv("markdown-preview");
    this.previewContainer.style.cssText = `
      width: 100%;
      height: 100%;
      overflow: auto;
      padding: 0.5rem;
      cursor: text;
      box-sizing: border-box;
    `;
    this.renderContent();
    this.setupPreviewEvents();
  }
  createEditorContainer() {
    this.editorContainer = this.container.createDiv("markdown-editor");
    this.editorContainer.style.cssText = `
      width: 100%;
      height: 100%;
      display: none;
      box-sizing: border-box;
    `;
    this.textArea = this.editorContainer.createEl("textarea");
    this.textArea.style.cssText = `
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      resize: none;
      font-family: var(--font-text);
      font-size: var(--font-size-normal);
      background: transparent;
      color: var(--text-normal);
      padding: 0.5rem;
      box-sizing: border-box;
      line-height: 1.6;
    `;
    this.textArea.value = this.content;
    this.setupEditorEvents();
  }
  async renderContent() {
    this.previewContainer.empty();
    if (!this.content.trim()) {
      this.renderEmptyState();
      return;
    }
    try {
      const { MarkdownRenderer, Component } = require("obsidian");
      const component = new Component();
      await MarkdownRenderer.renderMarkdown(
        this.content,
        this.previewContainer,
        this.file.path,
        component
      );
      console.log("\u2705 Contenu rendu avec le moteur Obsidian (plugins support\xE9s)");
      this.setupInteractions();
    } catch (error) {
      console.warn("\u26A0\uFE0F Erreur rendu Obsidian, fallback vers rendu simple:", error);
      this.previewContainer.innerHTML = this.renderSimpleMarkdown(this.content);
    }
  }
  setupInteractions() {
    const taskCheckboxes = this.previewContainer.querySelectorAll('input[type="checkbox"].task-list-item-checkbox');
    taskCheckboxes.forEach((checkbox) => {
      checkbox.addEventListener("change", (event) => {
        const target = event.target;
        this.handleTaskToggle(target);
      });
    });
    const internalLinks = this.previewContainer.querySelectorAll("a.internal-link");
    internalLinks.forEach((link) => {
      link.addEventListener("click", (event) => {
        event.preventDefault();
        const href = link.getAttribute("data-href") || link.getAttribute("href");
        if (href) {
          this.app.workspace.openLinkText(href, this.file.path);
        }
      });
    });
    const interactiveElements = this.previewContainer.querySelectorAll("input, button, a, .dataview, .task-list-item");
    interactiveElements.forEach((element) => {
      element.addEventListener("click", (event) => {
        event.stopPropagation();
      });
    });
  }
  handleTaskToggle(checkbox) {
    const isChecked = checkbox.checked;
    const listItem = checkbox.closest("li");
    if (!listItem)
      return;
    const taskText = this.getTaskTextFromListItem(listItem);
    if (!taskText)
      return;
    const lines = this.content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (this.isTaskLine(line) && this.getTaskTextFromLine(line) === taskText) {
        const newCheckState = isChecked ? "[x]" : "[ ]";
        lines[i] = line.replace(/\[[ x]\]/, newCheckState);
        this.content = lines.join("\n");
        clearTimeout(this.changeTimeout);
        this.changeTimeout = setTimeout(() => {
          this.onChange(this.content);
        }, 500);
        console.log(`\u2705 T\xE2che ${isChecked ? "coch\xE9e" : "d\xE9coch\xE9e"}: ${taskText}`);
        break;
      }
    }
  }
  getTaskTextFromListItem(listItem) {
    var _a;
    const textNode = listItem.childNodes[listItem.childNodes.length - 1];
    return ((_a = textNode == null ? void 0 : textNode.textContent) == null ? void 0 : _a.trim()) || null;
  }
  isTaskLine(line) {
    return /^[\s]*[-*+] \[[ x]\]/.test(line);
  }
  getTaskTextFromLine(line) {
    const match = line.match(/^[\s]*[-*+] \[[ x]\] (.+)$/);
    return match ? match[1].trim() : "";
  }
  renderSimpleMarkdown(content) {
    let html = content;
    html = html.replace(/\[\[([^\]]+)\]\]/g, '<span class="internal-link">$1</span>');
    html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
    html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
    html = html.replace(/^[\s]*[-*+] (.+)$/gm, "<li>$1</li>");
    const lines = html.split("\n");
    let result = "";
    let inList = false;
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.includes("<li>")) {
        if (!inList) {
          result += "<ul>\n";
          inList = true;
        }
        result += line + "\n";
      } else {
        if (inList) {
          result += "</ul>\n";
          inList = false;
        }
        if (trimmed === "") {
          result += "<br>\n";
        } else {
          result += `<p>${trimmed}</p>
`;
        }
      }
    }
    if (inList) {
      result += "</ul>\n";
    }
    return result;
  }
  renderEmptyState() {
    const placeholder = this.previewContainer.createDiv("empty-placeholder");
    placeholder.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      min-height: 80px;
      color: var(--text-muted);
      font-style: italic;
      cursor: text;
    `;
    placeholder.textContent = "Cliquez pour commencer \xE0 \xE9crire...";
  }
  setupPreviewEvents() {
    this.previewContainer.addEventListener("click", (event) => {
      const target = event.target;
      if (this.isInteractiveElement(target)) {
        console.log("\u{1F3AF} Clic sur \xE9l\xE9ment interactif, pas de mode \xE9dition");
        return;
      }
      console.log("\u{1F5B1}\uFE0F Clic sur preview \u2192 mode \xE9dition");
      this.enterEditMode();
    });
  }
  isInteractiveElement(element) {
    let current = element;
    while (current && current !== this.previewContainer) {
      const tagName = current.tagName.toLowerCase();
      const classList = Array.from(current.classList);
      if (["input", "button", "a", "select", "textarea"].includes(tagName)) {
        return true;
      }
      const interactiveClasses = [
        "internal-link",
        "external-link",
        "tag",
        "dataview",
        "task-list-item-checkbox",
        "task-list-item",
        "cm-hmd-codeblock",
        "block-language-dataview",
        "block-language-tasks"
      ];
      if (interactiveClasses.some((cls) => classList.includes(cls))) {
        return true;
      }
      if (current.hasAttribute("href") || current.hasAttribute("data-href") || current.hasAttribute("data-task") || current.hasAttribute("contenteditable")) {
        return true;
      }
      current = current.parentElement;
    }
    return false;
  }
  setupEditorEvents() {
    this.textArea.addEventListener("input", () => {
      this.content = this.textArea.value;
      clearTimeout(this.changeTimeout);
      this.changeTimeout = setTimeout(() => {
        this.onChange(this.content);
      }, 1e3);
    });
    this.textArea.addEventListener("blur", () => {
      console.log("\u{1F4DD} Blur sur textarea \u2192 mode preview");
      this.exitEditMode();
    });
    this.textArea.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        console.log("\u2328\uFE0F Escape \u2192 mode preview");
        this.exitEditMode();
      }
    });
  }
  enterEditMode() {
    this.isEditing = true;
    this.previewContainer.style.display = "none";
    this.editorContainer.style.display = "block";
    this.textArea.value = this.content;
    this.textArea.focus();
    console.log("\u270F\uFE0F Mode \xE9dition activ\xE9");
  }
  exitEditMode() {
    if (!this.isEditing)
      return;
    this.isEditing = false;
    this.content = this.textArea.value;
    this.editorContainer.style.display = "none";
    this.previewContainer.style.display = "block";
    this.renderContent();
    console.log("\u{1F441}\uFE0F Mode preview activ\xE9");
  }
  showPreview() {
    this.previewContainer.style.display = "block";
    this.editorContainer.style.display = "none";
    this.isEditing = false;
  }
  updateContent(section) {
    this.section = section;
    this.content = section.lines.join("\n");
    if (this.isEditing) {
      this.textArea.value = this.content;
    } else {
      this.renderContent();
    }
  }
  getContent() {
    return this.isEditing ? this.textArea.value : this.content;
  }
  destroy() {
    this.container.empty();
    console.log("\u{1F5D1}\uFE0F MarkdownFrame d\xE9truite");
  }
};

// src/views/BoardView.ts
var BOARD_VIEW_TYPE = "agile-board-view";
var BoardView = class extends import_obsidian.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.gridContainer = null;
    this.frames = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    console.log("\u{1F3AF} BoardView constructor appel\xE9");
  }
  getViewType() {
    return BOARD_VIEW_TYPE;
  }
  getDisplayText() {
    return this.file ? `${this.file.basename} (Board)` : "Agile Board";
  }
  getIcon() {
    return "layout-grid";
  }
  async onLoadFile(file) {
    console.log("\u{1F4C2} onLoadFile appel\xE9 pour:", file.basename);
    await this.renderBoardLayout();
  }
  async onUnloadFile(file) {
    console.log("\u{1F4C2} onUnloadFile appel\xE9 pour:", file.basename);
    this.cleanup();
  }
  // Méthode publique pour recharger le board
  async renderBoardLayout() {
    var _a;
    console.log("\u{1F3A8} renderBoardLayout d\xE9but");
    if (!this.file) {
      console.log("\u274C Pas de fichier dans renderBoardLayout");
      return;
    }
    console.log("\u{1F4C4} Fichier actuel:", this.file.basename);
    this.cleanup();
    const fileCache = this.app.metadataCache.getFileCache(this.file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    console.log("\u{1F3AF} Layout name d\xE9tect\xE9:", layoutName);
    if (!layoutName) {
      console.log("\u274C Pas de layout agile-board trouv\xE9");
      this.showNoLayoutMessage();
      return;
    }
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.log("\u274C Layout non trouv\xE9 dans le service");
      this.showLayoutNotFoundMessage(layoutName);
      return;
    }
    let sections = await this.plugin.fileService.parseSections(this.file);
    console.log("\u{1F4DA} Sections pars\xE9es:", Object.keys(sections));
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = this.plugin.fileService.getMissingSections(existingSections, requiredSections);
    if (missingSections.length > 0) {
      console.log("\u{1F527} Sections manquantes d\xE9tect\xE9es:", missingSections);
      this.showMissingSectionsMessage(missingSections, layout);
      return;
    }
    console.log("\u2705 Rendu Board pour:", this.file.basename, "avec layout:", layoutName);
    this.createGrid();
    this.createFrames(layout, sections);
  }
  cleanup() {
    for (const frame of this.frames.values()) {
      frame.destroy();
    }
    this.frames.clear();
    if (this.gridContainer) {
      this.gridContainer.remove();
      this.gridContainer = null;
    }
    this.contentEl.empty();
  }
  createGrid() {
    console.log("\u{1F532} Cr\xE9ation de la grille");
    this.gridContainer = this.contentEl.createDiv("agile-board-grid");
    this.gridContainer.style.cssText = `
      display: grid;
      grid-template-columns: repeat(24, 1fr);
      gap: 0.5rem;
      padding: 1rem;
      height: 100%;
      overflow: auto;
      background: var(--background-primary);
    `;
  }
  createFrames(layout, sections) {
    if (!this.gridContainer) {
      console.log("\u274C Pas de gridContainer pour cr\xE9er les frames");
      return;
    }
    console.log("\u{1F5BC}\uFE0F Cr\xE9ation de", layout.length, "frames");
    for (const block of layout) {
      console.log("\u{1F5BC}\uFE0F Cr\xE9ation frame pour:", block.title);
      const frameElement = this.gridContainer.createDiv("agile-board-frame");
      frameElement.style.cssText = `
        grid-column: ${block.x + 1} / span ${block.w};
        grid-row: ${block.y + 1} / span ${block.h};
        min-height: 100px;
        display: flex;
        flex-direction: column;
        border: 2px solid var(--background-modifier-border);
        border-radius: 6px;
        background: var(--background-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      `;
      const titleElement = frameElement.createDiv("frame-title");
      titleElement.style.cssText = `
        padding: 0.5rem 0.75rem;
        font-weight: 500;
        color: var(--text-normal);
        border-bottom: 1px solid var(--background-modifier-border);
        background: var(--background-secondary);
        font-size: 1.1rem;
      `;
      titleElement.textContent = block.title;
      const contentElement = frameElement.createDiv("frame-content");
      contentElement.style.cssText = `
        flex: 1;
        overflow: auto;
        background: var(--background-primary);
      `;
      const section = sections[block.title];
      if (section) {
        const frame = new MarkdownFrame(
          this.app,
          contentElement,
          this.file,
          section,
          (content) => this.onFrameContentChanged(block.title, content)
        );
        this.frames.set(block.title, frame);
        console.log(`\u2705 Frame \xE9ditable cr\xE9\xE9e pour "${block.title}"`);
      } else {
        contentElement.style.padding = "0.75rem";
        contentElement.innerHTML = `
          <p><strong>\u274C Section manquante:</strong> ${block.title}</p>
          <p><em>Sections disponibles:</em> ${Object.keys(sections).join(", ")}</p>
        `;
        console.log(`\u274C Section "${block.title}" non trouv\xE9e`);
      }
    }
    console.log("\u2705 Toutes les frames cr\xE9\xE9es");
  }
  async onFrameContentChanged(sectionName, content) {
    if (!this.file)
      return;
    console.log(`\u{1F4BE} Changement d\xE9tect\xE9 dans la section "${sectionName}"`);
    try {
      const fileContent = await this.app.vault.read(this.file);
      const lines = fileContent.split("\n");
      const sections = await this.plugin.fileService.parseSections(this.file);
      const section = sections[sectionName];
      if (!section) {
        console.log(`\u274C Section "${sectionName}" non trouv\xE9e pour la sauvegarde`);
        return;
      }
      const newLines = [
        ...lines.slice(0, section.start + 1),
        // Avant la section (inclus le titre)
        ...content.split("\n"),
        // Nouveau contenu
        ...lines.slice(section.end)
        // Après la section
      ];
      await this.app.vault.modify(this.file, newLines.join("\n"));
      console.log(`\u2705 Section "${sectionName}" sauvegard\xE9e`);
    } catch (error) {
      console.error(`\u274C Erreur sauvegarde section "${sectionName}":`, error);
    }
  }
  showNoLayoutMessage() {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("no-layout-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-muted);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Pas de layout agile-board</h3>
        <p>Cette note n'a pas de layout agile-board configur\xE9</p>
        <p>Ajoutez dans le frontmatter:<br><code>agile-board: layout_eisenhower</code></p>
      </div>
    `;
  }
  showLayoutNotFoundMessage(layoutName) {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("layout-not-found-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-error);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Layout "${layoutName}" introuvable</h3>
        <p>Layouts disponibles: ${this.plugin.layoutService.getAllModelNames().join(", ")}</p>
      </div>
    `;
  }
  showMissingSectionsMessage(missingBlocks, layout) {
    this.contentEl.empty();
    const errorContainer = this.contentEl.createDiv("missing-sections-overlay");
    errorContainer.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      height: 100%;
      padding: 2rem;
      text-align: center;
      background: var(--background-primary);
    `;
    const title = errorContainer.createEl("h2");
    title.textContent = "\u{1F527} Sections manquantes d\xE9tect\xE9es";
    title.style.cssText = `
      color: var(--text-normal);
      margin-bottom: 1rem;
    `;
    const description = errorContainer.createEl("p");
    description.textContent = "Les sections suivantes sont requises pour ce layout :";
    description.style.cssText = `
      color: var(--text-muted);
      margin-bottom: 1rem;
    `;
    const sectionsList = errorContainer.createEl("ul");
    sectionsList.style.cssText = `
      list-style: none;
      padding: 0;
      margin: 1rem 0;
      color: var(--text-normal);
    `;
    missingBlocks.forEach((section) => {
      const listItem = sectionsList.createEl("li");
      listItem.textContent = `# ${section}`;
      listItem.style.cssText = `
        font-family: var(--font-monospace);
        background: var(--background-secondary);
        padding: 0.5rem;
        margin: 0.25rem 0;
        border-radius: 4px;
      `;
    });
    const buttonContainer = errorContainer.createDiv();
    buttonContainer.style.cssText = `
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    `;
    const autoCreateButton = buttonContainer.createEl("button", { cls: "mod-cta" });
    autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
    autoCreateButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--interactive-accent);
      color: var(--text-on-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    autoCreateButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      console.log("\u{1F527} Cr\xE9ation automatique des sections manquantes...");
      autoCreateButton.textContent = "\u23F3 Cr\xE9ation...";
      autoCreateButton.disabled = true;
      try {
        await this.plugin.fileService.createMissingSections(this.file, layout);
        console.log("\u2705 Sections cr\xE9\xE9es, rechargement du board...");
        setTimeout(() => {
          this.renderBoardLayout();
        }, 500);
      } catch (error) {
        console.error("\u274C Erreur cr\xE9ation sections:", error);
        autoCreateButton.textContent = "\u274C Erreur";
        setTimeout(() => {
          autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
          autoCreateButton.disabled = false;
        }, 2e3);
      }
    });
    const markdownButton = buttonContainer.createEl("button");
    markdownButton.textContent = "\u{1F4DD} Mode Markdown";
    markdownButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--background-secondary);
      color: var(--text-normal);
      border: 1px solid var(--background-modifier-border);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    markdownButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      const leaf = this.app.workspace.activeLeaf;
      if (leaf) {
        await leaf.setViewState({
          type: "markdown",
          state: { file: this.file.path }
        });
      }
    });
  }
};

// src/managers/ViewSwitcher.ts
var import_obsidian2 = require("obsidian");
var ViewSwitcher = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async switchToBoardView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: BOARD_VIEW_TYPE,
        state: { file: file.path }
      });
      console.log("\u{1F3AF} Basculement vers Board View");
    }
  }
  async switchToMarkdownView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: "markdown",
        state: { file: file.path }
      });
      console.log("\u{1F4DD} Basculement vers Markdown View");
    }
  }
  isCurrentViewBoardView() {
    return this.plugin.app.workspace.getActiveViewOfType(BoardView) !== null;
  }
  isCurrentViewMarkdownView() {
    return this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView) !== null;
  }
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    return ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]) !== void 0;
  }
  addSwitchButton() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.path === file.path) {
          setTimeout(() => this.updateSwitchButtonForFile(file), 100);
        }
      })
    );
    setTimeout(() => this.updateSwitchButton(), 100);
  }
  updateSwitchButtonForFile(file) {
    const hasLayout = this.hasAgileBoardLayout(file);
    if (hasLayout) {
      if (this.isCurrentViewMarkdownView()) {
        this.ensureBoardModeButton();
      } else if (this.isCurrentViewBoardView()) {
        this.ensureNormalModeButton();
      }
    } else {
      this.removeSwitchButtons();
    }
  }
  updateSwitchButton() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const hasLayout = this.hasAgileBoardLayout(activeFile);
    if (!hasLayout) {
      this.removeSwitchButtons();
      return;
    }
    if (this.isCurrentViewMarkdownView()) {
      this.ensureBoardModeButton();
    } else if (this.isCurrentViewBoardView()) {
      this.ensureNormalModeButton();
    } else {
      this.removeSwitchButtons();
    }
  }
  ensureBoardModeButton() {
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!markdownView)
      return;
    const viewActions = markdownView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = markdownView.addAction("layout-grid", "Mode Board", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToBoardView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "board-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Board ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Board:", error);
    }
  }
  ensureNormalModeButton() {
    const boardView = this.plugin.app.workspace.getActiveViewOfType(BoardView);
    if (!boardView)
      return;
    const viewActions = boardView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = boardView.addAction("document", "Mode Markdown", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToMarkdownView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "normal-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Markdown ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Markdown:", error);
    }
  }
  removeSwitchButtons() {
    const buttons = document.querySelectorAll(".agile-board-switch-button");
    buttons.forEach((button) => button.remove());
  }
  stop() {
    this.removeSwitchButtons();
  }
};

// src/managers/ModelDetector.ts
var ModelDetector = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.processedFiles = /* @__PURE__ */ new Set();
  }
  onLoad() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        this.handleMetadataChanged(file);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          if (activeFile) {
            this.handleFileOpen(activeFile);
          }
        }, 100);
      })
    );
    setTimeout(() => {
      this.processAllOpenFiles();
    }, 1e3);
  }
  onUnload() {
    this.processedFiles.clear();
  }
  handleMetadataChanged(file) {
    console.log("\u{1F4DD} M\xE9tadonn\xE9es chang\xE9es pour:", file.basename);
    this.processFile(file);
  }
  handleFileOpen(file) {
    console.log("\u{1F4C2} Fichier ouvert:", file.basename);
    this.processFile(file);
  }
  processAllOpenFiles() {
    console.log("\u{1F50D} Traitement initial de tous les fichiers ouverts...");
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === "markdown" && view.file) {
        this.processFile(view.file);
      }
    });
  }
  processFile(file) {
    if (!file.path.endsWith(".md"))
      return;
    const fileKey = `${file.path}-${file.stat.mtime}`;
    if (this.processedFiles.has(fileKey))
      return;
    this.processedFiles.add(fileKey);
    this.cleanupProcessedFiles();
    const hasLayout = this.hasAgileBoardLayout(file);
    console.log(`\u{1F3AF} Fichier "${file.basename}" - Layout agile-board: ${hasLayout ? "OUI" : "NON"}`);
    setTimeout(() => {
      this.plugin.viewSwitcher.updateSwitchButtonForFile(file);
    }, 50);
  }
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return false;
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.warn(`\u26A0\uFE0F Layout "${layoutName}" sp\xE9cifi\xE9 mais non trouv\xE9`);
      return false;
    }
    return true;
  }
  cleanupProcessedFiles() {
    if (this.processedFiles.size > 100) {
      const entries = Array.from(this.processedFiles);
      const toKeep = entries.slice(-50);
      this.processedFiles.clear();
      toKeep.forEach((entry) => this.processedFiles.add(entry));
    }
  }
  forceUpdate() {
    this.processedFiles.clear();
    this.processAllOpenFiles();
  }
};

// src/types/index.ts
var DEFAULT_LAYOUTS = {
  EISENHOWER: "layout_eisenhower",
  KANBAN: "layout_kanban",
  GTD: "layout_gtd",
  WEEKLY: "layout_weekly",
  DAILY: "layout_daily"
};

// src/utils/settings.ts
function createDefaultSettings() {
  return {
    defaultModel: DEFAULT_LAYOUTS.EISENHOWER,
    autoSwitchEnabled: true,
    debounceDelay: 1e3
  };
}

// src/main.ts
var AgileBoardPlugin = class extends import_obsidian3.Plugin {
  /**
   * Initialisation du plugin
   */
  async onload() {
    console.log("\u{1F680} Loading Agile Board Plugin...");
    try {
      await this.loadSettings();
      await this.initializeServices();
      this.registerView(BOARD_VIEW_TYPE, (leaf) => new BoardView(leaf, this));
      await this.initializeManagers();
      this.registerCommands();
      this.addStatusBarItem().setText("Agile Board Ready");
      console.log("\u2705 Agile Board Plugin loaded successfully");
      console.log("\u{1F4CB} Layouts disponibles:", this.layoutService.getAllModelNames());
    } catch (error) {
      console.error("\u274C Erreur lors du chargement du plugin:", error);
    }
  }
  /**
   * Nettoyage lors du déchargement du plugin
   */
  async onunload() {
    var _a, _b;
    console.log("\u{1F6D1} Unloading Agile Board Plugin...");
    (_a = this.modelDetector) == null ? void 0 : _a.onUnload();
    (_b = this.viewSwitcher) == null ? void 0 : _b.stop();
    console.log("\u2705 Agile Board Plugin unloaded");
  }
  /**
   * Initialise tous les services
   */
  async initializeServices() {
    this.layoutService = new LayoutService(this);
    this.layoutService.load();
    this.fileService = new FileService(this.app);
  }
  /**
   * Initialise tous les managers
   */
  async initializeManagers() {
    this.viewSwitcher = new ViewSwitcher(this);
    this.modelDetector = new ModelDetector(this);
    this.viewSwitcher.addSwitchButton();
    this.modelDetector.onLoad();
  }
  /**
   * Enregistre toutes les commandes du plugin
   */
  registerCommands() {
    this.addCommand({
      id: "switch-to-board-view",
      name: "Switch to Board View",
      callback: () => this.activateBoardView()
    });
    this.registerCreationCommands();
    this.registerUtilityCommands();
  }
  /**
   * Enregistre les commandes de création de notes
   */
  registerCreationCommands() {
    const layouts = [
      { id: "eisenhower", name: "Eisenhower Matrix" },
      { id: "kanban", name: "Kanban Board" },
      { id: "gtd", name: "GTD Board" },
      { id: "weekly", name: "Weekly Planner" },
      { id: "daily", name: "Daily Planner" },
      { id: "project", name: "Project Board" },
      { id: "simple", name: "Simple Board" },
      { id: "cornell", name: "Cornell Notes" },
      { id: "tasks-dashboard", name: "Tasks Dashboard" },
      { id: "dataview-analytics", name: "Dataview Analytics" }
    ];
    layouts.forEach((layout) => {
      this.addCommand({
        id: `create-${layout.id}-note`,
        name: `Create ${layout.name} Note`,
        callback: () => this.createNoteWithLayout(`layout_${layout.id.replace("-", "_")}`)
      });
    });
  }
  /**
   * Enregistre les commandes utilitaires
   */
  registerUtilityCommands() {
    this.addCommand({
      id: "list-layouts",
      name: "List Available Layouts",
      callback: () => this.showAvailableLayouts()
    });
    this.addCommand({
      id: "create-missing-sections",
      name: "Create Missing Sections for Current Layout",
      checkCallback: (checking) => {
        var _a;
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        const fileCache = this.app.metadataCache.getFileCache(activeFile);
        const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
        if (!layoutName)
          return false;
        if (!checking) {
          this.createMissingSectionsForCurrentFile();
        }
        return true;
      }
    });
    this.addCommand({
      id: "force-update-buttons",
      name: "Force Update Board Buttons",
      callback: () => {
        this.modelDetector.forceUpdate();
        console.log("\u{1F504} Boutons mis \xE0 jour manuellement");
      }
    });
  }
  /**
   * Active la vue Board pour le fichier actuel
   */
  async activateBoardView() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      console.log("\u274C Aucun fichier actif");
      return;
    }
    const leaf = this.app.workspace.activeLeaf;
    if (leaf) {
      await leaf.setViewState({
        type: BOARD_VIEW_TYPE,
        state: { file: activeFile.path }
      });
      console.log("\u{1F3AF} Basculement vers Board View pour:", activeFile.basename);
    }
  }
  /**
   * Crée une note avec un layout spécifique
   */
  async createNoteWithLayout(layoutName) {
    const layout = this.layoutService.getModel(layoutName);
    if (!layout) {
      console.error(`\u274C Layout "${layoutName}" non trouv\xE9`);
      return;
    }
    const frontmatter = `---
agile-board: ${layoutName}
---

`;
    const sections = layout.map((block) => `# ${block.title}

`).join("");
    const content = frontmatter + sections;
    const layoutDisplayName = this.layoutService.getLayoutDisplayName(layoutName);
    const timestamp = new Date().toISOString().split("T")[0];
    const fileName = `${layoutDisplayName} ${timestamp}.md`;
    try {
      const file = await this.app.vault.create(fileName, content);
      await this.app.workspace.getLeaf().openFile(file);
      console.log(`\u2705 Note "${fileName}" cr\xE9\xE9e avec layout ${layoutName}`);
    } catch (error) {
      console.error(`\u274C Erreur cr\xE9ation note:`, error);
    }
  }
  /**
   * Affiche la liste des layouts disponibles
   */
  showAvailableLayouts() {
    const layouts = this.layoutService.getAllModelsInfo();
    let message = "Layouts disponibles :\n\n";
    layouts.forEach((layout) => {
      message += `\u2022 **${layout.displayName}** (${layout.blockCount} sections)
`;
      message += `  Sections: ${layout.sections.join(", ")}

`;
    });
    const modal = new (require("obsidian")).Modal(this.app);
    modal.contentEl.innerHTML = `
      <h2>Layouts Agile Board</h2>
      <div style="white-space: pre-wrap; font-family: var(--font-text);">${message}</div>
    `;
    modal.open();
  }
  /**
   * Crée les sections manquantes pour le fichier actuel
   */
  async createMissingSectionsForCurrentFile() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const fileCache = this.app.metadataCache.getFileCache(activeFile);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return;
    const layout = this.layoutService.getModel(layoutName);
    if (!layout)
      return;
    try {
      const sectionsCreated = await this.fileService.createMissingSections(activeFile, layout);
      if (sectionsCreated) {
        console.log("\u2705 Sections manquantes cr\xE9\xE9es pour:", activeFile.basename);
        const boardView = this.app.workspace.getActiveViewOfType(BoardView);
        if (boardView) {
          setTimeout(() => {
            boardView.renderBoardLayout();
          }, 500);
        }
      } else {
        console.log("\u2139\uFE0F Aucune section manquante \xE0 cr\xE9er");
      }
    } catch (error) {
      console.error("\u274C Erreur lors de la cr\xE9ation des sections:", error);
    }
  }
  /**
   * Charge les paramètres du plugin
   */
  async loadSettings() {
    this.settings = Object.assign({}, createDefaultSettings(), await this.loadData());
  }
  /**
   * Sauvegarde les paramètres du plugin
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
