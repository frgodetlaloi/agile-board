/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgileBoardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var import_obsidian8 = require("obsidian");

// src/types.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["ERROR"] = 0] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 1] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 3] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 4] = "VERBOSE";
  return LogLevel2;
})(LogLevel || {});

// src/services/LoggerService.ts
var LoggerService = class {
  // Buffer de strings
  constructor(plugin, settings) {
    this.logBuffer = [];
    this.plugin = plugin;
    this.settings = settings;
  }
  /**
   * Met Ã  jour les paramÃ¨tres de debug
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Ajoute un message au buffer
   */
  addToBuffer(level, message, data, source) {
    const timestamp = new Date().toISOString();
    const levelStr = LogLevel[level];
    const dataStr = data ? ` | Data: ${JSON.stringify(data)}` : "";
    const sourceStr = source ? ` | Source: ${source}` : "";
    const logEntry = `[${timestamp}] ${levelStr}: ${message}${dataStr}${sourceStr}`;
    this.logBuffer.push(logEntry);
    if (this.logBuffer.length > 1e3) {
      this.logBuffer = this.logBuffer.slice(-500);
    }
  }
  /**
   * Log d'erreur
   */
  error(message, error, source) {
    if (!this.settings.enabled || this.settings.logLevel < 0 /* ERROR */)
      return;
    this.addToBuffer(0 /* ERROR */, message, error, source);
    if (this.settings.logToConsole) {
      console.error(`\u274C [Agile-Board] ${message}`, error);
    }
  }
  /**
   * Log d'avertissement
   */
  warn(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 1 /* WARN */)
      return;
    this.addToBuffer(1 /* WARN */, message, data, source);
    if (this.settings.logToConsole) {
      console.warn(`\u26A0\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log d'information
   */
  info(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 2 /* INFO */)
      return;
    this.addToBuffer(2 /* INFO */, message, data, source);
    if (this.settings.logToConsole) {
      console.info(`\u2139\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de debug
   */
  debug(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 3 /* DEBUG */)
      return;
    this.addToBuffer(3 /* DEBUG */, message, data, source);
    if (this.settings.logToConsole) {
      console.debug(`\u{1F527} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log verbose
   */
  verbose(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 4 /* VERBOSE */)
      return;
    this.addToBuffer(4 /* VERBOSE */, message, data, source);
    if (this.settings.logToConsole) {
      console.debug(`\u{1F50D} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de dÃ©marrage (toujours affichÃ©)
   */
  startup(message, data) {
    this.addToBuffer(2 /* INFO */, `STARTUP: ${message}`, data, "startup");
    console.log(`\u{1F680} [Agile-Board] ${message}`, data);
  }
  /**
   * Log de succÃ¨s
   */
  success(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 2 /* INFO */)
      return;
    this.addToBuffer(2 /* INFO */, `SUCCESS: ${message}`, data, source);
    if (this.settings.logToConsole) {
      console.log(`\u2705 [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de configuration
   */
  config(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 3 /* DEBUG */)
      return;
    this.addToBuffer(3 /* DEBUG */, `CONFIG: ${message}`, data, "config");
    if (this.settings.logToConsole) {
      console.debug(`\u2699\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de navigation
   */
  navigation(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 4 /* VERBOSE */)
      return;
    this.addToBuffer(4 /* VERBOSE */, `NAV: ${message}`, data, "navigation");
    if (this.settings.logToConsole) {
      console.debug(`\u{1F9ED} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log d'opÃ©ration sur fichier
   */
  fileOperation(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 3 /* DEBUG */)
      return;
    this.addToBuffer(3 /* DEBUG */, `FILE: ${message}`, data, "file");
    if (this.settings.logToConsole) {
      console.debug(`\u{1F4C1} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Test du systÃ¨me de logging
   */
  testSystem() {
    this.info("Test du syst\xE8me de logging lanc\xE9");
    this.debug("Message de debug test");
    this.verbose("Message verbeux test");
    this.warn("Message d'avertissement test");
    this.error("Message d'erreur test (test uniquement)");
    this.success("Test du syst\xE8me de logging termin\xE9");
  }
  /**
   * Retourne les statistiques du logger
   */
  getStats() {
    return {
      totalLogs: this.logBuffer.length,
      // Pour un buffer de strings, on analyse le contenu pour compter par type
      errorCount: this.logBuffer.filter(
        (log) => log.includes("ERROR:") || log.includes("\u274C") || log.includes("Message d'erreur")
      ).length,
      warningCount: this.logBuffer.filter(
        (log) => log.includes("WARN:") || log.includes("\u26A0\uFE0F") || log.includes("Message d'avertissement")
      ).length,
      debugCount: this.logBuffer.filter(
        (log) => log.includes("DEBUG:") || log.includes("\u{1F527}") || log.includes("VERBOSE:") || log.includes("\u{1F50D}")
      ).length,
      lastLogTime: new Date().toISOString(),
      // Timestamp actuel
      bufferSize: this.logBuffer.length,
      isEnabled: this.settings.enabled,
      currentLevel: LogLevel[this.settings.logLevel],
      fileLoggingEnabled: this.settings.logToFile
    };
  }
  /**
   * Vide le buffer de logs
   */
  clearBuffer() {
    this.logBuffer.length = 0;
    this.debug("Buffer de logs vid\xE9");
  }
  /**
   * Retourne tout le contenu du buffer
   */
  getBuffer() {
    return [...this.logBuffer];
  }
  /**
   * Sauvegarde les logs dans un fichier
   */
  async saveLogsToFile() {
    if (!this.settings.logToFile || this.logBuffer.length === 0) {
      return;
    }
    try {
      const fileName = this.settings.logFileName || "agile-board-debug.log";
      const content = this.logBuffer.join("\n");
      const adapter = this.plugin.app.vault.adapter;
      const exists = await adapter.exists(fileName);
      if (exists) {
        const existingContent = await adapter.read(fileName);
        const newContent = existingContent + "\n" + content;
        if (newContent.length > (this.settings.maxLogFileSize || 5 * 1024 * 1024)) {
          const lines = newContent.split("\n");
          const halfLines = lines.slice(Math.floor(lines.length / 2));
          await adapter.write(fileName, halfLines.join("\n"));
        } else {
          await adapter.write(fileName, newContent);
        }
      } else {
        await adapter.write(fileName, content);
      }
      this.debug(`Logs sauvegard\xE9s dans ${fileName} (${this.logBuffer.length} entr\xE9es)`);
    } catch (error) {
      console.error("[Agile-Board] Erreur lors de la sauvegarde des logs:", error);
    }
  }
  /**
   * Formate un message de log avec horodatage et source
   */
  formatLogMessage(level, message, source) {
    const timestamp = this.settings.showTimestamps ? `[${new Date().toISOString()}] ` : "";
    const sourceStr = this.settings.showSourceLocation && source ? ` (${source})` : "";
    const levelStr = LogLevel[level];
    return `${timestamp}${levelStr}: ${message}${sourceStr}`;
  }
  /**
   * Retourne la configuration actuelle
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Active ou dÃ©sactive le logging
   */
  setEnabled(enabled) {
    this.settings.enabled = enabled;
    this.config(`Logging ${enabled ? "activ\xE9" : "d\xE9sactiv\xE9"}`);
  }
  /**
   * Change le niveau de log
   */
  setLogLevel(level) {
    this.settings.logLevel = level;
    this.config(`Niveau de log chang\xE9 vers: ${LogLevel[level]}`);
  }
};

// src/components/SettingsTab.ts
var import_obsidian = require("obsidian");
var AgileBoardSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Agile Board - Configuration" });
    this.createDebugSection(containerEl);
    this.createGeneralSection(containerEl);
  }
  /**
   * CrÃ©e la section de configuration du debug
   */
  createDebugSection(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F527} Configuration du Debug" });
    const debugDesc = containerEl.createEl("div", { cls: "setting-item-description" });
    debugDesc.innerHTML = `
            <p>Configurez le niveau de verbosit\xE9 et les options de debug du plugin.</p>
            <p><strong>Conseil :</strong> Gardez le debug <em>d\xE9sactiv\xE9</em> en usage normal pour optimiser les performances.</p>
        `;
    new import_obsidian.Setting(containerEl).setName("Activer le debug").setDesc("Active ou d\xE9sactive compl\xE8tement le syst\xE8me de debug").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.enabled).onChange(async (value) => {
      this.plugin.settings.debug.enabled = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Debug ${value ? "activ\xE9" : "d\xE9sactiv\xE9"}`);
      this.display();
    }));
    if (this.plugin.settings.debug.enabled) {
      this.createDebugAdvancedOptions(containerEl);
    }
  }
  /**
   * CrÃ©e les options avancÃ©es de debug (quand activÃ©)
   */
  createDebugAdvancedOptions(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Niveau de verbosit\xE9").setDesc("Contr\xF4le la quantit\xE9 d'informations affich\xE9es dans les logs").addDropdown((dropdown) => dropdown.addOption(0 /* ERROR */.toString(), "\u274C Erreurs uniquement").addOption(1 /* WARN */.toString(), "\u26A0\uFE0F Erreurs + Avertissements").addOption(2 /* INFO */.toString(), "\u2139\uFE0F Informations importantes (recommand\xE9)").addOption(3 /* DEBUG */.toString(), "\u{1F527} Debug d\xE9taill\xE9").addOption(4 /* VERBOSE */.toString(), "\u{1F50D} Tout afficher (tr\xE8s verbeux)").setValue(this.plugin.settings.debug.logLevel.toString()).onChange(async (value) => {
      this.plugin.settings.debug.logLevel = parseInt(value);
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Niveau de debug: ${LogLevel[parseInt(value)]}`);
    }));
    new import_obsidian.Setting(containerEl).setName("Afficher les timestamps").setDesc("Ajoute l'heure pr\xE9cise \xE0 chaque message de log").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.showTimestamps).onChange(async (value) => {
      this.plugin.settings.debug.showTimestamps = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Afficher la source").setDesc("Indique le fichier source de chaque message de log").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.showSourceLocation).onChange(async (value) => {
      this.plugin.settings.debug.showSourceLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sauvegarder dans un fichier").setDesc("Enregistre automatiquement les logs dans un fichier de votre vault").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.logToFile).onChange(async (value) => {
      this.plugin.settings.debug.logToFile = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.debug.logToFile) {
      this.createFileLoggingOptions(containerEl);
    }
    this.createDebugActions(containerEl);
  }
  /**
   * CrÃ©e les options de sauvegarde fichier
   */
  createFileLoggingOptions(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Nom du fichier de log").setDesc("Nom du fichier o\xF9 sauvegarder les logs (dans la racine du vault)").addText((text) => text.setPlaceholder("agile-board-debug.log").setValue(this.plugin.settings.debug.logFileName).onChange(async (value) => {
      this.plugin.settings.debug.logFileName = value || "agile-board-debug.log";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Taille maximale du fichier").setDesc("Taille maximale en KB avant rotation automatique").addSlider((slider) => slider.setLimits(100, 1e4, 100).setValue(this.plugin.settings.debug.maxLogFileSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.debug.maxLogFileSize = value;
      await this.plugin.saveSettings();
    }));
  }
  /**
   * CrÃ©e les boutons d'action pour le debug
   */
  createDebugActions(containerEl) {
    const actionsContainer = containerEl.createDiv("debug-actions");
    actionsContainer.style.cssText = `
            margin-top: 20px;
            padding: 15px;
            background-color: var(--background-secondary);
            border-radius: 6px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        `;
    const testButton = actionsContainer.createEl("button", {
      text: "\u{1F9EA} Tester le syst\xE8me",
      cls: "mod-cta"
    });
    testButton.onclick = () => {
      this.plugin.logger.testSystem();
      new import_obsidian.Notice("Test de debug ex\xE9cut\xE9 - v\xE9rifiez la console (F12)", 3e3);
    };
    if (this.plugin.settings.debug.logToFile) {
      const saveButton = actionsContainer.createEl("button", {
        text: "\u{1F4BE} Sauvegarder maintenant"
      });
      saveButton.onclick = async () => {
        await this.plugin.logger.saveLogsToFile();
        new import_obsidian.Notice("Logs sauvegard\xE9s", 2e3);
      };
    }
    const statsButton = actionsContainer.createEl("button", {
      text: "\u{1F4CA} Statistiques"
    });
    statsButton.onclick = () => this.showDebugStats();
    const clearButton = actionsContainer.createEl("button", {
      text: "\u{1F5D1}\uFE0F Vider le buffer"
    });
    clearButton.onclick = () => {
      this.plugin.logger.clearBuffer();
      new import_obsidian.Notice("Buffer de logs vid\xE9", 2e3);
    };
  }
  /**
   * Affiche les statistiques de debug dans une notification
   */
  showDebugStats() {
    const stats = this.plugin.logger.getStats();
    const message = `\u{1F4CA} Statistiques de Debug:

\u2022 Statut: ${stats.isEnabled ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9"}
\u2022 Niveau: ${stats.currentLevel}
\u2022 Buffer: ${stats.bufferSize} entr\xE9es
\u2022 Fichier: ${stats.fileLoggingEnabled ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9"}`;
    new import_obsidian.Notice(message, 6e3);
  }
  /**
   * CrÃ©e la section de configuration gÃ©nÃ©rale
   */
  createGeneralSection(containerEl) {
    containerEl.createEl("h2", { text: "\u2699\uFE0F Param\xE8tres G\xE9n\xE9raux" });
    new import_obsidian.Setting(containerEl).setName("Cr\xE9ation automatique des sections").setDesc("Cr\xE9e automatiquement les sections manquantes lors de l'ouverture d'un board").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCreateSections).onChange(async (value) => {
      this.plugin.settings.autoCreateSections = value;
      await this.plugin.saveSettings();
      this.plugin.logger.config("Auto-cr\xE9ation sections modifi\xE9e", { enabled: value });
    }));
    const layoutDesc = containerEl.createEl("div", { cls: "setting-item-description" });
    layoutDesc.innerHTML = `
            <p><strong>Layouts disponibles:</strong> Eisenhower, Kanban, GTD, Weekly Planner, Daily Planner, Project Board, Cornell Notes, Tasks Dashboard</p>
        `;
  }
};

// src/utils/settings.ts
var DEFAULT_SETTINGS = {
  autoCreateSections: true,
  defaultLayouts: ["layout_kanban", "layout_eisenhower", "layout_gtd"],
  debug: {
    enabled: false,
    logLevel: 2 /* INFO */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: false,
    logToConsole: true,
    // â† AjoutÃ©
    logFileName: "agile-board-debug.log",
    maxLogFileSize: 5 * 1024 * 1024
    // 5MB
  }
};
var DEV_SETTINGS = {
  debug: {
    enabled: true,
    logLevel: 4 /* VERBOSE */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: false,
    logToConsole: true,
    // â† AjoutÃ©
    logFileName: "agile-board-debug.log",
    maxLogFileSize: 5 * 1024 * 1024
  }
};
var PROD_WITH_LOGS_SETTINGS = {
  debug: {
    enabled: true,
    logLevel: 3 /* DEBUG */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: true,
    logToConsole: false,
    // â† AjoutÃ© (false pour la production)
    logFileName: "agile-board-debug.log",
    maxLogFileSize: 5 * 1024 * 1024
  }
};

// src/constants/layouts.ts
var BUILT_IN_LAYOUTS = {
  // ===========================================================================
  // SECTION 1 : LAYOUTS DE PRODUCTIVITÃ‰ ET PRIORISATION
  // ===========================================================================
  /**
   * MATRICE D'EISENHOWER - SystÃ¨me de priorisation prÃ©sidentiel
   * 
   * MÃ‰THODOLOGIE :
   * CrÃ©Ã©e par le prÃ©sident Dwight D. Eisenhower, cette matrice classe
   * les tÃ¢ches selon deux axes orthogonaux : Urgent vs Important.
   * 
   * PHILOSOPHIE :
   * "Ce qui est important est rarement urgent et ce qui est urgent 
   * est rarement important." - Eisenhower
   * 
   * QUADRANTS :
   * 1. Urgent ET Important (Q1) â†’ FAIRE immÃ©diatement
   * 2. Important mais PAS Urgent (Q2) â†’ PLANIFIER (zone optimale)
   * 3. Urgent mais PAS Important (Q3) â†’ DÃ‰LÃ‰GUER
   * 4. NI Urgent NI Important (Q4) â†’ Ã‰LIMINER
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ URGENT ET       â”‚ PAS URGENT      â”‚
   * â”‚ IMPORTANT       â”‚ MAIS IMPORTANT  â”‚
   * â”‚ âš¡ DO NOW âš¡    â”‚ ğŸ“… SCHEDULE ğŸ“…  â”‚
   * â”‚ (Crises,        â”‚ (Planification, â”‚
   * â”‚  Urgences)      â”‚  PrÃ©vention)    â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ URGENT MAIS     â”‚ NI URGENT       â”‚
   * â”‚ PAS IMPORTANT   â”‚ NI IMPORTANT    â”‚
   * â”‚ ğŸ‘¥ DELEGATE ğŸ‘¥  â”‚ ğŸ—‘ï¸ DELETE ğŸ—‘ï¸   â”‚
   * â”‚ (Interruptions, â”‚ (Distractions,  â”‚
   * â”‚  Certains mails)â”‚  RÃ©seaux soc.)  â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 4 quadrants de 12Ã—12 chacun
   * CAS D'USAGE : Gestion quotidienne, dÃ©cisions stratÃ©giques, leadership
   */
  layout_eisenhower: [
    {
      title: "Urgent et Important",
      x: 0,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q1 : Actions immÃ©diates, gestion de crise
    },
    {
      title: "Pas urgent mais Important",
      x: 12,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q2 : Zone optimale de productivitÃ©, planification
    },
    {
      title: "Urgent mais Pas important",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q3 : Candidats Ã  la dÃ©lÃ©gation
    },
    {
      title: "Ni urgent ni important",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q4 : ActivitÃ©s Ã  Ã©liminer ou rÃ©duire
    }
  ],
  /**
   * GETTING THINGS DONE (GTD) - MÃ©thode David Allen
   * 
   * MÃ‰THODOLOGIE :
   * SystÃ¨me complet de productivitÃ© dÃ©veloppÃ© par David Allen.
   * BasÃ© sur l'externalisation de la mÃ©moire et la clarification systÃ©matique.
   * 
   * PRINCIPE CENTRAL :
   * "Votre esprit est fait pour avoir des idÃ©es, pas pour les retenir."
   * 
   * FLUX GTD :
   * CAPTURER â†’ CLARIFIER â†’ ORGANISER â†’ RÃ‰VISER â†’ FAIRE
   * 
   * ZONES FONCTIONNELLES :
   * 1. Inbox : Capture de tout ce qui arrive
   * 2. Actions suivantes : TÃ¢ches concrÃ¨tes et faisables
   * 3. En attente : DÃ©lÃ©guÃ© ou dÃ©pendant d'autres
   * 4. Projets : RÃ©sultats nÃ©cessitant plusieurs actions
   * 5. Someday/Maybe : IdÃ©es pour le futur
   * 6. RÃ©fÃ©rence : Informations Ã  conserver
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚   ğŸ“¥ INBOX   â”‚ â¡ï¸ ACTIONS   â”‚
   * â”‚              â”‚   SUIVANTES  â”‚
   * â”‚ (Collecte    â”‚ (Prochaines  â”‚
   * â”‚  rapide)     â”‚  tÃ¢ches)     â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚â³ EN â”‚ğŸ“‹ PROJâ”‚ğŸ¤” SM â”‚       â”‚
   * â”‚ATTEN.â”‚   ETS â”‚  /M  â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ“š RÃ‰FÃ‰RENCE           â”‚
   * â”‚   (Documentation,           â”‚
   * â”‚    informations)            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : OptimisÃ©e pour le flux GTD
   * CAS D'USAGE : ProductivitÃ© personnelle, gestion complÃ¨te des tÃ¢ches
   */
  layout_gtd: [
    {
      title: "Inbox",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Zone de capture : tout ce qui arrive sans traitement
    },
    {
      title: "Actions suivantes",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // TÃ¢ches clarifiÃ©es et prÃªtes Ã  Ãªtre exÃ©cutÃ©es
    },
    {
      title: "En attente",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // DÃ©lÃ©guÃ© ou en attente de quelqu'un/quelque chose d'autre
    },
    {
      title: "Projets",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // RÃ©sultats dÃ©sirÃ©s nÃ©cessitant plus d'une action
    },
    {
      title: "Someday Maybe",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // IdÃ©es intÃ©ressantes pour plus tard
    },
    {
      title: "R\xE9f\xE9rence",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Informations utiles Ã  conserver pour consultation
    }
  ],
  // ===========================================================================
  // SECTION 2 : LAYOUTS DE FLUX DE TRAVAIL (WORKFLOW)
  // ===========================================================================
  /**
   * TABLEAU KANBAN CLASSIQUE - Visualisation du flux de travail
   * 
   * MÃ‰THODOLOGIE :
   * Originaire du systÃ¨me de production Toyota, adaptÃ© au travail intellectuel.
   * Principe : visualiser le travail, limiter le travail en cours (WIP).
   * 
   * PHILOSOPHIE :
   * Flux tirÃ© (pull) plutÃ´t que poussÃ© (push).
   * Optimisation du dÃ©bit global plutÃ´t que de l'efficacitÃ© locale.
   * 
   * COLONNES STANDARD :
   * 1. Ã€ faire (Backlog) : TÃ¢ches en attente
   * 2. En cours (Doing/WIP) : Travail actuel (limitÃ©)
   * 3. TerminÃ© (Done) : Travail complÃ©tÃ©
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚            â”‚            â”‚            â”‚
   * â”‚  ğŸ“‹ Ã€      â”‚  âš™ï¸ EN     â”‚  âœ… TERMI- â”‚
   * â”‚   FAIRE    â”‚   COURS    â”‚    NÃ‰      â”‚
   * â”‚            â”‚            â”‚            â”‚
   * â”‚ â€¢ TÃ¢che A  â”‚ â€¢ TÃ¢che X  â”‚ â€¢ TÃ¢che 1  â”‚
   * â”‚ â€¢ TÃ¢che B  â”‚ â€¢ TÃ¢che Y  â”‚ â€¢ TÃ¢che 2  â”‚
   * â”‚ â€¢ TÃ¢che C  â”‚            â”‚ â€¢ TÃ¢che 3  â”‚
   * â”‚ â€¢ ...      â”‚ [WIP: 2]   â”‚ â€¢ ...      â”‚
   * â”‚            â”‚            â”‚            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 3 colonnes Ã©gales sur toute la hauteur
   * CAS D'USAGE : DÃ©veloppement logiciel, gestion d'Ã©quipe, projets itÃ©ratifs
   */
  layout_kanban: [
    {
      title: "\xC0 faire",
      x: 0,
      y: 0,
      w: 8,
      h: 24
      // Backlog : tÃ¢ches priorisÃ©es en attente
    },
    {
      title: "En cours",
      x: 8,
      y: 0,
      w: 8,
      h: 24
      // Work In Progress : limite recommandÃ©e selon l'Ã©quipe
    },
    {
      title: "Termin\xE9",
      x: 16,
      y: 0,
      w: 8,
      h: 24
      // Done : validation et archivage des tÃ¢ches complÃ©tÃ©es
    }
  ],
  // ===========================================================================
  // SECTION 3 : LAYOUTS DE PLANIFICATION TEMPORELLE
  // ===========================================================================
  /**
   * PLANIFICATEUR HEBDOMADAIRE - Organisation par jour de la semaine
   * 
   * MÃ‰THODOLOGIE :
   * Planification cyclique basÃ©e sur la semaine de travail standard.
   * Ã‰quilibre entre productivitÃ© professionnelle et bien-Ãªtre personnel.
   * 
   * PHILOSOPHIE :
   * Rythme hebdomadaire naturel avec distinction travail/repos.
   * Vision d'ensemble pour une planification Ã©quilibrÃ©e.
   * 
   * ORGANISATION :
   * - 5 jours de travail avec sections dÃ©diÃ©es
   * - Weekend groupÃ© pour activitÃ©s personnelles
   * - Zone de notes pour observations et rÃ©flexions
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   * â”‚ LUN â”‚ MAR â”‚ MER â”‚ JEU â”‚
   * â”‚     â”‚     â”‚     â”‚     â”‚
   * â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚
   * â”‚     â”‚     â”‚     â”‚     â”‚
   * â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¤
   * â”‚ VEN â”‚ W-E â”‚   ğŸ“      â”‚
   * â”‚     â”‚ ğŸ–ï¸  â”‚   NOTES   â”‚
   * â”‚ ğŸ“…  â”‚     â”‚           â”‚
   * â”‚     â”‚     â”‚           â”‚
   * â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Layout asymÃ©trique optimisÃ©
   * CAS D'USAGE : Planning personnel, coordination d'Ã©quipe, revues hebdomadaires
   */
  layout_weekly: [
    {
      title: "Lundi",
      x: 0,
      y: 0,
      w: 6,
      h: 12
      // DÃ©marrage de semaine, objectifs et planification
    },
    {
      title: "Mardi",
      x: 6,
      y: 0,
      w: 6,
      h: 12
      // ProductivitÃ© optimale, tÃ¢ches importantes
    },
    {
      title: "Mercredi",
      x: 12,
      y: 0,
      w: 6,
      h: 12
      // Milieu de semaine, ajustements et rÃ©visions
    },
    {
      title: "Jeudi",
      x: 18,
      y: 0,
      w: 6,
      h: 12
      // Finalisation des livrables de la semaine
    },
    {
      title: "Vendredi",
      x: 0,
      y: 12,
      w: 8,
      h: 12
      // ClÃ´ture, bilans et prÃ©paration semaine suivante
    },
    {
      title: "Weekend",
      x: 8,
      y: 12,
      w: 8,
      h: 12
      // Repos, activitÃ©s personnelles, famille, loisirs
    },
    {
      title: "Notes",
      x: 16,
      y: 12,
      w: 8,
      h: 12
      // Observations, idÃ©es, rÃ©flexions et apprentissages
    }
  ],
  /**
   * PLANIFICATEUR QUOTIDIEN - Structure dÃ©taillÃ©e d'une journÃ©e
   * 
   * MÃ‰THODOLOGIE :
   * Organisation mÃ©ticuleuse d'une journÃ©e avec focus sur l'apprentissage
   * et la rÃ©flexion. InspirÃ© des mÃ©thodes de dÃ©veloppement personnel.
   * 
   * PHILOSOPHIE :
   * JournÃ©e intentionnelle avec boucle d'amÃ©lioration continue.
   * Ã‰quilibre entre action et rÃ©flexion.
   * 
   * STRUCTURE :
   * - Objectifs clairs et limitÃ©s (max 3)
   * - TÃ¢ches prioritaires identifiÃ©es
   * - Planning temporel structurÃ©
   * - Capture d'apprentissages
   * - RÃ©flexion et bilan de fin de journÃ©e
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ ğŸ¯ OBJECTIFSâ”‚ â­ PRIORITÃ‰S â”‚
   * â”‚   DU JOUR   â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ğŸ“…PLAâ”‚ğŸ“ NOTâ”‚ğŸ“šAPPâ”‚ğŸ’­ RÃ‰F â”‚
   * â”‚NING â”‚   ES â”‚RENT.â”‚  LEX. â”‚
   * â”‚     â”‚      â”‚     â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ’¡ RÃ‰FLEXIONS       â”‚
   * â”‚     ET BILAN QUOTIDIEN   â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 6 sections pour journÃ©e structurÃ©e
   * CAS D'USAGE : DÃ©veloppement personnel, productivitÃ© quotidienne
   */
  layout_daily: [
    {
      title: "Objectifs du jour",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Maximum 3 objectifs SMART pour la journÃ©e
    },
    {
      title: "T\xE2ches prioritaires",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // Actions importantes qui font avancer les objectifs
    },
    {
      title: "Planning",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // Emploi du temps, rendez-vous, crÃ©neaux de travail
    },
    {
      title: "Notes",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // Capture rapide d'idÃ©es, observations, informations
    },
    {
      title: "Apprentissages",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // Ce que j'ai appris aujourd'hui (compÃ©tences, insights)
    },
    {
      title: "R\xE9flexions",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Bilan de journÃ©e, points d'amÃ©lioration, gratitude
    }
  ],
  // ===========================================================================
  // SECTION 4 : LAYOUTS DE GESTION DE PROJET
  // ===========================================================================
  /**
   * GESTION DE PROJET COMPLÃˆTE - Vue d'ensemble projet
   * 
   * MÃ‰THODOLOGIE :
   * Approche holistique de la gestion de projet intÃ©grant tous les aspects
   * essentiels. InspirÃ© des mÃ©thodologies PMI et Agile.
   * 
   * PHILOSOPHIE :
   * Vision systÃ©mique du projet avec Ã©quilibre entre planification
   * et adaptabilitÃ©.
   * 
   * COMPOSANTS :
   * - Vue d'ensemble : Contexte et vision globale
   * - Objectifs : RÃ©sultats mesurables attendus
   * - Ã‰tapes : Jalons et phases du projet
   * - Ressources : Ã‰quipe, budget, outils
   * - Risques : Identification et mitigation
   * - Suivi : MÃ©triques et progression
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚       ğŸ¯ VUE D'ENSEMBLE         â”‚
   * â”‚    (Vision, contexte, enjeux)   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ğŸ“‹ OBJECTI â”‚ğŸš€ Ã‰TAPES  â”‚ğŸ’¼ RESSO-â”‚
   * â”‚   FS      â”‚           â”‚   URCES â”‚
   * â”‚           â”‚           â”‚         â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚  âš ï¸ RISQUES     â”‚ ğŸ“Š SUIVI     â”‚
   * â”‚                 â”‚               â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Vue hiÃ©rarchique avec header
   * CAS D'USAGE : Gestion de projet, initiatives stratÃ©giques, lancements
   */
  layout_project: [
    {
      title: "Vue d'ensemble",
      x: 0,
      y: 0,
      w: 24,
      h: 6
      // Contexte, vision, objectifs gÃ©nÃ©raux, parties prenantes
    },
    {
      title: "Objectifs",
      x: 0,
      y: 6,
      w: 8,
      h: 9
      // Objectifs SMART, critÃ¨res de succÃ¨s, KPIs
    },
    {
      title: "\xC9tapes",
      x: 8,
      y: 6,
      w: 8,
      h: 9
      // Jalons, phases, roadmap, planning gÃ©nÃ©ral
    },
    {
      title: "Ressources",
      x: 16,
      y: 6,
      w: 8,
      h: 9
      // Ã‰quipe, budget, outils, compÃ©tences nÃ©cessaires
    },
    {
      title: "Risques",
      x: 0,
      y: 15,
      w: 12,
      h: 9
      // Identification, Ã©valuation, plans de mitigation
    },
    {
      title: "Suivi",
      x: 12,
      y: 15,
      w: 12,
      h: 9
      // MÃ©triques, avancement, reporting, ajustements
    }
  ],
  // ===========================================================================
  // SECTION 5 : LAYOUTS BASIQUES ET POLYVALENTS
  // ===========================================================================
  /**
   * BOARD SIMPLE - Approche minimaliste 2 colonnes
   * 
   * MÃ‰THODOLOGIE :
   * SimplicitÃ© volontaire pour dÃ©marrage rapide ou usages non-spÃ©cialisÃ©s.
   * BasÃ© sur la dichotomie pensÃ©e/action.
   * 
   * PHILOSOPHIE :
   * "La simplicitÃ© est la sophistication suprÃªme" - Leonardo da Vinci
   * Parfait pour dÃ©buter ou pour des besoins basiques.
   * 
   * APPLICATIONS :
   * - Brainstorming : IdÃ©es â†’ Actions
   * - Comparaison : Pour â†’ Contre
   * - Processus : Input â†’ Output
   * - Planning : Cette semaine â†’ Semaine prochaine
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚             â”‚             â”‚
   * â”‚   ğŸ’¡ IDEAS  â”‚ âš¡ ACTIONS  â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 2 colonnes Ã©gales, simplicitÃ© maximale
   * CAS D'USAGE : Brainstorming, comparaisons, projets simples, dÃ©marrage
   */
  layout_simple: [
    {
      title: "Ideas",
      x: 0,
      y: 0,
      w: 12,
      h: 24
      // IdÃ©es, concepts, possibilitÃ©s, rÃ©flexions
    },
    {
      title: "Actions",
      x: 12,
      y: 0,
      w: 12,
      h: 24
      // Actions concrÃ¨tes, tÃ¢ches, Ã©tapes suivantes
    }
  ],
  // ===========================================================================
  // SECTION 6 : LAYOUTS DE PRISE DE NOTES
  // ===========================================================================
  /**
   * NOTES CORNELL - SystÃ¨me de prise de notes universitaire
   * 
   * MÃ‰THODOLOGIE :
   * DÃ©veloppÃ© Ã  l'universitÃ© Cornell par Walter Pauk dans les annÃ©es 1950.
   * Optimise la prise de notes, la rÃ©vision et la mÃ©morisation.
   * 
   * PHILOSOPHIE :
   * Structure prÃ©dÃ©finie qui force l'organisation et la synthÃ¨se.
   * SÃ©paration claire entre capture, analyse et mÃ©morisation.
   * 
   * ZONES FONCTIONNELLES :
   * 1. Notes principales : Capture du contenu principal
   * 2. Mots-clÃ©s/Questions : Indices de rÃ©vision et concepts clÃ©s
   * 3. RÃ©sumÃ© : SynthÃ¨se personnelle et points clÃ©s
   * 
   * PROCESSUS :
   * PENDANT â†’ Prendre des notes dans la zone principale
   * APRÃˆS â†’ Ajouter mots-clÃ©s et questions dans la marge
   * RÃ‰VISION â†’ Utiliser les mots-clÃ©s pour rÃ©viser
   * SYNTHÃˆSE â†’ Ã‰crire un rÃ©sumÃ© personnel
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚                    â”‚       â”‚
   * â”‚     ğŸ“ NOTES       â”‚ ğŸ·ï¸    â”‚
   * â”‚   (Contenu         â”‚ MOTS- â”‚
   * â”‚    principal)      â”‚ CLÃ‰S  â”‚
   * â”‚                    â”‚       â”‚
   * â”‚                    â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ“‹ RÃ‰SUMÃ‰             â”‚
   * â”‚   (SynthÃ¨se personnelle)   â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Zone principale + marge + footer
   * CAS D'USAGE : Cours, confÃ©rences, lectures, formations
   */
  layout_cornell: [
    {
      title: "Notes",
      x: 0,
      y: 0,
      w: 16,
      h: 18
      // Zone principale de prise de notes pendant l'Ã©coute
    },
    {
      title: "Mots-cl\xE9s",
      x: 16,
      y: 0,
      w: 8,
      h: 18
      // Marge pour concepts clÃ©s, questions, indices de rÃ©vision
    },
    {
      title: "R\xE9sum\xE9",
      x: 0,
      y: 18,
      w: 24,
      h: 6
      // SynthÃ¨se personnelle en fin de session
    }
  ],
  // ===========================================================================
  // SECTION 7 : LAYOUTS D'INTÃ‰GRATION AVEC PLUGINS OBSIDIAN
  // ===========================================================================
  /**
   * DASHBOARD TASKS - IntÃ©gration avancÃ©e avec le plugin Tasks
   * 
   * MÃ‰THODOLOGIE :
   * OptimisÃ© pour exploiter les capacitÃ©s du plugin Tasks d'Obsidian.
   * Affichage intelligent des tÃ¢ches par contexte temporel et projet.
   * 
   * PHILOSOPHIE :
   * Centralisation et contextualisation des tÃ¢ches pour une vision
   * d'ensemble de la charge de travail.
   * 
   * ZONES TEMPORELLES :
   * - Aujourd'hui : Focus sur l'immÃ©diat
   * - Cette semaine : Vision Ã  court terme
   * - En retard : Gestion des dÃ©passements
   * - Projets actifs : Vision organisationnelle
   * - Statistiques : MÃ©triques et tendances
   * 
   * REQUÃŠTES TASKS INTÃ‰GRÃ‰ES :
   * Utilise la syntaxe du plugin Tasks pour des requÃªtes dynamiques.
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ ğŸ“… AUJ. â”‚ğŸ“… SEMN â”‚âš ï¸ RETARDâ”‚
   * â”‚         â”‚         â”‚         â”‚
   * â”‚ tasks   â”‚ tasks   â”‚ tasks   â”‚
   * â”‚ due     â”‚ due     â”‚ due     â”‚
   * â”‚ today   â”‚ this    â”‚ before  â”‚
   * â”‚         â”‚ week    â”‚ today   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚  ğŸ“Š PROJETS       â”‚ğŸ“ˆ STATS â”‚
   * â”‚    ACTIFS         â”‚         â”‚
   * â”‚ (par projet)      â”‚(mÃ©triq.)â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * REQUÃŠTES TASKS SUGGÃ‰RÃ‰ES :
   * - Aujourd'hui : ```tasks due today not done```
   * - Cette semaine : ```tasks due this week not done```
   * - En retard : ```tasks due before today not done```
   * - Par projet : ```tasks group by project```
   * 
   * GRILLE TECHNIQUE : Vue temporelle + organisation + analytics
   * CAS D'USAGE : Gestion avancÃ©e des tÃ¢ches, productivitÃ©, suivi projets
   */
  layout_tasks_dashboard: [
    {
      title: "T\xE2ches du jour",
      x: 0,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due today not done```
    },
    {
      title: "Cette semaine",
      x: 8,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due this week not done```
    },
    {
      title: "En retard",
      x: 16,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due before today not done```
    },
    {
      title: "Projets actifs",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // ```tasks group by project``` ou organisation manuelle
    },
    {
      title: "Statistiques",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // MÃ©triques, tendances, analyse de productivitÃ©
    }
  ]
};
var LAYOUT_INFO = {
  layout_eisenhower: {
    name: "layout_eisenhower",
    displayName: "Matrice d'Eisenhower",
    description: "Syst\xE8me de priorisation bas\xE9 sur l'urgence et l'importance. Parfait pour la gestion quotidienne et les d\xE9cisions strat\xE9giques.",
    sections: ["Urgent et Important", "Pas urgent mais Important", "Urgent mais Pas important", "Ni urgent ni important"],
    blockCount: 4,
    category: "productivit\xE9"
  },
  layout_gtd: {
    name: "layout_gtd",
    displayName: "Getting Things Done (GTD)",
    description: "M\xE9thode compl\xE8te de productivit\xE9 de David Allen. Syst\xE8me d'externalisation de la m\xE9moire et de clarification syst\xE9matique.",
    sections: ["Inbox", "Actions suivantes", "En attente", "Projets", "Someday Maybe", "R\xE9f\xE9rence"],
    blockCount: 6,
    category: "productivit\xE9"
  },
  layout_kanban: {
    name: "layout_kanban",
    displayName: "Tableau Kanban",
    description: "Visualisation du flux de travail avec limitation du travail en cours. Id\xE9al pour le d\xE9veloppement et la gestion d'\xE9quipe.",
    sections: ["\xC0 faire", "En cours", "Termin\xE9"],
    blockCount: 3,
    category: "workflow"
  },
  layout_weekly: {
    name: "layout_weekly",
    displayName: "Planificateur Hebdomadaire",
    description: "Organisation par jour de la semaine avec \xE9quilibre travail/repos. Parfait pour la planification personnelle et la coordination d'\xE9quipe.",
    sections: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Weekend", "Notes"],
    blockCount: 7,
    category: "planification"
  },
  layout_daily: {
    name: "layout_daily",
    displayName: "Planificateur Quotidien",
    description: "Structure d\xE9taill\xE9e d'une journ\xE9e avec focus sur l'apprentissage et la r\xE9flexion. Id\xE9al pour le d\xE9veloppement personnel.",
    sections: ["Objectifs du jour", "T\xE2ches prioritaires", "Planning", "Notes", "Apprentissages", "R\xE9flexions"],
    blockCount: 6,
    category: "planification"
  },
  layout_project: {
    name: "layout_project",
    displayName: "Gestion de Projet",
    description: "Vue d'ensemble compl\xE8te d'un projet avec tous les aspects essentiels. Inspir\xE9 des m\xE9thodologies PMI et Agile.",
    sections: ["Vue d'ensemble", "Objectifs", "\xC9tapes", "Ressources", "Risques", "Suivi"],
    blockCount: 6,
    category: "projet"
  },
  layout_simple: {
    name: "layout_simple",
    displayName: "Board Simple",
    description: "Approche minimaliste \xE0 2 colonnes. Parfait pour d\xE9buter ou pour des besoins basiques de brainstorming et comparaison.",
    sections: ["Ideas", "Actions"],
    blockCount: 2,
    category: "basique"
  },
  layout_cornell: {
    name: "layout_cornell",
    displayName: "Notes Cornell",
    description: "Syst\xE8me de prise de notes universitaire optimisant la capture, r\xE9vision et m\xE9morisation. D\xE9velopp\xE9 \xE0 Cornell University.",
    sections: ["Notes", "Mots-cl\xE9s", "R\xE9sum\xE9"],
    blockCount: 3,
    category: "notes"
  },
  layout_tasks_dashboard: {
    name: "layout_tasks_dashboard",
    displayName: "Dashboard Tasks",
    description: "Int\xE9gration avanc\xE9e avec le plugin Tasks d'Obsidian. Affichage intelligent des t\xE2ches par contexte temporel et projet.",
    sections: ["T\xE2ches du jour", "Cette semaine", "En retard", "Projets actifs", "Statistiques"],
    blockCount: 5,
    category: "int\xE9gration"
  }
};

// src/services/LayoutService.ts
var LayoutService = class {
  /**
   * CONSTRUCTEUR avec injection de dÃ©pendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * INJECTION DE DÃ‰PENDANCE :
   * Le plugin est injectÃ© pour potentiel accÃ¨s futur Ã  :
   * - Configuration utilisateur
   * - SystÃ¨me de logs
   * - Ã‰vÃ©nements du plugin
   * 
   * MODIFICATEUR private :
   * Le plugin est stockÃ© pour usage interne uniquement
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Stockage interne des layouts validÃ©s
     * 
     * CHOIX DE STRUCTURE DE DONNÃ‰ES :
     * Map vs Object :
     * - Map : accÃ¨s O(1), iteration garantie, clÃ©s dynamiques
     * - Object : plus de syntaxe, risque de pollution du prototype
     * 
     * GÃ‰NÃ‰RICS TYPESCRIPT :
     * Map<K, V> indique les types de clÃ© et valeur
     * - K = string (nom du layout)
     * - V = BoardLayout[] (array de blocs)
     */
    this.models = /* @__PURE__ */ new Map();
  }
  // ===========================================================================
  // MÃ‰THODES DE CHARGEMENT ET INITIALISATION
  // ===========================================================================
  /**
   * Charge et valide tous les layouts intÃ©grÃ©s
   * 
   * PROCESSUS DE CHARGEMENT :
   * 1. Vider le cache existant
   * 2. ItÃ©rer sur tous les layouts prÃ©dÃ©finis
   * 3. Valider chaque layout gÃ©omÃ©triquement
   * 4. Stocker les layouts valides
   * 5. Rejeter les layouts invalides avec warning
   * 6. Logger le rÃ©sumÃ© du chargement
   * 
   * GESTION D'ERREURS :
   * Les layouts invalides sont ignorÃ©s mais loggÃ©s.
   * Le plugin continue de fonctionner avec les layouts valides.
   * 
   * VALIDATION GÃ‰OMÃ‰TRIQUE :
   * - VÃ©rification des limites de grille
   * - DÃ©tection des chevauchements
   * - Validation des types de donnÃ©es
   * 
   * @example
   * layoutService.load();
   * // Log: "ğŸ“ 3 layouts chargÃ©s"
   * // Log: "ğŸ“‹ Layouts disponibles: layout_eisenhower, layout_kanban, ..."
   */
  load() {
    console.log("\u{1F4D0} Chargement des layouts int\xE9gr\xE9s...");
    this.models.clear();
    let loadedCount = 0;
    for (const [name, layout] of Object.entries(BUILT_IN_LAYOUTS)) {
      console.log(`\u{1F50D} Chargement du layout "${name}"...`);
      if (this.validateModel(name, layout)) {
        this.models.set(name, layout);
        loadedCount++;
        console.log(`\u2705 Layout "${name}" charg\xE9 (${layout.length} blocs)`);
      } else {
        console.warn(`\u274C Mod\xE8le "${name}" invalide`);
      }
    }
    console.log(`\u{1F4D0} ${loadedCount} layouts charg\xE9s`);
    this.logAvailableLayouts();
  }
  /**
   * Valide complÃ¨tement un layout (gÃ©omÃ©trie + cohÃ©rence)
   * 
   * VALIDATION EN PLUSIEURS Ã‰TAPES :
   * 1. Validation individuelle de chaque bloc
   * 2. VÃ©rification des limites de grille
   * 3. DÃ©tection des chevauchements
   * 4. CrÃ©ation d'une grille de test pour simulation
   * 
   * ALGORITHME DE CHEVAUCHEMENT :
   * - CrÃ©er une grille boolÃ©enne 24Ã—100
   * - Pour chaque bloc, marquer ses cellules
   * - Si une cellule est dÃ©jÃ  marquÃ©e = chevauchement
   * 
   * @param name - Nom du layout (pour les logs d'erreur)
   * @param layout - Array de blocs Ã  valider
   * @returns boolean - true si le layout est entiÃ¨rement valide
   * 
   * @example
   * const isValid = layoutService.validateModel("test", [
   *   { title: "Block 1", x: 0, y: 0, w: 12, h: 12 },
   *   { title: "Block 2", x: 12, y: 0, w: 12, h: 12 }
   * ]);
   * // true si pas de chevauchement, false sinon
   */
  validateModel(name, layout) {
    const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
    let isValid = true;
    for (const block of layout) {
      if (!this.isValidBlock(block)) {
        console.warn(`\u274C [${name}] Bloc invalide :`, block);
        isValid = false;
        continue;
      }
      if (!this.isBlockInBounds(block)) {
        console.warn(`\u274C [${name}] Bloc hors limites :`, block);
        isValid = false;
        continue;
      }
      if (!this.checkOverlap(grid, block, name)) {
        isValid = false;
      }
    }
    return isValid;
  }
  /**
   * VÃ©rifie qu'un objet a la structure d'un BoardLayout valide
   * 
   * TYPE GUARD TYPESCRIPT :
   * Cette fonction est un "type guard" qui vÃ©rifie Ã  l'exÃ©cution
   * qu'un objet correspond Ã  l'interface BoardLayout.
   * 
   * VÃ‰RIFICATIONS :
   * - PrÃ©sence de toutes les propriÃ©tÃ©s requises
   * - Types corrects (string pour title, number pour les autres)
   * - Pas de vÃ©rification des valeurs (fait dans isBlockInBounds)
   * 
   * @param block - Objet Ã  vÃ©rifier (type any pour flexibilitÃ©)
   * @returns block is BoardLayout - Type guard TypeScript
   * 
   * @example
   * const obj = { title: "Test", x: 0, y: 0, w: 5, h: 5 };
   * if (isValidBlock(obj)) {
   *   // TypeScript sait maintenant que obj est un BoardLayout
   *   console.log(obj.title); // Pas d'erreur TypeScript
   * }
   */
  isValidBlock(block) {
    return typeof block.title === "string" && // Titre doit Ãªtre une chaÃ®ne
    typeof block.x === "number" && // Position X doit Ãªtre un nombre
    typeof block.y === "number" && // Position Y doit Ãªtre un nombre
    typeof block.w === "number" && // Largeur doit Ãªtre un nombre
    typeof block.h === "number";
  }
  /**
   * VÃ©rifie qu'un bloc respecte les limites de la grille
   * 
   * CONTRAINTES DE GRILLE :
   * - x >= 0 : pas de position nÃ©gative
   * - y >= 0 : pas de position nÃ©gative
   * - w > 0 : largeur positive
   * - h > 0 : hauteur positive
   * - x + w <= 24 : ne dÃ©borde pas Ã  droite
   * - y + h <= 100 : ne dÃ©borde pas en bas
   * 
   * @param block - Bloc Ã  vÃ©rifier (dÃ©jÃ  validÃ© par isValidBlock)
   * @returns boolean - true si dans les limites
   * 
   * @example
   * isBlockInBounds({ title: "Test", x: 20, y: 0, w: 5, h: 10 });
   * // false car x(20) + w(5) = 25 > 24 (dÃ©borde Ã  droite)
   */
  isBlockInBounds(block) {
    return block.x >= 0 && // Position X positive
    block.y >= 0 && // Position Y positive
    block.w > 0 && // Largeur positive
    block.h > 0 && // Hauteur positive
    block.x + block.w <= 24 && // Pas de dÃ©bordement horizontal
    block.y + block.h <= 100;
  }
  /**
   * VÃ©rifie qu'un bloc ne chevauche pas avec les blocs dÃ©jÃ  placÃ©s
   * 
   * ALGORITHME :
   * 1. Parcourir toutes les cellules du bloc
   * 2. Pour chaque cellule (x, y), vÃ©rifier si grid[x][y] est dÃ©jÃ  true
   * 3. Si dÃ©jÃ  true = chevauchement dÃ©tectÃ©
   * 4. Sinon, marquer la cellule comme occupÃ©e
   * 
   * EFFET DE BORD :
   * Cette fonction modifie la grille en marquant les cellules occupÃ©es.
   * C'est voulu pour la dÃ©tection cumulative de chevauchements.
   * 
   * @param grid - Grille de test (modifiÃ©e par la fonction)
   * @param block - Bloc Ã  placer
   * @param modelName - Nom du layout (pour les logs d'erreur)
   * @returns boolean - true si pas de chevauchement
   * 
   * @example
   * const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
   * const block1 = { title: "A", x: 0, y: 0, w: 10, h: 10 };
   * const block2 = { title: "B", x: 5, y: 5, w: 10, h: 10 };
   * 
   * checkOverlap(grid, block1, "test"); // true (premiÃ¨re fois)
   * checkOverlap(grid, block2, "test"); // false (chevauchement en (5,5)-(9,9))
   */
  checkOverlap(grid, block, modelName) {
    for (let x = block.x; x < block.x + block.w; x++) {
      for (let y = block.y; y < block.y + block.h; y++) {
        if (grid[x][y]) {
          console.warn(`\u274C [${modelName}] Chevauchement d\xE9tect\xE9 au bloc "${block.title}" \xE0 (${x}, ${y})`);
          return false;
        }
        grid[x][y] = true;
      }
    }
    return true;
  }
  /**
   * Affiche un rÃ©sumÃ© des layouts chargÃ©s dans la console
   * 
   * UTILITÃ‰ :
   * - DÃ©bogage : voir quels layouts sont disponibles
   * - VÃ©rification : confirmer que le chargement s'est bien passÃ©
   * - Documentation : liste des sections de chaque layout
   * 
   * FORMAT DE SORTIE :
   * ```
   * ğŸ“‹ Layouts disponibles: layout_eisenhower, layout_kanban
   *   â€¢ layout_eisenhower: 4 sections (Urgent et Important, Pas urgent...)
   *   â€¢ layout_kanban: 3 sections (Ã€ faire, En cours, TerminÃ©)
   * ```
   */
  logAvailableLayouts() {
    const layouts = Array.from(this.models.keys());
    console.log("\u{1F4CB} Layouts disponibles:", layouts);
    for (const [name, layout] of this.models) {
      const sections = layout.map((b) => b.title).join(", ");
      console.log(`  \u2022 ${name}: ${layout.length} sections (${sections})`);
    }
  }
  // ===========================================================================
  // MÃ‰THODES D'ACCÃˆS PUBLIC (API DU SERVICE)
  // ===========================================================================
  /**
   * RÃ©cupÃ¨re un layout par son nom
   * 
   * API PRINCIPALE :
   * Cette mÃ©thode est l'interface principale pour obtenir un layout.
   * UtilisÃ©e par BoardView, ViewSwitcher, etc.
   * 
   * RETOUR UNDEFINED :
   * Retourne undefined si le layout n'existe pas.
   * Plus sÃ»r que de lever une exception.
   * 
   * @param name - Nom du layout (ex: "layout_eisenhower")
   * @returns BoardLayout[] | undefined - Layout ou undefined si inexistant
   * 
   * @example
   * const layout = layoutService.getModel("layout_eisenhower");
   * if (layout) {
   *   // Layout trouvÃ©, on peut l'utiliser
   *   console.log(`Layout avec ${layout.length} blocs`);
   * } else {
   *   // Layout inexistant
   *   console.error("Layout non trouvÃ©");
   * }
   */
  getModel(name) {
    return this.models.get(name);
  }
  /**
   * Retourne la liste de tous les noms de layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : lister les layouts dans un menu
   * - Validation : vÃ©rifier qu'un layout existe
   * - DÃ©bogage : voir ce qui est disponible
   * 
   * @returns string[] - Array des noms de layouts
   * 
   * @example
   * const names = layoutService.getAllModelNames();
   * console.log(names); // ["layout_eisenhower", "layout_kanban", ...]
   * 
   * // Utilisation dans une interface
   * names.forEach(name => {
   *   const displayName = getLayoutDisplayName(name);
   *   addMenuItem(displayName, () => createNote(name));
   * });
   */
  getAllModelNames() {
    return Array.from(this.models.keys());
  }
  /**
   * Obtient le nom d'affichage convivial d'un layout
   * 
   * MAPPING TECHNIQUE â†’ USER-FRIENDLY :
   * "layout_eisenhower" â†’ "Matrice d'Eisenhower"
   * 
   * FALLBACK :
   * Si aucun nom d'affichage n'est dÃ©fini, retourne le nom technique.
   * Ã‰vite les erreurs si les mÃ©tadonnÃ©es sont incomplÃ¨tes.
   * 
   * @param layoutName - Nom technique du layout
   * @returns string - Nom d'affichage ou nom technique si non trouvÃ©
   * 
   * @example
   * const displayName = layoutService.getLayoutDisplayName("layout_eisenhower");
   * console.log(displayName); // "Matrice d'Eisenhower"
   * 
   * const unknownName = layoutService.getLayoutDisplayName("layout_custom");
   * console.log(unknownName); // "layout_custom" (fallback)
   */
  getLayoutDisplayName(layoutName) {
    const layoutInfo = LAYOUT_INFO[layoutName];
    return layoutInfo ? layoutInfo.displayName : layoutName;
  }
  /**
   * Obtient les mÃ©tadonnÃ©es complÃ¨tes d'un layout
   * 
   * MÃ‰TADONNÃ‰ES ENRICHIES :
   * - Nom technique et d'affichage
   * - Description et cas d'usage
   * - Liste des sections
   * - Nombre de blocs
   * - CatÃ©gorie pour organisation
   * 
   * GÃ‰NÃ‰RATION AUTOMATIQUE :
   * Si les mÃ©tadonnÃ©es prÃ©dÃ©finies n'existent pas, gÃ©nÃ¨re des mÃ©tadonnÃ©es
   * basiques Ã  partir du layout lui-mÃªme.
   * 
   * @param name - Nom du layout
   * @returns LayoutInfo | undefined - MÃ©tadonnÃ©es ou undefined si layout inexistant
   * 
   * @example
   * const info = layoutService.getModelInfo("layout_eisenhower");
   * if (info) {
   *   console.log(`${info.displayName}: ${info.description}`);
   *   console.log(`Sections: ${info.sections.join(', ')}`);
   *   console.log(`CatÃ©gorie: ${info.category}`);
   * }
   */
  getModelInfo(name) {
    const model = this.models.get(name);
    if (!model)
      return void 0;
    const info = LAYOUT_INFO[name];
    return info || {
      name,
      displayName: name,
      // Nom technique par dÃ©faut
      description: "Layout personnalis\xE9",
      // Description gÃ©nÃ©rique
      sections: model.map((block) => block.title),
      // Extraire les titres des blocs
      blockCount: model.length,
      // Compter les blocs
      category: "custom"
      // CatÃ©gorie par dÃ©faut
    };
  }
  /**
   * Retourne les mÃ©tadonnÃ©es de tous les layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : afficher tous les layouts avec dÃ©tails
   * - Filtrage : grouper par catÃ©gorie
   * - Documentation : gÃ©nÃ©rer de l'aide automatiquement
   * 
   * PERFORMANCE :
   * GÃ©nÃ¨re les mÃ©tadonnÃ©es Ã  la demande.
   * Pour de meilleures performances avec beaucoup de layouts,
   * on pourrait envisager un cache.
   * 
   * @returns LayoutInfo[] - Array de toutes les mÃ©tadonnÃ©es
   */
  getAllModelsInfo() {
    return Array.from(this.models.keys()).map((name) => this.getModelInfo(name)).filter((info) => info !== void 0);
  }
};

// src/services/FileService.ts
var FileService = class {
  /**
   * CONSTRUCTEUR avec injection de dÃ©pendance
   * 
   * @param app - Instance principale d'Obsidian
   * 
   * CONCEPT OBSIDIAN - APP :
   * L'objet App donne accÃ¨s Ã  toutes les fonctionnalitÃ©s d'Obsidian :
   * - app.vault : SystÃ¨me de fichiers
   * - app.metadataCache : Cache des mÃ©tadonnÃ©es
   * - app.workspace : Gestion des vues et onglets
   * 
   * MODIFICATEUR private :
   * Rend la propriÃ©tÃ© accessible uniquement dans cette classe
   */
  constructor(app) {
    this.app = app;
  }
  // ===========================================================================
  // MÃ‰THODES PRINCIPALES DE PARSING
  // ===========================================================================
  /**
   * Parse toutes les sections H1 d'un fichier markdown
   * 
   * ALGORITHME :
   * 1. Lire le contenu du fichier
   * 2. DÃ©couper en lignes
   * 3. Identifier les titres H1 (lignes commenÃ§ant par "# ")
   * 4. Extraire le contenu entre chaque titre
   * 5. CrÃ©er des objets FileSection avec mÃ©tadonnÃ©es
   * 
   * GESTION DES CAS LIMITES :
   * - Fichier vide : retourne objet vide
   * - Pas de sections H1 : retourne objet vide
   * - Sections vides : incluses avec tableau de lignes vide
   * - DerniÃ¨re section : va jusqu'Ã  la fin du fichier
   * 
   * @param file - Fichier Obsidian Ã  parser
   * @returns Promise<FileSections> - Dictionnaire des sections trouvÃ©es
   * 
   * @example
   * // Pour un fichier contenant :
   * // # Section 1
   * // Contenu 1
   * // # Section 2  
   * // Contenu 2
   * 
   * const sections = await fileService.parseSections(file);
   * // Retourne :
   * // {
   * //   "Section 1": { start: 0, end: 2, lines: ["Contenu 1"] },
   * //   "Section 2": { start: 2, end: 4, lines: ["Contenu 2"] }
   * // }
   */
  async parseSections(file) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = {};
    let currentSection = null;
    let sectionStart = 0;
    console.log("\u{1F4D6} Parsing sections du fichier:", file.basename);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const headerMatch = line.match(/^# ([^\n#].*?)\s*$/);
      if (headerMatch) {
        if (currentSection !== null) {
          const sectionLines = lines.slice(sectionStart + 1, i);
          sections[currentSection] = {
            start: sectionStart,
            // Index de la ligne du titre
            end: i,
            // Index de la ligne suivante (exclus)
            lines: sectionLines
            // Contenu de la section
          };
          console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
        }
        currentSection = headerMatch[1].trim();
        sectionStart = i;
      }
    }
    if (currentSection !== null) {
      const sectionLines = lines.slice(sectionStart + 1);
      sections[currentSection] = {
        start: sectionStart,
        end: lines.length,
        // Fin du fichier
        lines: sectionLines
      };
      console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
    }
    console.log("\u2705 Sections trouv\xE9es:", Object.keys(sections));
    return sections;
  }
  // ===========================================================================
  // MÃ‰THODES DE MODIFICATION DES FICHIERS
  // ===========================================================================
  /**
   * CrÃ©e automatiquement les sections manquantes dans un fichier
   * 
   * PROCESSUS :
   * 1. Parser les sections existantes
   * 2. Comparer avec les sections requises par le layout
   * 3. Identifier les sections manquantes
   * 4. Trouver le point d'insertion optimal
   * 5. GÃ©nÃ©rer le contenu des nouvelles sections
   * 6. InsÃ©rer et sauvegarder
   * 
   * STRATÃ‰GIE D'INSERTION :
   * - AprÃ¨s le frontmatter YAML (s'il existe)
   * - Sinon au dÃ©but du fichier
   * - Chaque section avec titre H1 et ligne vide
   * 
   * @param file - Fichier Ã  modifier
   * @param layout - Layout dÃ©finissant les sections requises
   * @returns Promise<boolean> - true si des sections ont Ã©tÃ© crÃ©Ã©es
   * 
   * @example
   * // Layout requiert : ["Section A", "Section B", "Section C"]
   * // Fichier contient : ["Section A", "Section C"]
   * // RÃ©sultat : Ajoute "Section B" au fichier
   */
  async createMissingSections(file, layout) {
    console.log("\u{1F527} V\xE9rification des sections manquantes...");
    const sections = await this.parseSections(file);
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = requiredSections.filter(
      (section) => !existingSections.includes(section)
    );
    if (missingSections.length === 0) {
      console.log("\u2705 Toutes les sections sont pr\xE9sentes");
      return false;
    }
    console.log("\u{1F4DD} Sections manquantes d\xE9tect\xE9es:", missingSections);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const insertionPoint = this.findInsertionPoint(lines);
    const newSectionLines = [];
    for (const sectionTitle of missingSections) {
      newSectionLines.push("");
      newSectionLines.push(`# ${sectionTitle}`);
      newSectionLines.push("");
    }
    const updatedLines = [
      ...lines.slice(0, insertionPoint),
      // Contenu avant insertion
      ...newSectionLines,
      // Nouvelles sections
      ...lines.slice(insertionPoint)
      // Contenu aprÃ¨s insertion
    ];
    await this.app.vault.modify(file, updatedLines.join("\n"));
    console.log(`\u2705 ${missingSections.length} sections ajout\xE9es:`, missingSections);
    return true;
  }
  /**
   * Trouve le point d'insertion optimal pour les nouvelles sections
   * 
   * LOGIQUE :
   * 1. Chercher un frontmatter YAML (entre --- ... ---)
   * 2. Si frontmatter trouvÃ© : insÃ©rer aprÃ¨s
   * 3. Sinon : insÃ©rer au dÃ©but du fichier
   * 
   * FRONTMATTER YAML :
   * Bloc de mÃ©tadonnÃ©es au dÃ©but des fichiers markdown :
   * ---
   * title: Mon titre
   * tags: [tag1, tag2]
   * ---
   * 
   * @param lines - Lignes du fichier
   * @returns number - Index de ligne oÃ¹ insÃ©rer
   * 
   * @example
   * // Fichier avec frontmatter :
   * // ---
   * // title: Test
   * // ---
   * // # Existing Section
   * 
   * findInsertionPoint(lines); // Retourne 3 (aprÃ¨s le frontmatter)
   */
  findInsertionPoint(lines) {
    let frontmatterEnd = 0;
    let inFrontmatter = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (i === 0 && line === "---") {
        inFrontmatter = true;
        continue;
      }
      if (inFrontmatter && line === "---") {
        frontmatterEnd = i + 1;
        break;
      }
    }
    if (frontmatterEnd === 0) {
      return 0;
    } else {
      return frontmatterEnd;
    }
  }
  /**
   * Met Ã  jour le contenu d'une section spÃ©cifique
   * 
   * PROCESSUS :
   * 1. Parser les sections pour trouver la section cible
   * 2. Remplacer son contenu par le nouveau
   * 3. Conserver le titre et la structure
   * 4. Sauvegarder le fichier
   * 
   * UTILISATION :
   * AppelÃ©e par MarkdownFrame quand l'utilisateur modifie une section
   * dans l'interface Board.
   * 
   * @param file - Fichier Ã  modifier
   * @param sectionName - Nom de la section Ã  mettre Ã  jour
   * @param newContent - Nouveau contenu (sans le titre #)
   * 
   * @example
   * await fileService.updateSection(file, "Urgent et Important", "- Nouvelle tÃ¢che\n- Autre tÃ¢che");
   */
  async updateSection(file, sectionName, newContent) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = await this.parseSections(file);
    const section = sections[sectionName];
    if (!section) {
      console.warn(`\u26A0\uFE0F Section "${sectionName}" non trouv\xE9e pour mise \xE0 jour`);
      return;
    }
    const newLines = [
      ...lines.slice(0, section.start + 1),
      // Avant la section (inclus le titre)
      ...newContent.split("\n"),
      // Nouveau contenu
      ...lines.slice(section.end)
      // AprÃ¨s la section
    ];
    await this.app.vault.modify(file, newLines.join("\n"));
    console.log(`\u2705 Section "${sectionName}" mise \xE0 jour`);
  }
  // ===========================================================================
  // MÃ‰THODES UTILITAIRES
  // ===========================================================================
  /**
   * Identifie les sections manquantes par rapport Ã  un layout
   * 
   * ALGORITHME SIMPLE :
   * Filtre les sections requises qui ne sont pas dans les sections existantes.
   * 
   * FONCTION PURE :
   * - Pas d'effets de bord
   * - MÃªme entrÃ©e = mÃªme sortie
   * - Facilement testable
   * 
   * @param existingSections - Sections actuellement prÃ©sentes
   * @param requiredSections - Sections requises par le layout
   * @returns string[] - Liste des sections manquantes
   * 
   * @example
   * const missing = fileService.getMissingSections(
   *   ["Section A", "Section C"],           // Existantes
   *   ["Section A", "Section B", "Section C"]  // Requises
   * );
   * // Retourne : ["Section B"]
   */
  getMissingSections(existingSections, requiredSections) {
    return requiredSections.filter(
      (section) => !existingSections.includes(section)
    );
  }
};

// src/services/NoteCreatorService.ts
var import_obsidian2 = require("obsidian");
var NoteCreatorService = class {
  /**
   * Constructeur avec injection de dÃ©pendances
   * 
   * @param app - Instance de l'application Obsidian
   * @param layoutService - Service de gestion des layouts
   * @param logger - Service de logging (optionnel)
   */
  constructor(app, layoutService, logger) {
    this.app = app;
    this.layoutService = layoutService;
    this.logger = logger;
  }
  // =========================================================================
  // MÃ‰THODE PRINCIPALE
  // =========================================================================
  /**
   * CrÃ©e une nouvelle note avec un layout spÃ©cifique
   * 
   * @param options - Options de crÃ©ation
   * @returns Promise<NoteCreationResult> - RÃ©sultat de la crÃ©ation
   */
  async createNoteWithLayout(options) {
    var _a, _b, _c;
    (_a = this.logger) == null ? void 0 : _a.fileOperation("D\xE9but cr\xE9ation de note", { options });
    try {
      this.validateOptions(options);
      const layout = this.getLayout(options.layoutName);
      const layoutInfo = this.layoutService.getModelInfo(options.layoutName);
      const displayName = (layoutInfo == null ? void 0 : layoutInfo.displayName) || options.layoutName;
      const fileName = this.generateFileName(displayName, options);
      const content = this.generateNoteContent(options.layoutName, displayName, layout, layoutInfo, options);
      const file = await this.createFile(fileName, content, options.folder);
      if (options.autoOpen !== false) {
        await this.openFile(file);
      }
      new import_obsidian2.Notice(`\u2705 Note "${displayName}" cr\xE9\xE9e avec succ\xE8s !`, 3e3);
      const result = {
        file,
        layoutName: options.layoutName,
        displayName,
        sectionsCount: layout.length
      };
      (_b = this.logger) == null ? void 0 : _b.success("Note cr\xE9\xE9e avec succ\xE8s", {
        fileName: result.file.name,
        filePath: result.file.path,
        layoutName: result.layoutName,
        displayName: result.displayName,
        sectionsCount: result.sectionsCount
      });
      return result;
    } catch (error) {
      (_c = this.logger) == null ? void 0 : _c.error("Erreur lors de la cr\xE9ation de note", error);
      new import_obsidian2.Notice(`\u274C Erreur lors de la cr\xE9ation : ${error.message}`, 5e3);
      throw error;
    }
  }
  // =========================================================================
  // MÃ‰THODES DE VALIDATION
  // =========================================================================
  /**
   * Valide les options de crÃ©ation
   */
  validateOptions(options) {
    if (!options.layoutName) {
      throw new Error("Le nom du layout est requis");
    }
    if (!this.layoutService) {
      throw new Error("LayoutService non disponible");
    }
  }
  /**
   * RÃ©cupÃ¨re et valide un layout
   */
  getLayout(layoutName) {
    const layout = this.layoutService.getModel(layoutName);
    if (!layout) {
      throw new Error(`Layout "${layoutName}" non trouv\xE9`);
    }
    if (layout.length === 0) {
      throw new Error(`Layout "${layoutName}" est vide`);
    }
    return layout;
  }
  // =========================================================================
  // GÃ‰NÃ‰RATION DE NOMS DE FICHIERS
  // =========================================================================
  /**
   * GÃ©nÃ¨re un nom de fichier unique
   */
  generateFileName(displayName, options) {
    if (options.customFileName) {
      return this.sanitizeFileName(options.customFileName);
    }
    const timestamp = new Date().toISOString().split("T")[0];
    const baseName = this.sanitizeFileName(displayName);
    const fileName = `${baseName} ${timestamp}.md`;
    return this.ensureUniqueFileName(fileName, options.folder);
  }
  /**
   * Nettoie un nom de fichier des caractÃ¨res interdits
   */
  sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim();
  }
  /**
   * Assure l'unicitÃ© d'un nom de fichier
   */
  ensureUniqueFileName(fileName, folder) {
    const fullPath = folder ? `${folder}/${fileName}` : fileName;
    if (!this.app.vault.getAbstractFileByPath(fullPath)) {
      return fileName;
    }
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").substring(0, 19);
    const baseName = fileName.replace(".md", "");
    return `${baseName} ${timestamp}.md`;
  }
  // =========================================================================
  // GÃ‰NÃ‰RATION DE CONTENU
  // =========================================================================
  /**
   * GÃ©nÃ¨re le contenu complet de la note
   */
  generateNoteContent(layoutName, displayName, layout, layoutInfo, options) {
    const parts = [
      this.generateFrontmatter(layoutName, layoutInfo),
      this.generateTitle(displayName),
      this.generateDescription(layoutInfo),
      this.generateSections(layout, layoutName, options.customContent),
      this.generateFooter(displayName, layout.length)
    ];
    return parts.filter((part) => part).join("\n");
  }
  /**
   * GÃ©nÃ¨re le frontmatter YAML
   */
  generateFrontmatter(layoutName, layoutInfo) {
    const today = new Date().toISOString().split("T")[0];
    return [
      "---",
      `agile-board: ${layoutName}`,
      `created: ${today}`,
      `type: agile-board`,
      `layout-type: ${(layoutInfo == null ? void 0 : layoutInfo.category) || "custom"}`,
      (layoutInfo == null ? void 0 : layoutInfo.tags) ? `tags: [${layoutInfo.tags.join(", ")}]` : "",
      "---",
      ""
    ].filter((line) => line !== "").join("\n");
  }
  /**
   * GÃ©nÃ¨re le titre principal
   */
  generateTitle(displayName) {
    return `# ${displayName}
`;
  }
  /**
   * GÃ©nÃ¨re la description (si disponible)
   */
  generateDescription(layoutInfo) {
    if (!(layoutInfo == null ? void 0 : layoutInfo.description)) {
      return "";
    }
    return `> ${layoutInfo.description}

`;
  }
  /**
   * GÃ©nÃ¨re toutes les sections
   */
  generateSections(layout, layoutName, customContent) {
    return layout.map((block) => {
      const sectionTitle = `## ${block.title}`;
      const content = (customContent == null ? void 0 : customContent[block.title]) || this.generateSectionContent(block.title, layoutName);
      return `${sectionTitle}

${content}
`;
    }).join("\n");
  }
  /**
   * GÃ©nÃ¨re le contenu d'une section selon son type
   */
  generateSectionContent(sectionTitle, layoutName) {
    const title = sectionTitle.toLowerCase();
    const contentMap = {
      // Sections de tÃ¢ches
      "todo_tasks": () => [
        "- [ ] Premi\xE8re t\xE2che \xE0 faire",
        "- [ ] Deuxi\xE8me t\xE2che importante",
        "- [ ] Autre t\xE2che \xE0 planifier"
      ],
      "in_progress": () => [
        "- [ ] T\xE2che en cours de r\xE9alisation",
        "",
        "*D\xE9placez ici les t\xE2ches en cours d'ex\xE9cution*"
      ],
      "done": () => [
        "- [x] Exemple de t\xE2che termin\xE9e",
        "",
        "*Les t\xE2ches compl\xE9t\xE9es appara\xEEtront ici*"
      ],
      // Matrice d'Eisenhower
      "urgent_important": () => [
        "- [ ] Crise \xE0 r\xE9soudre imm\xE9diatement",
        "- [ ] Urgence critique",
        "",
        "\u{1F6A8} **\xC0 traiter en priorit\xE9 absolue**"
      ],
      "important_not_urgent": () => [
        "- [ ] Planification long terme",
        "- [ ] D\xE9veloppement personnel",
        "",
        "\u{1F4CB} **\xC0 planifier et organiser**"
      ],
      "urgent_not_important": () => [
        "- [ ] Interruption \xE0 g\xE9rer",
        "- [ ] Email urgent",
        "",
        "\u23F0 **\xC0 d\xE9l\xE9guer si possible**"
      ],
      "not_urgent_not_important": () => [
        "- [ ] Activit\xE9 de loisir",
        "- [ ] Distraction",
        "",
        "\u{1F5D1}\uFE0F **\xC0 \xE9liminer ou minimiser**"
      ]
    };
    const sectionType = this.detectSectionType(title, layoutName);
    const generator = contentMap[sectionType];
    if (generator) {
      return generator().join("\n");
    }
    return [
      "- [ ] Premier \xE9l\xE9ment",
      "- [ ] Deuxi\xE8me \xE9l\xE9ment",
      "",
      "*Ajoutez vos \xE9l\xE9ments ici*"
    ].join("\n");
  }
  /**
   * DÃ©tecte le type d'une section
   */
  detectSectionType(title, layoutName) {
    if (title.includes("faire") || title.includes("todo") || title.includes("backlog")) {
      return "todo_tasks";
    }
    if (title.includes("cours") || title.includes("progress") || title.includes("doing")) {
      return "in_progress";
    }
    if (title.includes("termin\xE9") || title.includes("done") || title.includes("fini")) {
      return "done";
    }
    if (layoutName.includes("eisenhower")) {
      if (title.includes("urgent") && title.includes("important")) {
        return "urgent_important";
      }
      if (title.includes("important") && !title.includes("urgent")) {
        return "important_not_urgent";
      }
      if (title.includes("urgent") && !title.includes("important")) {
        return "urgent_not_important";
      }
      if (title.includes("ni urgent") || title.includes("pas") && (title.includes("urgent") || title.includes("important"))) {
        return "not_urgent_not_important";
      }
    }
    return "generic";
  }
  /**
   * GÃ©nÃ¨re le footer informatif
   */
  generateFooter(displayName, sectionsCount) {
    const today = new Date().toISOString().split("T")[0];
    return [
      "---",
      "",
      "### \u{1F4CA} Informations",
      `- **Layout** : ${displayName}`,
      `- **Sections** : ${sectionsCount}`,
      `- **Cr\xE9\xE9** : ${today}`,
      `- **Plugin** : Agile Board v0.7.0`,
      "",
      "> Cette note utilise le plugin Agile Board. Modifiez les sections selon vos besoins !"
    ].join("\n");
  }
  // =========================================================================
  // OPÃ‰RATIONS FICHIERS
  // =========================================================================
  /**
   * CrÃ©e le fichier dans le vault
   */
  async createFile(fileName, content, folder) {
    var _a, _b;
    const fullPath = folder ? `${folder}/${fileName}` : fileName;
    if (folder && !this.app.vault.getAbstractFileByPath(folder)) {
      await this.app.vault.createFolder(folder);
      (_a = this.logger) == null ? void 0 : _a.debug("Dossier cr\xE9\xE9", { folder });
    }
    const file = await this.app.vault.create(fullPath, content);
    (_b = this.logger) == null ? void 0 : _b.success("Fichier cr\xE9\xE9", {
      path: file.path,
      size: content.length
    });
    return file;
  }
  /**
   * Ouvre un fichier dans Obsidian
   */
  async openFile(file) {
    var _a;
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.openFile(file);
    (_a = this.logger) == null ? void 0 : _a.debug("Fichier ouvert", { path: file.path });
  }
  // =========================================================================
  // MÃ‰THODES UTILITAIRES PUBLIQUES
  // =========================================================================
  /**
   * CrÃ©e une note avec des paramÃ¨tres simplifiÃ©s
   */
  async createQuickNote(layoutName, customFileName) {
    return this.createNoteWithLayout({
      layoutName,
      customFileName,
      autoOpen: true
    });
  }
  /**
   * VÃ©rifie si un layout est disponible
   */
  isLayoutAvailable(layoutName) {
    return !!this.layoutService.getModel(layoutName);
  }
  /**
   * Retourne la liste des layouts disponibles pour crÃ©ation
   */
  getAvailableLayouts() {
    return this.layoutService.getAllModelsInfo().map((info) => ({
      name: info.name,
      displayName: info.displayName,
      description: info.description
    }));
  }
};

// src/services/BoardViewService.ts
var import_obsidian3 = require("obsidian");
var _BoardViewService = class {
  /**
   * Constructeur avec injection de dÃ©pendances
   */
  constructor(app, layoutService, logger) {
    this.app = app;
    this.layoutService = layoutService;
    this.logger = logger;
  }
  // =========================================================================
  // MÃ‰THODE PRINCIPALE
  // =========================================================================
  /**
   * Bascule vers la vue board pour un fichier
   * 
   * @param options - Options de basculement
   * @returns Promise<ViewSwitchResult> - RÃ©sultat du basculement
   */
  async switchToBoardView(options = {}) {
    var _a, _b, _c, _d, _e;
    (_a = this.logger) == null ? void 0 : _a.navigation("D\xE9but basculement vers vue board", { options });
    try {
      const targetFile = options.targetFile || this.app.workspace.getActiveFile();
      if (!targetFile) {
        throw new Error("Aucun fichier actif ou sp\xE9cifi\xE9");
      }
      const fileInfo = await this.analyzeFile(targetFile);
      if (!fileInfo.isValid) {
        throw new Error(`Fichier incompatible: ${fileInfo.layoutName ? `layout "${fileInfo.layoutName}" invalide` : "aucun layout agile-board"}`);
      }
      if (!options.forceSwitch && this.isCurrentlyInBoardView(targetFile)) {
        const message = "Fichier d\xE9j\xE0 affich\xE9 en vue board";
        (_b = this.logger) == null ? void 0 : _b.info(message, { fileName: targetFile.name });
        return {
          success: true,
          file: targetFile,
          layoutName: fileInfo.layoutName,
          boardLeaf: this.getCurrentBoardLeaf(targetFile),
          message
        };
      }
      const boardLeaf = await this.createBoardView(targetFile, fileInfo, options);
      const result = {
        success: true,
        file: targetFile,
        layoutName: fileInfo.layoutName,
        boardLeaf,
        message: `Vue board "${fileInfo.displayName}" activ\xE9e`
      };
      (_c = this.logger) == null ? void 0 : _c.success("Basculement r\xE9ussi", {
        fileName: targetFile.name,
        layoutName: fileInfo.layoutName,
        displayName: fileInfo.displayName
      });
      new import_obsidian3.Notice(`\u{1F4CA} Vue board "${fileInfo.displayName}" activ\xE9e`, 2e3);
      return result;
    } catch (error) {
      (_e = this.logger) == null ? void 0 : _e.error("Erreur lors du basculement", {
        message: error.message,
        fileName: ((_d = options.targetFile) == null ? void 0 : _d.name) || "non sp\xE9cifi\xE9"
      });
      new import_obsidian3.Notice(`\u274C Impossible de basculer: ${error.message}`, 4e3);
      return {
        success: false,
        file: options.targetFile || this.app.workspace.getActiveFile(),
        layoutName: "",
        boardLeaf: null,
        message: error.message
      };
    }
  }
  // =========================================================================
  // ANALYSE DE FICHIERS
  // =========================================================================
  /**
   * Analyse un fichier pour dÃ©terminer sa compatibilitÃ© board
   */
  async analyzeFile(file) {
    var _a, _b, _c;
    (_a = this.logger) == null ? void 0 : _a.debug("Analyse du fichier", { fileName: file.name });
    try {
      const fileCache = this.app.metadataCache.getFileCache(file);
      const layoutName = (_b = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _b["agile-board"];
      if (!layoutName) {
        return {
          file,
          layoutName: "",
          displayName: "",
          isValid: false,
          sections: []
        };
      }
      const layout = this.layoutService.getModel(layoutName);
      const layoutInfo = this.layoutService.getModelInfo(layoutName);
      if (!layout || !layoutInfo) {
        return {
          file,
          layoutName,
          displayName: layoutName,
          isValid: false,
          sections: []
        };
      }
      return {
        file,
        layoutName,
        displayName: layoutInfo.displayName,
        isValid: true,
        sections: layout.map((block) => block.title)
      };
    } catch (error) {
      (_c = this.logger) == null ? void 0 : _c.error("Erreur analyse fichier", error);
      return {
        file,
        layoutName: "",
        displayName: "",
        isValid: false,
        sections: []
      };
    }
  }
  /**
   * VÃ©rifie si un fichier est actuellement affichÃ© en vue board
   */
  isCurrentlyInBoardView(file) {
    return this.getCurrentBoardLeaf(file) !== null;
  }
  /**
   * Trouve l'onglet board actuel pour un fichier
   */
  getCurrentBoardLeaf(file) {
    const leaves = this.app.workspace.getLeavesOfType(_BoardViewService.BOARD_VIEW_TYPE);
    return leaves.find((leaf) => {
      var _a;
      const view = leaf.view;
      return ((_a = view.file) == null ? void 0 : _a.path) === file.path;
    }) || null;
  }
  // =========================================================================
  // CRÃ‰ATION DE VUES
  // =========================================================================
  /**
   * CrÃ©e une nouvelle vue board
   */
  async createBoardView(file, fileInfo, options) {
    var _a, _b, _c;
    (_a = this.logger) == null ? void 0 : _a.debug("Cr\xE9ation vue board", {
      fileName: file.name,
      layoutName: fileInfo.layoutName
    });
    let targetLeaf;
    if (options.newTab) {
      targetLeaf = this.app.workspace.getLeaf(true);
    } else {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view.getViewType() === "markdown" && ((_b = activeLeaf.view.file) == null ? void 0 : _b.path) === file.path) {
        targetLeaf = activeLeaf;
      } else {
        targetLeaf = this.app.workspace.getLeaf(true);
      }
    }
    await targetLeaf.setViewState({
      type: _BoardViewService.BOARD_VIEW_TYPE,
      state: {
        file: file.path,
        layoutName: fileInfo.layoutName
      }
    });
    this.app.workspace.setActiveLeaf(targetLeaf, { focus: true });
    (_c = this.logger) == null ? void 0 : _c.debug("Vue board cr\xE9\xE9e", {
      leafId: targetLeaf.id,
      viewType: targetLeaf.view.getViewType()
    });
    return targetLeaf;
  }
  // =========================================================================
  // MÃ‰THODES UTILITAIRES
  // =========================================================================
  /**
   * Bascule vers la vue markdown pour un fichier en vue board
   */
  async switchToMarkdownView(file) {
    var _a, _b;
    const targetFile = file || this.app.workspace.getActiveFile();
    if (!targetFile) {
      new import_obsidian3.Notice("\u274C Aucun fichier sp\xE9cifi\xE9");
      return false;
    }
    try {
      const boardLeaf = this.getCurrentBoardLeaf(targetFile);
      if (!boardLeaf) {
        new import_obsidian3.Notice("\u{1F4DD} Fichier d\xE9j\xE0 en vue markdown");
        return true;
      }
      await boardLeaf.setViewState({
        type: "markdown",
        state: { file: targetFile.path }
      });
      (_a = this.logger) == null ? void 0 : _a.success("Basculement vers vue markdown", {
        fileName: targetFile.name
      });
      new import_obsidian3.Notice("\u{1F4DD} Vue markdown activ\xE9e", 2e3);
      return true;
    } catch (error) {
      (_b = this.logger) == null ? void 0 : _b.error("Erreur basculement markdown", error);
      new import_obsidian3.Notice(`\u274C Erreur: ${error.message}`);
      return false;
    }
  }
  /**
   * VÃ©rifie si un fichier a un layout agile-board (sans l'analyser complÃ¨tement)
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.app.metadataCache.getFileCache(file);
    return !!((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]);
  }
  /**
   * Retourne la liste des fichiers avec layout agile-board dans le vault
   */
  async getAllBoardFiles() {
    const boardFiles = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      if (this.hasAgileBoardLayout(file)) {
        const fileInfo = await this.analyzeFile(file);
        if (fileInfo.isValid) {
          boardFiles.push(fileInfo);
        }
      }
    }
    return boardFiles;
  }
  /**
   * Ferme toutes les vues board ouvertes
   */
  async closeAllBoardViews() {
    var _a;
    const boardLeaves = this.app.workspace.getLeavesOfType(_BoardViewService.BOARD_VIEW_TYPE);
    let closedCount = 0;
    for (const leaf of boardLeaves) {
      await leaf.detach();
      closedCount++;
    }
    if (closedCount > 0) {
      (_a = this.logger) == null ? void 0 : _a.info("Vues board ferm\xE9es", { count: closedCount });
      new import_obsidian3.Notice(`\u{1F4CA} ${closedCount} vue(s) board ferm\xE9e(s)`);
    }
    return closedCount;
  }
  // =========================================================================
  // MÃ‰THODES DE DIAGNOSTIC
  // =========================================================================
  /**
   * Retourne des informations de diagnostic sur les vues
   */
  getDiagnosticInfo() {
    const boardLeaves = this.app.workspace.getLeavesOfType(_BoardViewService.BOARD_VIEW_TYPE);
    const activeLeaf = this.app.workspace.activeLeaf;
    const activeFile = this.app.workspace.getActiveFile();
    return {
      boardViewsCount: boardLeaves.length,
      boardFiles: boardLeaves.map((leaf) => {
        var _a;
        return ((_a = leaf.view.file) == null ? void 0 : _a.name) || "unknown";
      }),
      activeView: (activeLeaf == null ? void 0 : activeLeaf.view.getViewType()) || "none",
      activeFile: (activeFile == null ? void 0 : activeFile.name) || "none"
    };
  }
};
var BoardViewService = _BoardViewService;
/** ID de la vue board (doit correspondre Ã  celui enregistrÃ© dans main.ts) */
BoardViewService.BOARD_VIEW_TYPE = "agile-board-view";

// src/services/SectionManagerService.ts
var import_obsidian4 = require("obsidian");
var SectionManagerService = class {
  /**
   * Constructeur avec injection de dÃ©pendances
   */
  constructor(app, layoutService, logger) {
    this.app = app;
    this.layoutService = layoutService;
    this.logger = logger;
  }
  // =========================================================================
  // MÃ‰THODE PRINCIPALE
  // =========================================================================
  /**
   * CrÃ©e les sections manquantes dans un fichier
   * 
   * @param file - Fichier Ã  modifier
   * @param options - Options d'ajout
   * @returns Promise<AddSectionsResult>
   */
  async createMissingSections(file, options = {}) {
    var _a, _b, _c, _d, _e;
    (_a = this.logger) == null ? void 0 : _a.fileOperation("D\xE9but cr\xE9ation sections manquantes", {
      fileName: file.name,
      options
    });
    try {
      const analysis = await this.analyzeFile(file);
      if (!analysis.layoutName) {
        throw new Error("Aucun layout agile-board d\xE9tect\xE9 dans le fichier");
      }
      if (analysis.missingSections.length === 0) {
        const message = "Toutes les sections sont d\xE9j\xE0 pr\xE9sentes";
        (_b = this.logger) == null ? void 0 : _b.info(message, {
          fileName: file.name,
          sectionsCount: analysis.existingSections.length
        });
        new import_obsidian4.Notice(`\u2705 ${message}`, 2e3);
        return {
          success: true,
          sectionsAdded: 0,
          addedSectionNames: [],
          newContent: await this.app.vault.read(file),
          messages: [message]
        };
      }
      const newContent = await this.generateContentWithMissingSections(
        file,
        analysis,
        options
      );
      if (options.autoSave !== false) {
        await this.app.vault.modify(file, newContent);
        (_c = this.logger) == null ? void 0 : _c.success("Fichier modifi\xE9", {
          fileName: file.name,
          sectionsAdded: analysis.missingSections.length
        });
      }
      const result = {
        success: true,
        sectionsAdded: analysis.missingSections.length,
        addedSectionNames: analysis.missingSections,
        newContent,
        messages: [`${analysis.missingSections.length} section(s) ajout\xE9e(s)`]
      };
      new import_obsidian4.Notice(`\u2705 ${analysis.missingSections.length} section(s) ajout\xE9e(s)`, 3e3);
      (_d = this.logger) == null ? void 0 : _d.success("Sections manquantes cr\xE9\xE9es", {
        fileName: file.name,
        sectionsAdded: result.sectionsAdded,
        addedSections: result.addedSectionNames
      });
      return result;
    } catch (error) {
      (_e = this.logger) == null ? void 0 : _e.error("Erreur cr\xE9ation sections manquantes", {
        message: error.message,
        fileName: file.name
      });
      new import_obsidian4.Notice(`\u274C Erreur: ${error.message}`, 4e3);
      return {
        success: false,
        sectionsAdded: 0,
        addedSectionNames: [],
        newContent: "",
        messages: [error.message]
      };
    }
  }
  // =========================================================================
  // ANALYSE DE FICHIERS
  // =========================================================================
  /**
   * Analyse un fichier pour dÃ©tecter ses sections et le layout
   */
  async analyzeFile(file) {
    var _a, _b, _c;
    (_a = this.logger) == null ? void 0 : _a.debug("D\xE9but analyse fichier", { fileName: file.name });
    try {
      const content = await this.app.vault.read(file);
      const layoutName = this.detectLayout(file);
      const existingSections = this.parseSections(content);
      const layoutSections = layoutName ? this.getLayoutSections(layoutName) : [];
      const existingSectionNames = existingSections.map((s) => s.name);
      const missingSections = layoutSections.filter(
        (layoutSection) => !existingSectionNames.includes(layoutSection)
      );
      const extraSections = existingSectionNames.filter(
        (existing) => !layoutSections.includes(existing)
      );
      const analysis = {
        file,
        layoutName,
        existingSections,
        missingSections,
        extraSections,
        correctOrder: layoutSections
      };
      (_b = this.logger) == null ? void 0 : _b.debug("Analyse termin\xE9e", {
        fileName: file.name,
        layoutName,
        existingSectionsCount: existingSections.length,
        missingSectionsCount: missingSections.length,
        extraSectionsCount: extraSections.length
      });
      return analysis;
    } catch (error) {
      (_c = this.logger) == null ? void 0 : _c.error("Erreur analyse fichier", error);
      throw error;
    }
  }
  /**
   * DÃ©tecte le layout d'un fichier
   */
  detectLayout(file) {
    var _a;
    const fileCache = this.app.metadataCache.getFileCache(file);
    return ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]) || "";
  }
  /**
   * RÃ©cupÃ¨re les sections d'un layout
   */
  getLayoutSections(layoutName) {
    const layout = this.layoutService.getModel(layoutName);
    if (!layout) {
      throw new Error(`Layout "${layoutName}" non trouv\xE9`);
    }
    return layout.map((block) => block.title);
  }
  /**
   * Parse les sections d'un contenu markdown
   */
  parseSections(content) {
    const lines = content.split("\n");
    const sections = [];
    let currentSection = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith("## ")) {
        if (currentSection) {
          this.finalizeSection(currentSection, i - 1, lines);
          sections.push(currentSection);
        }
        currentSection = {
          name: line.substring(3).trim(),
          // Enlever "## "
          startLine: i,
          lines: [],
          isFromLayout: false
          // Sera dÃ©terminÃ© plus tard
        };
      } else if (currentSection) {
        currentSection.lines.push(line);
      }
    }
    if (currentSection) {
      this.finalizeSection(currentSection, lines.length - 1, lines);
      sections.push(currentSection);
    }
    return sections;
  }
  /**
   * Finalise une section parsÃ©e
   */
  finalizeSection(section, endLine, allLines) {
    section.endLine = endLine;
    section.content = section.lines.join("\n").trim();
    while (section.lines.length > 0 && section.lines[section.lines.length - 1].trim() === "") {
      section.lines.pop();
    }
  }
  // =========================================================================
  // GÃ‰NÃ‰RATION DE CONTENU
  // =========================================================================
  /**
   * GÃ©nÃ¨re le nouveau contenu avec les sections manquantes
   */
  async generateContentWithMissingSections(file, analysis, options) {
    const originalContent = await this.app.vault.read(file);
    const lines = originalContent.split("\n");
    const frontmatterEnd = this.findFrontmatterEnd(lines);
    const newLines = [];
    newLines.push(...lines.slice(0, frontmatterEnd + 1));
    const insertPosition = options.insertPosition || "layout-order";
    if (insertPosition === "layout-order") {
      await this.addSectionsInLayoutOrder(newLines, analysis, options);
    } else if (insertPosition === "end") {
      this.addExistingContent(newLines, analysis, lines, frontmatterEnd);
      this.addMissingSectionsAtEnd(newLines, analysis, options);
    } else {
      this.addMissingSectionsAfterFrontmatter(newLines, analysis, options);
      this.addExistingContent(newLines, analysis, lines, frontmatterEnd);
    }
    return newLines.join("\n");
  }
  /**
   * Trouve la fin du frontmatter
   */
  findFrontmatterEnd(lines) {
    let frontmatterCount = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === "---") {
        frontmatterCount++;
        if (frontmatterCount === 2) {
          return i;
        }
      }
      if (lines[i].startsWith("# ")) {
        return i;
      }
    }
    return 0;
  }
  /**
   * Ajoute les sections dans l'ordre du layout
   */
  async addSectionsInLayoutOrder(newLines, analysis, options) {
    const existingSectionsMap = new Map(
      analysis.existingSections.map((s) => [s.name, s])
    );
    for (const sectionName of analysis.correctOrder) {
      newLines.push("");
      newLines.push(`## ${sectionName}`);
      newLines.push("");
      const existingSection = existingSectionsMap.get(sectionName);
      if (existingSection) {
        newLines.push(...existingSection.lines);
      } else {
        if (options.addDefaultContent !== false) {
          const defaultContent = this.generateDefaultSectionContent(
            sectionName,
            analysis.layoutName
          );
          newLines.push(...defaultContent);
        }
      }
      newLines.push("");
    }
  }
  /**
   * Ajoute le contenu existant (sections non-layout)
   */
  addExistingContent(newLines, analysis, originalLines, frontmatterEnd) {
    for (const section of analysis.existingSections) {
      if (!analysis.correctOrder.includes(section.name)) {
        newLines.push("");
        newLines.push(`## ${section.name}`);
        newLines.push("");
        newLines.push(...section.lines);
        newLines.push("");
      }
    }
  }
  /**
   * Ajoute les sections manquantes Ã  la fin
   */
  addMissingSectionsAtEnd(newLines, analysis, options) {
    for (const sectionName of analysis.missingSections) {
      newLines.push("");
      newLines.push(`## ${sectionName}`);
      newLines.push("");
      if (options.addDefaultContent !== false) {
        const defaultContent = this.generateDefaultSectionContent(
          sectionName,
          analysis.layoutName
        );
        newLines.push(...defaultContent);
      }
      newLines.push("");
    }
  }
  /**
   * Ajoute les sections manquantes aprÃ¨s le frontmatter
   */
  addMissingSectionsAfterFrontmatter(newLines, analysis, options) {
    this.addMissingSectionsAtEnd(newLines, analysis, options);
  }
  /**
   * GÃ©nÃ¨re le contenu par dÃ©faut pour une section
   */
  generateDefaultSectionContent(sectionName, layoutName) {
    const title = sectionName.toLowerCase();
    if (title.includes("faire") || title.includes("todo") || title.includes("backlog")) {
      return [
        "- [ ] Nouvelle t\xE2che \xE0 faire",
        "- [ ] Autre t\xE2che importante"
      ];
    }
    if (title.includes("cours") || title.includes("progress") || title.includes("doing")) {
      return [
        "- [ ] T\xE2che en cours",
        "",
        "*T\xE2ches actuellement en cours de r\xE9alisation*"
      ];
    }
    if (title.includes("termin\xE9") || title.includes("done") || title.includes("fini")) {
      return [
        "- [x] T\xE2che exemple termin\xE9e",
        "",
        "*T\xE2ches compl\xE9t\xE9es*"
      ];
    }
    if (layoutName.includes("eisenhower")) {
      if (title.includes("urgent") && title.includes("important")) {
        return [
          "- [ ] T\xE2che critique",
          "",
          "\u{1F6A8} **Priorit\xE9 maximale**"
        ];
      }
      if (title.includes("important") && !title.includes("urgent")) {
        return [
          "- [ ] T\xE2che importante \xE0 planifier",
          "",
          "\u{1F4CB} **\xC0 organiser**"
        ];
      }
      if (title.includes("urgent") && !title.includes("important")) {
        return [
          "- [ ] Interruption \xE0 g\xE9rer",
          "",
          "\u23F0 **\xC0 d\xE9l\xE9guer**"
        ];
      }
      if (title.includes("ni urgent") || title.includes("pas") && title.includes("urgent")) {
        return [
          "- [ ] Activit\xE9 optionnelle",
          "",
          "\u{1F5D1}\uFE0F **\xC0 \xE9liminer**"
        ];
      }
    }
    return [
      "- [ ] Nouvel \xE9l\xE9ment",
      "- [ ] Autre \xE9l\xE9ment",
      "",
      "*Section ajout\xE9e automatiquement*"
    ];
  }
  // =========================================================================
  // MÃ‰THODES UTILITAIRES
  // =========================================================================
  /**
   * VÃ©rifie si un fichier a toutes ses sections
   */
  async hasAllSections(file) {
    const analysis = await this.analyzeFile(file);
    return analysis.missingSections.length === 0;
  }
  /**
   * Compte les sections manquantes d'un fichier
   */
  async countMissingSections(file) {
    const analysis = await this.analyzeFile(file);
    return analysis.missingSections.length;
  }
  /**
   * Liste tous les fichiers avec sections manquantes
   */
  async findFilesWithMissingSections() {
    var _a;
    const results = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      try {
        const analysis = await this.analyzeFile(file);
        if (analysis.layoutName && analysis.missingSections.length > 0) {
          results.push({
            file,
            missingSectionsCount: analysis.missingSections.length,
            missingSections: analysis.missingSections
          });
        }
      } catch (error) {
        (_a = this.logger) == null ? void 0 : _a.debug("Erreur analyse fichier pour recherche", {
          fileName: file.name,
          error: error.message
        });
      }
    }
    return results;
  }
};

// src/views/BoardView.ts
var import_obsidian5 = require("obsidian");

// src/components/MarkdownFrame.ts
var MarkdownFrame = class {
  // ===========================================================================
  // CONSTRUCTEUR ET INITIALISATION
  // ===========================================================================
  /**
   * CONSTRUCTEUR du composant MarkdownFrame
   * * @param app - Instance principale d'Obsidian
   * @param container - Ã‰lÃ©ment DOM parent oÃ¹ injecter le composant
   * @param file - Fichier source contenant cette section
   * @param section - MÃ©tadonnÃ©es de la section (lignes, position)
   * @param onChange - Callback appelÃ© lors des modifications
   * * INJECTION DE DÃ‰PENDANCES :
   * - app : Pour accÃ¨s aux APIs Obsidian (rendu, navigation)
   * - container : Pour manipulation DOM
   * - file : Pour contexte de rendu (chemins relatifs, etc.)
   * - onChange : Pour notifier le parent des changements
   * * INITIALISATION :
   * Le constructeur dÃ©marre immÃ©diatement l'initialisation complÃ¨te.
   * * @example
   * const frame = new MarkdownFrame(
   * app,
   * frameElement,
   * currentFile,
   * sectionData,
   * (newContent) => saveToFile(sectionName, newContent)
   * );
   */
  constructor(app, container, file, section, onChange) {
    this.app = app;
    this.container = container;
    this.file = file;
    this.section = section;
    this.onChange = onChange;
    // ===========================================================================
    // PROPRIÃ‰TÃ‰S D'Ã‰TAT DU COMPOSANT
    // ===========================================================================
    /**
     * Indicateur du mode d'Ã©dition actuel
     * * Ã‰TATS POSSIBLES :
     * - false : Mode preview (affichage rendu)
     * - true : Mode Ã©dition (textarea visible)
     */
    this.isEditing = false;
    this.content = section.lines.join("\n");
    this.initializeFrame();
  }
  /**
   * Initialise complÃ¨tement l'interface du composant
   * * Ã‰TAPES D'INITIALISATION :
   * 1. Configuration du conteneur principal
   * 2. CrÃ©ation du conteneur preview
   * 3. CrÃ©ation du conteneur d'Ã©dition
   * 4. Affichage initial en mode preview
   * * PATTERN TEMPLATE METHOD :
   * Orchestration de l'initialisation en Ã©tapes dÃ©finies.
   */
  initializeFrame() {
    this.setupContainer();
    this.createPreviewContainer();
    this.createEditorContainer();
    this.showPreview();
  }
  /**
   * Configure le conteneur principal du composant
   * * NETTOYAGE :
   * Vide le conteneur existant pour Ã©viter les conflits.
   * * STYLES CSS :
   * - Position relative pour positionnement des enfants
   * - Overflow hidden pour contenir le contenu
   * - Dimensions 100% pour remplir l'espace disponible
   */
  setupContainer() {
    this.container.empty();
    this.container.style.cssText = `
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    `;
  }
  // ===========================================================================
  // CRÃ‰ATION DES INTERFACES PREVIEW ET Ã‰DITION
  // ===========================================================================
  /**
   * CrÃ©e et configure le conteneur de preview (affichage rendu)
   * * RESPONSABILITÃ‰S :
   * - Affichage du contenu markdown rendu
   * - Gestion des interactions (clics, tÃ¢ches, liens)
   * - DÃ©tection du basculement vers l'Ã©dition
   * * STYLES :
   * IntÃ©gration avec les variables CSS d'Obsidian pour cohÃ©rence visuelle.
   */
  createPreviewContainer() {
    this.previewContainer = this.container.createDiv("markdown-preview");
    this.previewContainer.style.cssText = `
      width: 100%;
      height: 100%;
      overflow: auto;
      padding: 0.5rem;
      cursor: text;
      box-sizing: border-box;
    `;
    this.renderContent();
    this.setupPreviewEvents();
  }
  /**
   * CrÃ©e et configure le conteneur d'Ã©dition (textarea)
   * * RESPONSABILITÃ‰S :
   * - Interface de modification directe du markdown
   * - Sauvegarde automatique des changements
   * - Gestion des raccourcis clavier (Escape)
   * * VISIBILITÃ‰ :
   * Initialement cachÃ©, affichÃ© seulement en mode Ã©dition.
   */
  createEditorContainer() {
    this.editorContainer = this.container.createDiv("markdown-editor");
    this.editorContainer.style.cssText = `
      width: 100%;
      height: 100%;
      display: none;
      box-sizing: border-box;
    `;
    this.textArea = this.editorContainer.createEl("textarea");
    this.textArea.style.cssText = `
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      resize: none;
      font-family: var(--font-text);
      font-size: var(--font-size-normal);
      background: transparent;
      color: var(--text-normal);
      padding: 0.5rem;
      box-sizing: border-box;
      line-height: 1.6;
    `;
    this.textArea.value = this.content;
    this.setupEditorEvents();
  }
  // ===========================================================================
  // MOTEUR DE RENDU MARKDOWN
  // ===========================================================================
  /**
   * Rend le contenu markdown avec le moteur officiel d'Obsidian
   * * MOTEUR DE RENDU :
   * Utilise MarkdownRenderer.renderMarkdown() qui supporte :
   * - Toutes les extensions markdown d'Obsidian
   * - Plugins tiers (Tasks, Dataview, etc.)
   * - Liens internes et navigation
   * - Syntaxe avancÃ©e (callouts, etc.)
   * * FALLBACK :
   * En cas d'erreur, utilise un moteur de rendu simple
   * pour maintenir la fonctionnalitÃ© de base.
   * * GESTION DU CONTENU VIDE :
   * Affiche un placeholder engageant pour inciter Ã  l'Ã©dition.
   */
  async renderContent() {
    this.previewContainer.empty();
    if (!this.content.trim()) {
      this.renderEmptyState();
      return;
    }
    try {
      const { MarkdownRenderer, Component } = require("obsidian");
      const component = new Component();
      await MarkdownRenderer.renderMarkdown(
        this.content,
        // Contenu Ã  rendre
        this.previewContainer,
        // Conteneur de destination
        this.file.path,
        // Contexte de fichier (pour liens relatifs)
        component
        // Composant pour cycle de vie
      );
      console.log("\u2705 Contenu rendu avec le moteur Obsidian (plugins support\xE9s)");
      this.setupInteractions();
    } catch (error) {
      console.warn("\u26A0\uFE0F Erreur rendu Obsidian, fallback vers rendu simple:", error);
      this.previewContainer.innerHTML = this.renderSimpleMarkdown(this.content);
    }
  }
  /**
   * Configure les interactions avec les Ã©lÃ©ments rendus
   * * INTERACTIONS SUPPORTÃ‰ES :
   * 1. TÃ¢ches cochables (Tasks plugin)
   * 2. Liens internes Obsidian
   * 3. Liens externes
   * 4. Ã‰lÃ©ments Dataview
   * * PATTERN EVENT DELEGATION :
   * Ajoute des Ã©couteurs sur les Ã©lÃ©ments spÃ©cifiques
   * plutÃ´t que sur le conteneur global.
   * * PRÃ‰VENTION DE PROPAGATION :
   * EmpÃªche les clics sur Ã©lÃ©ments interactifs de dÃ©clencher
   * le mode Ã©dition.
   */
  setupInteractions() {
    const taskCheckboxes = this.previewContainer.querySelectorAll('input[type="checkbox"].task-list-item-checkbox');
    taskCheckboxes.forEach((checkbox) => {
      checkbox.addEventListener("change", (event) => {
        const target = event.target;
        this.handleTaskToggle(target);
      });
    });
    const internalLinks = this.previewContainer.querySelectorAll("a.internal-link");
    internalLinks.forEach((link) => {
      link.addEventListener("click", (event) => {
        event.preventDefault();
        const href = link.getAttribute("data-href") || link.getAttribute("href");
        if (href) {
          this.app.workspace.openLinkText(href, this.file.path);
        }
      });
    });
    const interactiveElements = this.previewContainer.querySelectorAll("input, button, a, .dataview, .task-list-item");
    interactiveElements.forEach((element) => {
      element.addEventListener("click", (event) => {
        event.stopPropagation();
      });
    });
  }
  /**
   * GÃ¨re le cochage/dÃ©cochage des tÃ¢ches
   * * ALGORITHME :
   * 1. Identifier la tÃ¢che modifiÃ©e dans le DOM
   * 2. Trouver la ligne correspondante dans le markdown
   * 3. Mettre Ã  jour la syntaxe de tÃ¢che ([ ] â†” [x])
   * 4. DÃ©clencher la sauvegarde automatique
   * * SYNCHRONISATION :
   * Maintient la cohÃ©rence entre affichage et source markdown.
   * * @param checkbox - Ã‰lÃ©ment checkbox qui a Ã©tÃ© modifiÃ©
   * * @example
   * // Utilisateur coche une tÃ¢che dans l'affichage
   * // handleTaskToggle() met Ã  jour le markdown :
   * // "- [ ] TÃ¢che" â†’ "- [x] TÃ¢che"
   */
  handleTaskToggle(checkbox) {
    const isChecked = checkbox.checked;
    const listItem = checkbox.closest("li");
    if (!listItem)
      return;
    const taskText = this.getTaskTextFromListItem(listItem);
    if (!taskText)
      return;
    const lines = this.content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (this.isTaskLine(line) && this.getTaskTextFromLine(line) === taskText) {
        const newCheckState = isChecked ? "[x]" : "[ ]";
        lines[i] = line.replace(/\[[ x]\]/, newCheckState);
        this.content = lines.join("\n");
        clearTimeout(this.changeTimeout);
        this.changeTimeout = setTimeout(() => {
          this.onChange(this.content);
        }, 500);
        console.log(`\u2705 T\xE2che ${isChecked ? "coch\xE9e" : "d\xE9coch\xE9e"}: ${taskText}`);
        break;
      }
    }
  }
  /**
   * Extrait le texte d'une tÃ¢che depuis un Ã©lÃ©ment de liste DOM
   * * @param listItem - Ã‰lÃ©ment <li> contenant la tÃ¢che
   * @returns string | null - Texte de la tÃ¢che ou null si non trouvÃ©
   */
  getTaskTextFromListItem(listItem) {
    var _a;
    const textNode = listItem.childNodes[listItem.childNodes.length - 1];
    return ((_a = textNode == null ? void 0 : textNode.textContent) == null ? void 0 : _a.trim()) || null;
  }
  /**
   * VÃ©rifie si une ligne markdown est une tÃ¢che
   * * @param line - Ligne de texte Ã  vÃ©rifier
   * @returns boolean - true si c'est une ligne de tÃ¢che
   * * @example
   * isTaskLine("- [x] TÃ¢che terminÃ©e");  // true
   * isTaskLine("- [ ] TÃ¢che Ã  faire");   // true
   * isTaskLine("- Simple liste");        // false
   */
  isTaskLine(line) {
    return /^[\s]*[-*+] \[[ x]\]/.test(line);
  }
  /**
   * Extrait le texte d'une tÃ¢che depuis une ligne markdown
   * * @param line - Ligne markdown contenant une tÃ¢che
   * @returns string - Texte de la tÃ¢che (sans la syntaxe de liste/checkbox)
   */
  getTaskTextFromLine(line) {
    const match = line.match(/^[\s]*[-*+] \[[ x]\] (.+)$/);
    return match ? match[1].trim() : "";
  }
  /**
   * Moteur de rendu markdown simple (fallback)
   * * UTILISATION :
   * Quand le moteur Obsidian n'est pas disponible ou Ã©choue.
   * Supporte la syntaxe markdown de base.
   * * FONCTIONNALITÃ‰S :
   * - Liens internes [[...]]
   * - Gras **texte**
   * - Italique *texte*
   * - Listes simples
   * * @param content - Contenu markdown Ã  rendre
   * @returns string - HTML gÃ©nÃ©rÃ©
   */
  renderSimpleMarkdown(content) {
    let html = content;
    html = html.replace(/\[\[([^\]]+)\]\]/g, '<span class="internal-link">$1</span>');
    html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
    html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
    html = html.replace(/^[\s]*[-*+] (.+)$/gm, "<li>$1</li>");
    const lines = html.split("\n");
    let result = "";
    let inList = false;
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.includes("<li>")) {
        if (!inList) {
          result += "<ul>\n";
          inList = true;
        }
        result += line + "\n";
      } else {
        if (inList) {
          result += "</ul>\n";
          inList = false;
        }
        if (trimmed === "") {
          result += "<br>\n";
        } else {
          result += `<p>${trimmed}</p>
`;
        }
      }
    }
    if (inList) {
      result += "</ul>\n";
    }
    return result;
  }
  /**
   * Affiche un Ã©tat vide engageant pour inciter Ã  l'Ã©dition
   * * DESIGN UX :
   * Message clair et incitatif plutÃ´t qu'un vide intimidant.
   * Style cohÃ©rent avec l'interface Obsidian.
   */
  renderEmptyState() {
    const placeholder = this.previewContainer.createDiv("empty-placeholder");
    placeholder.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      min-height: 80px;
      color: var(--text-muted);
      font-style: italic;
      cursor: text;
    `;
    placeholder.textContent = "Cliquez pour commencer \xE0 \xE9crire...";
  }
  // ===========================================================================
  // GESTION DES Ã‰VÃ‰NEMENTS ET INTERACTIONS
  // ===========================================================================
  /**
   * Configure les Ã©vÃ©nements du mode preview
   * * DÃ‰TECTION INTELLIGENTE :
   * Distingue les clics sur Ã©lÃ©ments interactifs des clics d'Ã©dition.
   * Ã‰vite le basculement involontaire vers l'Ã©dition.
   */
  setupPreviewEvents() {
    this.previewContainer.addEventListener("click", (event) => {
      const target = event.target;
      if (this.isInteractiveElement(target)) {
        console.log("\u{1F3AF} Clic sur \xE9l\xE9ment interactif, pas de mode \xE9dition");
        return;
      }
      console.log("\u{1F5B1}\uFE0F Clic sur preview \u2192 mode \xE9dition");
      this.enterEditMode();
    });
  }
  /**
   * DÃ©tecte si un Ã©lÃ©ment est interactif (ne doit pas dÃ©clencher l'Ã©dition)
   * * Ã‰LÃ‰MENTS INTERACTIFS :
   * - Ã‰lÃ©ments HTML standard : input, button, a, select
   * - Ã‰lÃ©ments Obsidian : liens internes, tags
   * - Ã‰lÃ©ments de plugins : dataview, tasks
   * - Ã‰lÃ©ments avec attributs spÃ©ciaux
   * * ALGORITHME :
   * Remonte la hiÃ©rarchie DOM pour vÃ©rifier tous les parents.
   * Un Ã©lÃ©ment est interactif si lui ou un parent l'est.
   * * @param element - Ã‰lÃ©ment Ã  vÃ©rifier
   * @returns boolean - true si interactif
   */
  isInteractiveElement(element) {
    let current = element;
    while (current && current !== this.previewContainer) {
      const tagName = current.tagName.toLowerCase();
      const classList = Array.from(current.classList);
      if (["input", "button", "a", "select", "textarea"].includes(tagName)) {
        return true;
      }
      const interactiveClasses = [
        "internal-link",
        "external-link",
        "tag",
        "dataview",
        "task-list-item-checkbox",
        "task-list-item",
        "cm-hmd-codeblock",
        "block-language-dataview",
        "block-language-tasks"
      ];
      if (interactiveClasses.some((cls) => classList.includes(cls))) {
        return true;
      }
      if (current.hasAttribute("href") || current.hasAttribute("data-href") || current.hasAttribute("data-task") || current.hasAttribute("contenteditable")) {
        return true;
      }
      current = current.parentElement;
    }
    return false;
  }
  /**
   * Configure les Ã©vÃ©nements du mode Ã©dition
   * * Ã‰VÃ‰NEMENTS GÃ‰RÃ‰S :
   * - input : Sauvegarde diffÃ©rÃ©e des modifications
   * - blur : Retour automatique au mode preview
   * - keydown : Raccourcis clavier (Escape)
   */
  setupEditorEvents() {
    this.textArea.addEventListener("input", () => {
      this.content = this.textArea.value;
      clearTimeout(this.changeTimeout);
      this.changeTimeout = setTimeout(() => {
        this.onChange(this.content);
      }, 1e3);
    });
    this.textArea.addEventListener("blur", () => {
      console.log("\u{1F4DD} Blur sur textarea \u2192 mode preview");
      this.exitEditMode();
    });
    this.textArea.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        console.log("\u2328\uFE0F Escape \u2192 mode preview");
        this.exitEditMode();
      }
    });
  }
  // ===========================================================================
  // GESTION DES MODES (PREVIEW â†” Ã‰DITION)
  // ===========================================================================
  /**
   * Bascule vers le mode Ã©dition
   * * PROCESSUS :
   * 1. Marquer l'Ã©tat comme "en Ã©dition"
   * 2. Cacher le preview
   * 3. Afficher l'Ã©diteur
   * 4. Synchroniser le contenu
   * 5. Donner le focus au textarea
   */
  enterEditMode() {
    this.isEditing = true;
    this.previewContainer.style.display = "none";
    this.editorContainer.style.display = "block";
    this.textArea.value = this.content;
    this.textArea.focus();
    console.log("\u270F\uFE0F Mode \xE9dition activ\xE9");
  }
  /**
   * Bascule vers le mode preview
   * * PROCESSUS :
   * 1. VÃ©rifier qu'on est bien en Ã©dition
   * 2. RÃ©cupÃ©rer le contenu du textarea
   * 3. Cacher l'Ã©diteur
   * 4. Afficher le preview
   * 5. Re-rendre le contenu
   */
  exitEditMode() {
    if (!this.isEditing)
      return;
    this.isEditing = false;
    this.content = this.textArea.value;
    this.editorContainer.style.display = "none";
    this.previewContainer.style.display = "block";
    this.renderContent();
    console.log("\u{1F441}\uFE0F Mode preview activ\xE9");
  }
  /**
   * Force l'affichage du mode preview
   * * UTILISATION :
   * Initialisation du composant et rÃ©initialisations.
   */
  showPreview() {
    this.previewContainer.style.display = "block";
    this.editorContainer.style.display = "none";
    this.isEditing = false;
  }
  // ===========================================================================
  // API PUBLIQUE DU COMPOSANT
  // ===========================================================================
  /**
   * Met Ã  jour le contenu de la section
   * * UTILISATION :
   * Quand le fichier source est modifiÃ© externement.
   * Maintient la synchronisation avec la source de vÃ©ritÃ©.
   * * @param section - Nouvelles donnÃ©es de section
   */
  updateContent(section) {
    this.section = section;
    this.content = section.lines.join("\n");
    if (this.isEditing) {
      this.textArea.value = this.content;
    } else {
      this.renderContent();
    }
  }
  /**
   * Obtient le contenu actuel de la section
   * * @returns string - Contenu markdown actuel
   */
  getContent() {
    return this.isEditing ? this.textArea.value : this.content;
  }
  /**
   * DÃ©truit proprement le composant
   * * NETTOYAGE :
   * - Vide le conteneur DOM
   * - Annule les timers en cours
   * - LibÃ¨re les rÃ©fÃ©rences
   * * UTILISATION :
   * AppelÃ©e lors du nettoyage de la BoardView.
   */
  destroy() {
    this.container.empty();
    console.log("\u{1F5D1}\uFE0F MarkdownFrame d\xE9truite");
  }
};

// src/views/BoardView.ts
var BOARD_VIEW_TYPE = "agile-board-view";
var BoardView = class extends import_obsidian5.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.gridContainer = null;
    this.frames = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    console.log("\u{1F3AF} BoardView constructor appel\xE9");
  }
  getViewType() {
    return BOARD_VIEW_TYPE;
  }
  getDisplayText() {
    return this.file ? `${this.file.basename} (Board)` : "Agile Board";
  }
  getIcon() {
    return "layout-grid";
  }
  async onLoadFile(file) {
    console.log("\u{1F4C2} onLoadFile appel\xE9 pour:", file.basename);
    await this.renderBoardLayout();
  }
  async onUnloadFile(file) {
    console.log("\u{1F4C2} onUnloadFile appel\xE9 pour:", file.basename);
    this.cleanup();
  }
  // MÃ©thode publique pour recharger le board
  async renderBoardLayout() {
    var _a;
    console.log("\u{1F3A8} renderBoardLayout d\xE9but");
    if (!this.file) {
      console.log("\u274C Pas de fichier dans renderBoardLayout");
      return;
    }
    console.log("\u{1F4C4} Fichier actuel:", this.file.basename);
    this.cleanup();
    const fileCache = this.app.metadataCache.getFileCache(this.file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    console.log("\u{1F3AF} Layout name d\xE9tect\xE9:", layoutName);
    if (!layoutName) {
      console.log("\u274C Pas de layout agile-board trouv\xE9");
      this.showNoLayoutMessage();
      return;
    }
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.log("\u274C Layout non trouv\xE9 dans le service");
      this.showLayoutNotFoundMessage(layoutName);
      return;
    }
    let sections = await this.plugin.fileService.parseSections(this.file);
    console.log("\u{1F4DA} Sections pars\xE9es:", Object.keys(sections));
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = this.plugin.fileService.getMissingSections(existingSections, requiredSections);
    if (missingSections.length > 0) {
      console.log("\u{1F527} Sections manquantes d\xE9tect\xE9es:", missingSections);
      this.showMissingSectionsMessage(missingSections, layout);
      return;
    }
    console.log("\u2705 Rendu Board pour:", this.file.basename, "avec layout:", layoutName);
    this.createGrid();
    this.createFrames(layout, sections);
  }
  cleanup() {
    for (const frame of this.frames.values()) {
      frame.destroy();
    }
    this.frames.clear();
    if (this.gridContainer) {
      this.gridContainer.remove();
      this.gridContainer = null;
    }
    this.contentEl.empty();
  }
  createGrid() {
    console.log("\u{1F532} Cr\xE9ation de la grille");
    this.gridContainer = this.contentEl.createDiv("agile-board-grid");
    this.gridContainer.style.cssText = `
      display: grid;
      grid-template-columns: repeat(24, 1fr);
      gap: 0.5rem;
      padding: 1rem;
      height: 100%;
      overflow: auto;
      background: var(--background-primary);
    `;
  }
  createFrames(layout, sections) {
    if (!this.gridContainer) {
      console.log("\u274C Pas de gridContainer pour cr\xE9er les frames");
      return;
    }
    console.log("\u{1F5BC}\uFE0F Cr\xE9ation de", layout.length, "frames");
    for (const block of layout) {
      console.log("\u{1F5BC}\uFE0F Cr\xE9ation frame pour:", block.title);
      const frameElement = this.gridContainer.createDiv("agile-board-frame");
      frameElement.style.cssText = `
        grid-column: ${block.x + 1} / span ${block.w};
        grid-row: ${block.y + 1} / span ${block.h};
        min-height: 100px;
        display: flex;
        flex-direction: column;
        border: 2px solid var(--background-modifier-border);
        border-radius: 6px;
        background: var(--background-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      `;
      const titleElement = frameElement.createDiv("frame-title");
      titleElement.style.cssText = `
        padding: 0.5rem 0.75rem;
        font-weight: 500;
        color: var(--text-normal);
        border-bottom: 1px solid var(--background-modifier-border);
        background: var(--background-secondary);
        font-size: 1.1rem;
      `;
      titleElement.textContent = block.title;
      const contentElement = frameElement.createDiv("frame-content");
      contentElement.style.cssText = `
        flex: 1;
        overflow: auto;
        background: var(--background-primary);
      `;
      const section = sections[block.title];
      if (section) {
        const frame = new MarkdownFrame(
          this.app,
          contentElement,
          this.file,
          section,
          (content) => this.onFrameContentChanged(block.title, content)
        );
        this.frames.set(block.title, frame);
        console.log(`\u2705 Frame \xE9ditable cr\xE9\xE9e pour "${block.title}"`);
      } else {
        contentElement.style.padding = "0.75rem";
        contentElement.innerHTML = `
          <p><strong>\u274C Section manquante:</strong> ${block.title}</p>
          <p><em>Sections disponibles:</em> ${Object.keys(sections).join(", ")}</p>
        `;
        console.log(`\u274C Section "${block.title}" non trouv\xE9e`);
      }
    }
    console.log("\u2705 Toutes les frames cr\xE9\xE9es");
  }
  async onFrameContentChanged(sectionName, content) {
    if (!this.file)
      return;
    console.log(`\u{1F4BE} Changement d\xE9tect\xE9 dans la section "${sectionName}"`);
    try {
      const fileContent = await this.app.vault.read(this.file);
      const lines = fileContent.split("\n");
      const sections = await this.plugin.fileService.parseSections(this.file);
      const section = sections[sectionName];
      if (!section) {
        console.log(`\u274C Section "${sectionName}" non trouv\xE9e pour la sauvegarde`);
        return;
      }
      const newLines = [
        ...lines.slice(0, section.start + 1),
        // Avant la section (inclus le titre)
        ...content.split("\n"),
        // Nouveau contenu
        ...lines.slice(section.end)
        // AprÃ¨s la section
      ];
      await this.app.vault.modify(this.file, newLines.join("\n"));
      console.log(`\u2705 Section "${sectionName}" sauvegard\xE9e`);
    } catch (error) {
      console.error(`\u274C Erreur sauvegarde section "${sectionName}":`, error);
    }
  }
  showNoLayoutMessage() {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("no-layout-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-muted);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Pas de layout agile-board</h3>
        <p>Cette note n'a pas de layout agile-board configur\xE9</p>
        <p>Ajoutez dans le frontmatter:<br><code>agile-board: layout_eisenhower</code></p>
      </div>
    `;
  }
  showLayoutNotFoundMessage(layoutName) {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("layout-not-found-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-error);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Layout "${layoutName}" introuvable</h3>
        <p>Layouts disponibles: ${this.plugin.layoutService.getAllModelNames().join(", ")}</p>
      </div>
    `;
  }
  showMissingSectionsMessage(missingBlocks, layout) {
    this.contentEl.empty();
    const errorContainer = this.contentEl.createDiv("missing-sections-overlay");
    errorContainer.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      height: 100%;
      padding: 2rem;
      text-align: center;
      background: var(--background-primary);
    `;
    const title = errorContainer.createEl("h2");
    title.textContent = "\u{1F527} Sections manquantes d\xE9tect\xE9es";
    title.style.cssText = `
      color: var(--text-normal);
      margin-bottom: 1rem;
    `;
    const description = errorContainer.createEl("p");
    description.textContent = "Les sections suivantes sont requises pour ce layout :";
    description.style.cssText = `
      color: var(--text-muted);
      margin-bottom: 1rem;
    `;
    const sectionsList = errorContainer.createEl("ul");
    sectionsList.style.cssText = `
      list-style: none;
      padding: 0;
      margin: 1rem 0;
      color: var(--text-normal);
    `;
    missingBlocks.forEach((section) => {
      const listItem = sectionsList.createEl("li");
      listItem.textContent = `# ${section}`;
      listItem.style.cssText = `
        font-family: var(--font-monospace);
        background: var(--background-secondary);
        padding: 0.5rem;
        margin: 0.25rem 0;
        border-radius: 4px;
      `;
    });
    const buttonContainer = errorContainer.createDiv();
    buttonContainer.style.cssText = `
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    `;
    const autoCreateButton = buttonContainer.createEl("button", { cls: "mod-cta" });
    autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
    autoCreateButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--interactive-accent);
      color: var(--text-on-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    autoCreateButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      console.log("\u{1F527} Cr\xE9ation automatique des sections manquantes...");
      autoCreateButton.textContent = "\u23F3 Cr\xE9ation...";
      autoCreateButton.disabled = true;
      try {
        await this.plugin.fileService.createMissingSections(this.file, layout);
        console.log("\u2705 Sections cr\xE9\xE9es, rechargement du board...");
        setTimeout(() => {
          this.renderBoardLayout();
        }, 500);
      } catch (error) {
        console.error("\u274C Erreur cr\xE9ation sections:", error);
        autoCreateButton.textContent = "\u274C Erreur";
        setTimeout(() => {
          autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
          autoCreateButton.disabled = false;
        }, 2e3);
      }
    });
    const markdownButton = buttonContainer.createEl("button");
    markdownButton.textContent = "\u{1F4DD} Mode Markdown";
    markdownButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--background-secondary);
      color: var(--text-normal);
      border: 1px solid var(--background-modifier-border);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    markdownButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      const leaf = this.app.workspace.activeLeaf;
      if (leaf) {
        await leaf.setViewState({
          type: "markdown",
          state: { file: this.file.path }
        });
      }
    });
  }
};

// src/managers/ViewSwitcher.ts
var import_obsidian6 = require("obsidian");
var ViewSwitcher = class {
  /**
   * CONSTRUCTEUR avec injection de dÃ©pendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * INJECTION DE DÃ‰PENDANCE :
   * Le plugin donne accÃ¨s Ã  :
   * - app : Instance Obsidian pour les opÃ©rations
   * - layoutService : Pour vÃ©rifier les layouts disponibles
   * - registerEvent : Pour s'abonner aux Ã©vÃ©nements
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  // ===========================================================================
  // MÃ‰THODES DE BASCULEMENT ENTRE VUES
  // ===========================================================================
  /**
   * Bascule vers la vue Board pour un fichier donnÃ©
   * 
   * PROCESSUS :
   * 1. Obtenir l'onglet actif (activeLeaf)
   * 2. Changer son type de vue vers BOARD_VIEW_TYPE
   * 3. Passer le chemin du fichier en paramÃ¨tre d'Ã©tat
   * 
   * CONCEPT OBSIDIAN - SETVIEWSTATE :
   * setViewState permet de changer complÃ¨tement le type de vue d'un onglet.
   * C'est comme transformer un onglet "texte" en onglet "image" par exemple.
   * 
   * @param file - Fichier Ã  afficher en mode Board
   * 
   * @example
   * // L'utilisateur clique sur le bouton "Mode Board"
   * viewSwitcher.switchToBoardView(currentFile);
   * // L'onglet passe de MarkdownView Ã  BoardView
   */
  async switchToBoardView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: BOARD_VIEW_TYPE,
        // Notre type de vue personnalisÃ©
        state: { file: file.path }
        // Ã‰tat initial : quel fichier afficher
      });
      console.log("\u{1F3AF} Basculement vers Board View");
    }
  }
  /**
   * Bascule vers la vue Markdown standard pour un fichier donnÃ©
   * 
   * PROCESSUS INVERSE :
   * MÃªme principe que switchToBoardView mais vers la vue standard d'Obsidian.
   * 
   * @param file - Fichier Ã  afficher en mode Markdown
   * 
   * @example
   * // L'utilisateur clique sur le bouton "Mode Markdown"
   * viewSwitcher.switchToMarkdownView(currentFile);
   * // L'onglet passe de BoardView Ã  MarkdownView
   */
  async switchToMarkdownView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: "markdown",
        // Type de vue standard d'Obsidian
        state: { file: file.path }
        // MÃªme fichier, vue diffÃ©rente
      });
      console.log("\u{1F4DD} Basculement vers Markdown View");
    }
  }
  // ===========================================================================
  // MÃ‰THODES DE DÃ‰TECTION DE CONTEXTE
  // ===========================================================================
  /**
   * VÃ©rifie si la vue actuelle est notre BoardView
   * 
   * UTILITÃ‰ :
   * Permet de savoir quel bouton afficher (Board â†’ Markdown ou Markdown â†’ Board).
   * 
   * MÃ‰THODE OBSIDIAN :
   * getActiveViewOfType() cherche une vue d'un type spÃ©cifique dans l'espace de travail.
   * Retourne l'instance ou null si aucune vue de ce type n'est active.
   * 
   * @returns boolean - true si on est en mode Board
   * 
   * @example
   * if (viewSwitcher.isCurrentViewBoardView()) {
   *   showMarkdownButton();
   * } else {
   *   showBoardButton();
   * }
   */
  isCurrentViewBoardView() {
    return this.plugin.app.workspace.getActiveViewOfType(BoardView) !== null;
  }
  /**
   * VÃ©rifie si la vue actuelle est la MarkdownView standard
   * 
   * COMPLÃ‰MENT DE isCurrentViewBoardView :
   * Ces deux mÃ©thodes permettent de couvrir tous les cas de figure.
   * 
   * @returns boolean - true si on est en mode Markdown
   */
  isCurrentViewMarkdownView() {
    return this.plugin.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView) !== null;
  }
  /**
   * VÃ©rifie si un fichier a un layout agile-board configurÃ©
   * 
   * LOGIQUE MÃ‰TIER :
   * - Seuls les fichiers avec layout agile-board peuvent utiliser la vue Board
   * - Cette vÃ©rification dÃ©termine si les boutons doivent Ãªtre affichÃ©s
   * 
   * ACCÃˆS AUX MÃ‰TADONNÃ‰ES :
   * - metadataCache : Cache des mÃ©tadonnÃ©es des fichiers
   * - getFileCache : Obtient les mÃ©tadonnÃ©es d'un fichier
   * - frontmatter : Bloc YAML en dÃ©but de fichier
   * 
   * @param file - Fichier Ã  vÃ©rifier
   * @returns boolean - true si le fichier a un layout agile-board
   * 
   * @example
   * // Fichier avec frontmatter :
   * // ---
   * // agile-board: layout_eisenhower
   * // ---
   * hasAgileBoardLayout(file); // true
   * 
   * // Fichier normal sans frontmatter
   * hasAgileBoardLayout(file); // false
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    return ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]) !== void 0;
  }
  // ===========================================================================
  // MÃ‰THODES DE GESTION DES BOUTONS D'INTERFACE
  // ===========================================================================
  /**
   * Configure les Ã©couteurs d'Ã©vÃ©nements pour la gestion automatique des boutons
   * 
   * Ã‰VÃ‰NEMENTS OBSIDIAN SURVEILLÃ‰S :
   * 1. active-leaf-change : Changement d'onglet actif
   * 2. file-open : Ouverture d'un nouveau fichier
   * 3. metadataCache.on('changed') : Modification des mÃ©tadonnÃ©es
   * 
   * PATTERN OBSERVER :
   * S'abonne aux Ã©vÃ©nements systÃ¨me plutÃ´t que de sonder constamment.
   * Plus efficace et rÃ©actif.
   * 
   * DÃ‰LAIS (setTimeout) :
   * Petits dÃ©lais pour laisser le temps Ã  Obsidian de finaliser les changements
   * avant de mettre Ã  jour l'interface.
   * 
   * @example
   * viewSwitcher.addSwitchButton();
   * // Ã€ partir de maintenant, les boutons apparaissent/disparaissent automatiquement
   */
  addSwitchButton() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.path === file.path) {
          setTimeout(() => this.updateSwitchButtonForFile(file), 100);
        }
      })
    );
    setTimeout(() => this.updateSwitchButton(), 100);
  }
  /**
   * Met Ã  jour les boutons pour un fichier spÃ©cifique
   * 
   * UTILISATION :
   * AppelÃ©e depuis l'extÃ©rieur (ModelDetector) quand un changement est dÃ©tectÃ©.
   * Version optimisÃ©e qui Ã©vite de re-analyser le contexte.
   * 
   * @param file - Fichier pour lequel mettre Ã  jour les boutons
   */
  updateSwitchButtonForFile(file) {
    const hasLayout = this.hasAgileBoardLayout(file);
    if (hasLayout) {
      if (this.isCurrentViewMarkdownView()) {
        this.ensureBoardModeButton();
      } else if (this.isCurrentViewBoardView()) {
        this.ensureNormalModeButton();
      }
    } else {
      this.removeSwitchButtons();
    }
  }
  /**
   * Met Ã  jour les boutons selon le contexte actuel
   * 
   * LOGIQUE GLOBALE :
   * 1. Identifier le fichier actif
   * 2. VÃ©rifier s'il a un layout agile-board
   * 3. DÃ©terminer la vue actuelle
   * 4. Afficher le bouton appropriÃ©
   * 
   * MÃ‰THODE PRINCIPALE :
   * Point d'entrÃ©e pour toutes les mises Ã  jour automatiques.
   */
  updateSwitchButton() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const hasLayout = this.hasAgileBoardLayout(activeFile);
    if (!hasLayout) {
      this.removeSwitchButtons();
      return;
    }
    if (this.isCurrentViewMarkdownView()) {
      this.ensureBoardModeButton();
    } else if (this.isCurrentViewBoardView()) {
      this.ensureNormalModeButton();
    } else {
      this.removeSwitchButtons();
    }
  }
  /**
   * S'assure qu'un bouton "Mode Board" est prÃ©sent en vue Markdown
   * 
   * PROCESSUS :
   * 1. Trouver la vue Markdown active
   * 2. Localiser la zone des actions de vue (.view-actions)
   * 3. Supprimer le bouton existant s'il y en a un
   * 4. CrÃ©er et configurer le nouveau bouton
   * 5. Ajouter les styles et l'Ã©vÃ©nement click
   * 
   * GESTION D'ERREURS :
   * Try-catch pour Ã©viter que les erreurs d'interface cassent le plugin.
   * 
   * CONCEPT OBSIDIAN - addAction :
   * addAction() est la mÃ©thode officielle pour ajouter des boutons aux vues.
   * ParamÃ¨tres : (icÃ´ne, tooltip, callback)
   */
  ensureBoardModeButton() {
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    if (!markdownView)
      return;
    const viewActions = markdownView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = markdownView.addAction("layout-grid", "Mode Board", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToBoardView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "board-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Board ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Board:", error);
    }
  }
  /**
   * S'assure qu'un bouton "Mode Markdown" est prÃ©sent en vue Board
   * 
   * PROCESSUS SIMILAIRE Ã  ensureBoardModeButton mais pour BoardView.
   * 
   * DIFFÃ‰RENCES :
   * - Utilise getActiveViewOfType(BoardView)
   * - IcÃ´ne 'document' au lieu de 'layout-grid'
   * - Callback vers switchToMarkdownView
   */
  ensureNormalModeButton() {
    const boardView = this.plugin.app.workspace.getActiveViewOfType(BoardView);
    if (!boardView)
      return;
    const viewActions = boardView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = boardView.addAction("document", "Mode Markdown", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToMarkdownView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "normal-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Markdown ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Markdown:", error);
    }
  }
  /**
   * Supprime tous les boutons de basculement de l'interface
   * 
   * UTILISATION :
   * - Quand on ouvre un fichier sans layout agile-board
   * - Quand on bascule vers une vue non supportÃ©e
   * - Lors du nettoyage du plugin
   * 
   * SÃ‰LECTEUR GLOBAL :
   * Utilise document.querySelectorAll pour trouver tous les boutons,
   * mÃªme s'ils sont dans des onglets diffÃ©rents.
   * 
   * CLASSE IDENTIFICATRICE :
   * Tous nos boutons ont la classe 'agile-board-switch-button'
   * pour un nettoyage facile et sÃ»r.
   */
  removeSwitchButtons() {
    const buttons = document.querySelectorAll(".agile-board-switch-button");
    buttons.forEach((button) => button.remove());
  }
  // ===========================================================================
  // MÃ‰THODES DE CYCLE DE VIE
  // ===========================================================================
  /**
   * Nettoie les ressources utilisÃ©es par le ViewSwitcher
   * 
   * APPELÃ‰E PAR :
   * Le plugin principal lors de son dÃ©chargement (onunload).
   * 
   * NETTOYAGE :
   * - Supprime tous les boutons de l'interface
   * - Les Ã©couteurs d'Ã©vÃ©nements sont automatiquement nettoyÃ©s par Obsidian
   *   grÃ¢ce Ã  registerEvent() utilisÃ© dans addSwitchButton()
   * 
   * IMPORTANCE :
   * Ã‰vite les fuites mÃ©moire et les boutons orphelins dans l'interface.
   */
  stop() {
    this.removeSwitchButtons();
  }
};

// src/managers/ModelDetector.ts
var ModelDetector = class {
  /**
   * CONSTRUCTEUR avec injection de dÃ©pendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * DÃ‰PENDANCES UTILISÃ‰ES :
   * - plugin.app : Pour accÃ©der aux APIs Obsidian
   * - plugin.layoutService : Pour valider les layouts
   * - plugin.viewSwitcher : Pour mettre Ã  jour l'interface
   * - plugin.registerEvent : Pour l'abonnement sÃ©curisÃ© aux Ã©vÃ©nements
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Cache des fichiers dÃ©jÃ  traitÃ©s
     * 
     * STRUCTURE DE DONNÃ‰ES :
     * Set<string> pour un accÃ¨s O(1) et Ã©viter les doublons.
     * 
     * CLÃ‰ DE CACHE :
     * "chemin-du-fichier-timestamp" pour invalidation automatique
     * quand le fichier est modifiÃ©.
     * 
     * AVANTAGES :
     * - Ã‰vite les retraitements inutiles
     * - Performance optimisÃ©e pour les gros vaults
     * - Invalidation automatique lors des modifications
     */
    this.processedFiles = /* @__PURE__ */ new Set();
  }
  // ===========================================================================
  // MÃ‰THODES DE CYCLE DE VIE
  // ===========================================================================
  /**
   * Initialise la surveillance des Ã©vÃ©nements Obsidian
   * 
   * Ã‰VÃ‰NEMENTS SURVEILLÃ‰S :
   * 1. metadataCache.on('changed') : Modification des mÃ©tadonnÃ©es
   * 2. workspace.on('file-open') : Ouverture de fichier
   * 3. workspace.on('active-leaf-change') : Changement d'onglet actif
   * 
   * DÃ‰LAIS D'INITIALISATION :
   * DÃ©lai de 1 seconde pour laisser Obsidian finir son initialisation
   * avant de traiter les fichiers dÃ©jÃ  ouverts.
   * 
   * PATTERN REGISTER-EVENT :
   * Utilise plugin.registerEvent() pour un nettoyage automatique
   * des Ã©couteurs lors du dÃ©chargement du plugin.
   * 
   * @example
   * modelDetector.onLoad();
   * // Ã€ partir de maintenant, les changements sont dÃ©tectÃ©s automatiquement
   */
  onLoad() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        this.handleMetadataChanged(file);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          if (activeFile) {
            this.handleFileOpen(activeFile);
          }
        }, 100);
      })
    );
    setTimeout(() => {
      this.processAllOpenFiles();
    }, 1e3);
  }
  /**
   * Nettoie les ressources utilisÃ©es par le dÃ©tecteur
   * 
   * APPELÃ‰E PAR :
   * Le plugin principal lors de son dÃ©chargement (onunload).
   * 
   * NETTOYAGE :
   * - Vide le cache des fichiers traitÃ©s
   * - Les Ã©couteurs d'Ã©vÃ©nements sont automatiquement nettoyÃ©s par Obsidian
   * 
   * IMPORTANCE :
   * Ã‰vite les fuites mÃ©moire et prÃ©pare un rechargement propre du plugin.
   */
  onUnload() {
    this.processedFiles.clear();
  }
  // ===========================================================================
  // GESTIONNAIRES D'Ã‰VÃ‰NEMENTS PRIVÃ‰S
  // ===========================================================================
  /**
   * GÃ¨re les changements de mÃ©tadonnÃ©es d'un fichier
   * 
   * DÃ‰CLENCHEMENT :
   * Quand l'utilisateur modifie le frontmatter d'un fichier.
   * Par exemple, ajouter ou changer "agile-board: layout_kanban".
   * 
   * LOGIQUE :
   * Les mÃ©tadonnÃ©es changÃ©es peuvent affecter l'affichage des boutons,
   * donc on relance le traitement du fichier.
   * 
   * @param file - Fichier dont les mÃ©tadonnÃ©es ont changÃ©
   * 
   * @example
   * // L'utilisateur ajoute dans le frontmatter :
   * // agile-board: layout_eisenhower
   * // â†’ handleMetadataChanged() est appelÃ©e
   * // â†’ Les boutons de basculement apparaissent
   */
  handleMetadataChanged(file) {
    console.log("\u{1F4DD} M\xE9tadonn\xE9es chang\xE9es pour:", file.basename);
    this.processFile(file);
  }
  /**
   * GÃ¨re l'ouverture d'un fichier
   * 
   * DÃ‰CLENCHEMENT :
   * - Ouverture d'un nouveau fichier
   * - Basculement vers un onglet existant
   * - Navigation par liens internes
   * 
   * @param file - Fichier qui vient d'Ãªtre ouvert/activÃ©
   */
  handleFileOpen(file) {
    console.log("\u{1F4C2} Fichier ouvert:", file.basename);
    this.processFile(file);
  }
  /**
   * Traite tous les fichiers dÃ©jÃ  ouverts au dÃ©marrage
   * 
   * UTILISATION :
   * AppelÃ©e une fois lors de l'initialisation pour traiter les fichiers
   * qui Ã©taient dÃ©jÃ  ouverts avant l'activation du plugin.
   * 
   * MÃ‰THODE OBSIDIAN :
   * iterateAllLeaves() parcourt tous les onglets ouverts dans l'espace de travail.
   * 
   * FILTRAGE :
   * Seuls les onglets avec vue markdown et fichier valide sont traitÃ©s.
   * 
   * @example
   * // Au dÃ©marrage d'Obsidian avec 3 fichiers ouverts :
   * // processAllOpenFiles() va traiter les 3 fichiers
   * // et afficher les boutons appropriÃ©s
   */
  processAllOpenFiles() {
    console.log("\u{1F50D} Traitement initial de tous les fichiers ouverts...");
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === "markdown" && view.file) {
        this.processFile(view.file);
      }
    });
  }
  // ===========================================================================
  // LOGIQUE MÃ‰TIER PRINCIPALE
  // ===========================================================================
  /**
   * Traite un fichier individuel et met Ã  jour l'interface si nÃ©cessaire
   * 
   * ALGORITHME :
   * 1. Filtrer les fichiers non-markdown
   * 2. GÃ©nÃ©rer une clÃ© de cache unique
   * 3. VÃ©rifier si dÃ©jÃ  traitÃ© (cache hit)
   * 4. DÃ©tecter si le fichier a un layout agile-board
   * 5. Mettre Ã  jour l'interface via ViewSwitcher
   * 6. Nettoyer le cache si nÃ©cessaire
   * 
   * OPTIMISATION DE CACHE :
   * La clÃ© inclut le timestamp de modification (mtime) pour invalider
   * automatiquement le cache quand le fichier change.
   * 
   * @param file - Fichier Ã  traiter
   * 
   * @example
   * // PremiÃ¨re fois : traitement complet
   * processFile(myFile); // Cache miss â†’ traitement
   * 
   * // DeuxiÃ¨me fois (fichier inchangÃ©) : cache hit
   * processFile(myFile); // Cache hit â†’ pas de traitement
   * 
   * // AprÃ¨s modification du fichier : cache invalidÃ©
   * processFile(myFile); // Cache miss â†’ traitement
   */
  processFile(file) {
    if (!file.path.endsWith(".md"))
      return;
    const fileKey = `${file.path}-${file.stat.mtime}`;
    if (this.processedFiles.has(fileKey))
      return;
    this.processedFiles.add(fileKey);
    this.cleanupProcessedFiles();
    const hasLayout = this.hasAgileBoardLayout(file);
    console.log(`\u{1F3AF} Fichier "${file.basename}" - Layout agile-board: ${hasLayout ? "OUI" : "NON"}`);
    setTimeout(() => {
      this.plugin.viewSwitcher.updateSwitchButtonForFile(file);
    }, 50);
  }
  /**
   * VÃ©rifie si un fichier a un layout agile-board valide
   * 
   * VALIDATION EN DEUX Ã‰TAPES :
   * 1. VÃ©rifier la prÃ©sence du champ 'agile-board' dans le frontmatter
   * 2. VÃ©rifier que le layout existe dans le LayoutService
   * 
   * GESTION D'ERREURS :
   * Si un layout est spÃ©cifiÃ© mais n'existe pas, log un warning
   * mais retourne false (traitement gracieux).
   * 
   * @param file - Fichier Ã  vÃ©rifier
   * @returns boolean - true si le fichier a un layout valide
   * 
   * @example
   * // Fichier avec frontmatter valide :
   * // ---
   * // agile-board: layout_eisenhower
   * // ---
   * hasAgileBoardLayout(file); // true
   * 
   * // Fichier avec layout inexistant :
   * // ---
   * // agile-board: layout_inexistant
   * // ---
   * hasAgileBoardLayout(file); // false + warning
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return false;
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.warn(`\u26A0\uFE0F Layout "${layoutName}" sp\xE9cifi\xE9 mais non trouv\xE9`);
      return false;
    }
    return true;
  }
  // ===========================================================================
  // GESTION DU CACHE ET OPTIMISATIONS
  // ===========================================================================
  /**
   * Nettoie le cache pour Ã©viter une croissance excessive
   * 
   * STRATÃ‰GIE DE NETTOYAGE :
   * - Limite : 100 entrÃ©es maximum dans le cache
   * - MÃ©thode : Garder les 50 entrÃ©es les plus rÃ©centes
   * - DÃ©clenchement : Ã€ chaque ajout dans le cache
   * 
   * POURQUOI NETTOYER :
   * - Ã‰viter la fuite mÃ©moire avec de gros vaults
   * - Maintenir des performances optimales
   * - Les anciennes entrÃ©es sont probablement obsolÃ¨tes
   * 
   * ALGORITHME LRU SIMPLE :
   * Les entrÃ©es sont dans l'ordre d'insertion dans le Set.
   * On garde les derniÃ¨res ajoutÃ©es (= les plus rÃ©cemment utilisÃ©es).
   * 
   * @example
   * // Cache avec 100+ entrÃ©es
   * cleanupProcessedFiles();
   * // â†’ Cache rÃ©duit Ã  50 entrÃ©es les plus rÃ©centes
   */
  cleanupProcessedFiles() {
    if (this.processedFiles.size > 100) {
      const entries = Array.from(this.processedFiles);
      const toKeep = entries.slice(-50);
      this.processedFiles.clear();
      toKeep.forEach((entry) => this.processedFiles.add(entry));
      console.log("\u{1F9F9} Cache nettoy\xE9: gard\xE9 50 entr\xE9es sur", entries.length);
    }
  }
  // ===========================================================================
  // MÃ‰THODES UTILITAIRES PUBLIQUES
  // ===========================================================================
  /**
   * Force une mise Ã  jour complÃ¨te de tous les fichiers ouverts
   * 
   * UTILISATION :
   * - Commande de dÃ©bogage
   * - AprÃ¨s rechargement de layouts
   * - RÃ©cupÃ©ration d'Ã©tat incohÃ©rent
   * 
   * PROCESSUS :
   * 1. Vider complÃ¨tement le cache
   * 2. Retraiter tous les fichiers ouverts
   * 3. Mettre Ã  jour toute l'interface
   * 
   * PERFORMANCE :
   * OpÃ©ration coÃ»teuse, Ã  utiliser avec parcimonie.
   * 
   * @example
   * // L'utilisateur utilise la commande "Force Update Board Buttons"
   * modelDetector.forceUpdate();
   * // â†’ Tous les boutons sont recalculÃ©s et mis Ã  jour
   */
  forceUpdate() {
    this.processedFiles.clear();
    this.processAllOpenFiles();
    console.log("\u{1F504} Mise \xE0 jour forc\xE9e termin\xE9e");
  }
};

// src/main.ts
var AgileBoardPlugin = class extends import_obsidian7.Plugin {
  /**
   * Initialisation du plugin - appelÃ©e au chargement d'Obsidian
   */
  async onload() {
    await this.loadSettings();
    this.logger = new LoggerService(this, this.settings.debug);
    this.logger.startup("Plugin Agile-Board v0.7.0 en cours d'initialisation", {
      debugEnabled: this.settings.debug.enabled,
      logLevel: this.settings.debug.logLevel,
      autoCreateSections: this.settings.autoCreateSections
    });
    await this.initializeServices();
    this.registerViews();
    this.registerCommands();
    this.addSettingTab(new AgileBoardSettingsTab(this.app, this));
    this.logger.config("Onglet de configuration enregistr\xE9");
    this.setupPeriodicLogSaving();
    this.setupEventListeners();
    this.logger.success("Plugin Agile-Board initialis\xE9 avec succ\xE8s", {
      version: "0.7.0",
      loadTime: performance.now(),
      services: this.getLoadedServices()
    });
  }
  /**
   * ArrÃªt du plugin - appelÃ©e Ã  la fermeture d'Obsidian
   */
  async onunload() {
    this.logger.info("Arr\xEAt du plugin Agile-Board en cours");
    if (this.modelDetector) {
      this.modelDetector.onUnload();
    }
    if (this.settings.debug.logToFile) {
      this.logger.info("Sauvegarde finale des logs avant arr\xEAt");
      await this.logger.saveLogsToFile();
    }
    this.cleanupResources();
    this.logger.success("Plugin Agile-Board arr\xEAt\xE9 proprement");
  }
  // ====================================================================
  // GESTION DE LA CONFIGURATION
  // ====================================================================
  /**
   * Charge la configuration depuis le stockage d'Obsidian
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings = this.validateSettings(this.settings);
  }
  /**
   * Sauvegarde la configuration dans le stockage d'Obsidian
   */
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.logger) {
      this.logger.updateSettings(this.settings.debug);
      this.logger.config("Configuration sauvegard\xE9e et logger mis \xE0 jour");
    }
  }
  /**
   * Valide et corrige la configuration si nÃ©cessaire
   */
  validateSettings(settings) {
    if (!settings.debug) {
      settings.debug = DEFAULT_SETTINGS.debug;
    }
    if (!Array.isArray(settings.defaultLayouts) || settings.defaultLayouts.length === 0) {
      settings.defaultLayouts = DEFAULT_SETTINGS.defaultLayouts;
    }
    return settings;
  }
  // ====================================================================
  // INITIALISATION DES SERVICES
  // ====================================================================
  /**
   * Initialise tous les services du plugin
   */
  async initializeServices() {
    this.logger.debug("Initialisation des services en cours");
    try {
      this.layoutService = new LayoutService(this);
      this.fileService = new FileService(this.app);
      this.layoutService.load();
      this.noteCreator = new NoteCreatorService(
        this.app,
        this.layoutService,
        this.logger
      );
      this.boardViewService = new BoardViewService(
        this.app,
        this.layoutService,
        this.logger
      );
      this.sectionManager = new SectionManagerService(
        this.app,
        this.layoutService,
        this.logger
      );
      this.viewSwitcher = new ViewSwitcher(this);
      this.modelDetector = new ModelDetector(this);
      this.modelDetector.onLoad();
      this.logger.success("Tous les services initialis\xE9s", {
        layoutsCount: this.layoutService.getAllModelNames().length,
        noteCreatorReady: !!this.noteCreator,
        boardViewServiceReady: !!this.boardViewService,
        sectionManagerReady: !!this.sectionManager,
        viewSwitcherReady: !!this.viewSwitcher,
        modelDetectorReady: !!this.modelDetector
      });
      this.logger.debug("Tous les services ont \xE9t\xE9 initialis\xE9s avec succ\xE8s");
    } catch (error) {
      this.logger.error("Erreur lors de l'initialisation des services", error);
      throw error;
    }
  }
  /**
   * Enregistre les vues personnalisÃ©es
   */
  registerViews() {
    this.logger.debug("Enregistrement des vues personnalis\xE9es");
    try {
      this.registerView("agile-board-view", (leaf) => new BoardView(leaf, this));
      this.logger.success("Vue BoardView enregistr\xE9e");
    } catch (error) {
      this.logger.error("Erreur lors de l'enregistrement des vues", error);
    }
  }
  /**
   * Enregistre toutes les commandes du plugin
   */
  registerCommands() {
    this.logger.debug("Enregistrement des commandes");
    this.addCommand({
      id: "create-eisenhower-note",
      name: "Cr\xE9er une note Matrice d'Eisenhower",
      callback: () => this.createNoteWithLayout("layout_eisenhower")
    });
    this.addCommand({
      id: "create-kanban-note",
      name: "Cr\xE9er une note Kanban",
      callback: () => this.createNoteWithLayout("layout_kanban")
    });
    this.addCommand({
      id: "create-gtd-note",
      name: "Cr\xE9er une note GTD",
      callback: () => this.createNoteWithLayout("layout_gtd")
    });
    this.addCommand({
      id: "create-weekly-note",
      name: "Cr\xE9er un planificateur hebdomadaire",
      callback: () => this.createNoteWithLayout("layout_weekly")
    });
    this.addCommand({
      id: "create-daily-note",
      name: "Cr\xE9er un planificateur quotidien",
      callback: () => this.createNoteWithLayout("layout_daily")
    });
    this.addCommand({
      id: "create-project-note",
      name: "Cr\xE9er un tableau de projet",
      callback: () => this.createNoteWithLayout("layout_project")
    });
    this.addCommand({
      id: "switch-to-board-view",
      name: "Basculer vers la vue board",
      callback: () => this.switchToBoardView()
    });
    this.addCommand({
      id: "list-layouts",
      name: "Afficher les layouts disponibles",
      callback: () => this.listAvailableLayouts()
    });
    this.addCommand({
      id: "create-missing-sections",
      name: "Cr\xE9er les sections manquantes",
      callback: () => this.createMissingSections()
    });
    this.addCommand({
      id: "debug-button-state",
      name: "\u{1F50D} Debug \xC9tat des Boutons",
      callback: () => {
        var _a, _b;
        const activeFile = this.app.workspace.getActiveFile();
        const activeLeaf = this.app.workspace.activeLeaf;
        if (activeFile && activeLeaf) {
          const debugInfo = {
            fileName: activeFile.name,
            currentViewType: activeLeaf.view.getViewType(),
            hasAgileBoardLayout: !!((_b = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b["agile-board"]),
            services: {
              viewSwitcher: !!this.viewSwitcher,
              boardViewService: !!this.boardViewService,
              modelDetector: !!this.modelDetector
            }
          };
          console.log("\u{1F50D} \xC9tat actuel:", debugInfo);
          this.logger.debug("Debug \xE9tat boutons", debugInfo);
          if (this.viewSwitcher) {
            console.log("\u{1F504} Mise \xE0 jour ViewSwitcher...");
            this.viewSwitcher.updateSwitchButtonForFile(activeFile);
          }
          if (this.modelDetector) {
            console.log("\u{1F504} Force update ModelDetector...");
            this.modelDetector.forceUpdate();
          }
          new import_obsidian8.Notice(`\u{1F50D} Debug: ${debugInfo.currentViewType} | Check console F12`, 4e3);
        }
      }
    });
    this.addCommand({
      id: "force-update-buttons",
      name: "\u{1F504} Forcer mise \xE0 jour des boutons",
      callback: () => this.forceUpdateButtons()
    });
    this.addCommand({
      id: "toggle-debug",
      name: "Activer/D\xE9sactiver le debug",
      callback: () => this.toggleDebug()
    });
    this.addCommand({
      id: "test-debug-system",
      name: "Tester le syst\xE8me de debug",
      callback: () => this.testDebugSystem()
    });
    this.addCommand({
      id: "save-logs-now",
      name: "Sauvegarder les logs maintenant",
      callback: () => this.saveLogsNow()
    });
    this.logger.success("Toutes les commandes ont \xE9t\xE9 enregistr\xE9es");
  }
  // ====================================================================
  // CONFIGURATION AUTOMATIQUE
  // ====================================================================
  /**
   * Configure la sauvegarde pÃ©riodique des logs
   */
  setupPeriodicLogSaving() {
    if (!this.settings.debug.logToFile) {
      return;
    }
    this.registerInterval(
      window.setInterval(async () => {
        if (this.settings.debug.logToFile) {
          this.logger.verbose("Sauvegarde p\xE9riodique des logs", {
            timestamp: new Date().toISOString()
          });
          await this.logger.saveLogsToFile();
        }
      }, 5 * 60 * 1e3)
      // 5 minutes
    );
    this.logger.config("Sauvegarde p\xE9riodique des logs configur\xE9e (5 min)");
  }
  /**
   * Configure les Ã©couteurs d'Ã©vÃ©nements
   */
  setupEventListeners() {
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file) {
          this.logger.navigation("Fichier ouvert", {
            fileName: file.name,
            path: file.path
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.logger.navigation("Layout workspace modifi\xE9");
      })
    );
    this.logger.config("\xC9couteurs d'\xE9v\xE9nements configur\xE9s");
  }
  // ====================================================================
  // IMPLÃ‰MENTATION DES COMMANDES
  // ====================================================================
  /**
  * CrÃ©e une note avec un layout spÃ©cifique
  */
  async createNoteWithLayout(layoutName) {
    this.logger.fileOperation("Cr\xE9ation de note demand\xE9e", { layoutName });
    try {
      if (!this.noteCreator) {
        throw new Error("NoteCreatorService non initialis\xE9");
      }
      const result = await this.noteCreator.createNoteWithLayout({
        layoutName,
        autoOpen: true
      });
      this.logger.success("Note cr\xE9\xE9e via NoteCreatorService", {
        fileName: result.file.name,
        filePath: result.file.path,
        sectionsCount: result.sectionsCount,
        layoutUsed: result.layoutName
      });
    } catch (error) {
      this.logger.error("Erreur lors de la cr\xE9ation de note", {
        message: error.message,
        stack: error.stack,
        name: error.name,
        layoutName
      }, "main.ts");
      console.error("D\xE9tail erreur createNoteWithLayout:", error);
    }
  }
  /**
  * CrÃ©e une note avec des options avancÃ©es
  */
  async createAdvancedNote(layoutName, options) {
    if (!this.noteCreator) {
      new import_obsidian8.Notice("\u274C Service de cr\xE9ation non disponible");
      return;
    }
    try {
      await this.noteCreator.createNoteWithLayout({
        layoutName,
        customFileName: options == null ? void 0 : options.fileName,
        folder: options == null ? void 0 : options.folder,
        customContent: options == null ? void 0 : options.customContent,
        autoOpen: true
      });
    } catch (error) {
      this.logger.error("Erreur cr\xE9ation note avanc\xE9e", error);
    }
  }
  /**
   * MÃ©thode pour obtenir les layouts disponibles (pour l'interface)
   */
  getAvailableLayoutsForUI() {
    var _a;
    return ((_a = this.noteCreator) == null ? void 0 : _a.getAvailableLayouts()) || [];
  }
  /**
   * Bascule vers la vue board pour le fichier actuel
   */
  async switchToBoardView() {
    this.logger.navigation("Basculement vers vue board demand\xE9");
    try {
      if (!this.boardViewService) {
        throw new Error("BoardViewService non initialis\xE9");
      }
      const result = await this.boardViewService.switchToBoardView({
        forceSwitch: false,
        newTab: false
      });
      if (result.success) {
        this.logger.success("Basculement r\xE9ussi via BoardViewService", {
          fileName: result.file.name,
          layoutName: result.layoutName,
          message: result.message
        });
        setTimeout(() => {
          if (this.viewSwitcher && result.file) {
            this.logger.debug("Mise \xE0 jour ViewSwitcher apr\xE8s basculement board");
            this.viewSwitcher.updateSwitchButtonForFile(result.file);
          }
        }, 500);
      } else {
        this.logger.warn("Basculement \xE9chou\xE9", {
          fileName: result.file.name,
          message: result.message
        });
      }
    } catch (error) {
      this.logger.error("Erreur lors du basculement vers vue board", error, "main.ts");
    }
  }
  /**
   * Bascule vers la vue markdown
   */
  async switchToMarkdownView() {
    this.logger.navigation("Basculement vers vue markdown demand\xE9");
    try {
      if (!this.boardViewService) {
        throw new Error("BoardViewService non initialis\xE9");
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian8.Notice("\u274C Aucun fichier actif");
        return;
      }
      const success = await this.boardViewService.switchToMarkdownView(activeFile);
      if (success) {
        this.logger.success("Basculement vers markdown r\xE9ussi", {
          fileName: activeFile.name
        });
        setTimeout(() => {
          if (this.viewSwitcher) {
            this.logger.debug("Mise \xE0 jour ViewSwitcher apr\xE8s basculement markdown");
            this.viewSwitcher.updateSwitchButtonForFile(activeFile);
          }
        }, 500);
      } else {
        this.logger.warn("Basculement vers markdown \xE9chou\xE9");
      }
    } catch (error) {
      this.logger.error("Erreur basculement vers markdown", error);
    }
  }
  /**
   * Force la mise Ã  jour des boutons
   */
  forceUpdateButtons() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && this.viewSwitcher) {
        this.logger.debug("Mise \xE0 jour forc\xE9e des boutons", { fileName: activeFile.name });
        this.viewSwitcher.updateSwitchButtonForFile(activeFile);
        new import_obsidian8.Notice("\u{1F504} Boutons mis \xE0 jour", 2e3);
      } else {
        new import_obsidian8.Notice("\u274C Aucun fichier actif ou ViewSwitcher indisponible", 3e3);
      }
    } catch (error) {
      this.logger.error("Erreur mise \xE0 jour boutons", error);
      new import_obsidian8.Notice(`\u274C Erreur: ${error.message}`, 3e3);
    }
  }
  /**
   * =============================================================================
   * AMÃ‰LIORATION DE listAvailableLayouts()
   * =============================================================================
   */
  /**
   * Affiche la liste dÃ©taillÃ©e des layouts disponibles
   * 
   * Version amÃ©liorÃ©e qui :
   * - Affiche les informations dans la console ET dans une notification
   * - Groupe les layouts par catÃ©gorie
   * - Montre des dÃ©tails utiles pour l'utilisateur
   * - Propose des actions supplÃ©mentaires
   */
  listAvailableLayouts() {
    this.logger.navigation("Liste des layouts demand\xE9e");
    try {
      if (!this.layoutService) {
        throw new Error("LayoutService non initialis\xE9");
      }
      const allLayouts = this.layoutService.getAllModelsInfo();
      if (allLayouts.length === 0) {
        const message = "Aucun layout disponible";
        this.logger.warn(message);
        new import_obsidian8.Notice(`\u26A0\uFE0F ${message}`, 3e3);
        return;
      }
      const layoutsByCategory = this.groupLayoutsByCategory(allLayouts);
      this.logDetailedLayoutInfo(allLayouts, layoutsByCategory);
      this.showLayoutSummaryToUser(allLayouts, layoutsByCategory);
      this.offerToCreateLayoutGuide(allLayouts);
    } catch (error) {
      this.logger.error("Erreur lors de l'affichage des layouts", error);
      new import_obsidian8.Notice(`\u274C Erreur: ${error.message}`, 4e3);
    }
  }
  /**
   * Groupe les layouts par catÃ©gorie
   */
  groupLayoutsByCategory(layouts) {
    const grouped = {};
    for (const layout of layouts) {
      const category = layout.category || "custom";
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(layout);
    }
    return grouped;
  }
  /**
   * Affiche les informations dÃ©taillÃ©es dans les logs
   */
  logDetailedLayoutInfo(allLayouts, layoutsByCategory) {
    this.logger.info("Layouts disponibles - R\xE9sum\xE9", {
      totalLayouts: allLayouts.length,
      categories: Object.keys(layoutsByCategory),
      layoutNames: allLayouts.map((l) => l.name)
    });
    for (const [category, layouts] of Object.entries(layoutsByCategory)) {
      this.logger.info(`Layouts - Cat\xE9gorie: ${category}`, {
        category,
        count: layouts.length,
        layouts: layouts.map((layout) => ({
          name: layout.name,
          displayName: layout.displayName,
          description: layout.description,
          sectionsCount: layout.sections.length,
          sections: layout.sections
        }))
      });
    }
  }
  /**
   * Affiche un rÃ©sumÃ© Ã  l'utilisateur
   */
  showLayoutSummaryToUser(allLayouts, layoutsByCategory) {
    const categoryTexts = Object.entries(layoutsByCategory).map(([category, layouts]) => {
      const categoryName = this.getCategoryDisplayName(category);
      const layoutNames = layouts.map((l) => l.displayName).join(", ");
      return `\u{1F4C2} **${categoryName}** (${layouts.length}) : ${layoutNames}`;
    });
    const summaryText = [
      `\u{1F4CB} **${allLayouts.length} layouts disponibles**`,
      "",
      ...categoryTexts,
      "",
      "\u{1F50D} Voir console (F12) pour d\xE9tails complets"
    ].join("\n");
    new import_obsidian8.Notice(summaryText, 8e3);
    console.group("\u{1F3AF} LAYOUTS AGILE BOARD DISPONIBLES");
    console.log(`Total: ${allLayouts.length} layouts`);
    for (const [category, layouts] of Object.entries(layoutsByCategory)) {
      console.group(`\u{1F4C2} ${this.getCategoryDisplayName(category)} (${layouts.length})`);
      for (const layout of layouts) {
        console.log(`\u{1F4CB} ${layout.displayName} (${layout.name})`);
        console.log(`   Description: ${layout.description}`);
        console.log(`   Sections (${layout.sections.length}): ${layout.sections.join(", ")}`);
        console.log("");
      }
      console.groupEnd();
    }
    console.groupEnd();
  }
  /**
   * Nom d'affichage convivial pour les catÃ©gories
   */
  getCategoryDisplayName(category) {
    const categoryNames = {
      "productivity": "\u{1F3AF} Productivit\xE9",
      "planning": "\u{1F4C5} Planification",
      "project": "\u{1F680} Projets",
      "personal": "\u{1F464} Personnel",
      "custom": "\u{1F527} Personnalis\xE9"
    };
    return categoryNames[category] || `\u{1F4C1} ${category}`;
  }
  /**
   * Propose de crÃ©er une note guide avec tous les layouts
   */
  offerToCreateLayoutGuide(allLayouts) {
    this.logger.debug("Option guide layouts disponible", {
      layoutsCount: allLayouts.length,
      suggestion: "Possibilit\xE9 de cr\xE9er une note guide avec tous les layouts"
    });
  }
  /**
   * CrÃ©e une note guide avec tous les layouts (fonction bonus)
   */
  async createLayoutGuideNote(allLayouts) {
    try {
      if (!this.noteCreator) {
        return;
      }
      const guideContent = this.generateLayoutGuideContent(allLayouts);
      const fileName = `Guide Layouts Agile Board ${new Date().toISOString().split("T")[0]}.md`;
      await this.app.vault.create(fileName, guideContent);
      this.logger.success("Guide des layouts cr\xE9\xE9", { fileName });
      new import_obsidian8.Notice(`\u{1F4D6} Guide cr\xE9\xE9: ${fileName}`, 4e3);
    } catch (error) {
      this.logger.error("Erreur cr\xE9ation guide layouts", error);
    }
  }
  /**
   * GÃ©nÃ¨re le contenu du guide des layouts
   */
  generateLayoutGuideContent(allLayouts) {
    const today = new Date().toISOString().split("T")[0];
    const sections = [
      "---",
      "type: guide",
      `created: ${today}`,
      "tags: [agile-board, layouts, guide]",
      "---",
      "",
      "# \u{1F4CB} Guide des Layouts Agile Board",
      "",
      `> Guide complet des ${allLayouts.length} layouts disponibles`,
      `> G\xE9n\xE9r\xE9 automatiquement le ${today}`,
      "",
      "## \u{1F3AF} R\xE9sum\xE9",
      "",
      `- **Total layouts** : ${allLayouts.length}`,
      `- **Plugin** : Agile Board v0.7.0`,
      `- **Utilisation** : Commandes de cr\xE9ation de notes`,
      "",
      "## \u{1F4DA} Layouts disponibles",
      ""
    ];
    const layoutsByCategory = this.groupLayoutsByCategory(allLayouts);
    for (const [category, layouts] of Object.entries(layoutsByCategory)) {
      sections.push(`### ${this.getCategoryDisplayName(category)}`);
      sections.push("");
      for (const layout of layouts) {
        sections.push(`#### \u{1F4CB} ${layout.displayName}`);
        sections.push("");
        sections.push(`- **Nom technique** : \`${layout.name}\``);
        sections.push(`- **Description** : ${layout.description}`);
        sections.push(`- **Sections** (${layout.sections.length}) : ${layout.sections.join(", ")}`);
        sections.push("");
        sections.push("**Utilisation :**");
        sections.push(`\`\`\`markdown`);
        sections.push(`---`);
        sections.push(`agile-board: ${layout.name}`);
        sections.push(`---`);
        sections.push(`\`\`\``);
        sections.push("");
      }
    }
    sections.push("---");
    sections.push("");
    sections.push("## \u{1F4D6} Comment utiliser");
    sections.push("");
    sections.push('1. **Cr\xE9er une note** : Utilisez les commandes "Cr\xE9er une note [Type]"');
    sections.push("2. **Ajouter un layout** : Ajoutez `agile-board: layout_name` dans le frontmatter");
    sections.push('3. **Basculer en vue board** : Commande "Basculer vers la vue board"');
    sections.push('4. **Compl\xE9ter les sections** : Commande "Cr\xE9er les sections manquantes"');
    sections.push("");
    sections.push("> \u{1F4A1} **Astuce** : Tous les layouts sont personnalisables selon vos besoins !");
    return sections.join("\n");
  }
  /**
   * CrÃ©e les sections manquantes pour le fichier actuel
   */
  async createMissingSections() {
    this.logger.fileOperation("Cr\xE9ation des sections manquantes demand\xE9e");
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        this.logger.warn("Aucun fichier actif pour cr\xE9er les sections");
        new import_obsidian8.Notice("\u274C Aucun fichier actif");
        return;
      }
      if (!this.sectionManager) {
        throw new Error("SectionManagerService non initialis\xE9");
      }
      const result = await this.sectionManager.createMissingSections(activeFile, {
        insertPosition: "layout-order",
        addDefaultContent: true,
        autoSave: true
      });
      if (result.success) {
        this.logger.success("Sections cr\xE9\xE9es via SectionManagerService", {
          fileName: activeFile.name,
          sectionsAdded: result.sectionsAdded,
          addedSections: result.addedSectionNames
        });
      } else {
        this.logger.warn("Cr\xE9ation de sections \xE9chou\xE9e", {
          fileName: activeFile.name,
          messages: result.messages
        });
      }
    } catch (error) {
      this.logger.error("Erreur lors de la cr\xE9ation des sections", error);
      new import_obsidian8.Notice(`\u274C Erreur: ${error.message}`, 4e3);
    }
  }
  // ====================================================================
  // COMMANDES DE DEBUG (NOUVELLES v0.7.0)
  // ====================================================================
  /**
   * Active/dÃ©sactive le debug via commande
   */
  async toggleDebug() {
    const wasEnabled = this.settings.debug.enabled;
    this.settings.debug.enabled = !wasEnabled;
    await this.saveSettings();
    const status = this.settings.debug.enabled ? "activ\xE9" : "d\xE9sactiv\xE9";
    const icon = this.settings.debug.enabled ? "\u2705" : "\u274C";
    this.logger.config(`Debug ${status} via commande`);
    new import_obsidian8.Notice(`${icon} Debug ${status}`, 3e3);
  }
  /**
   * Lance un test complet du systÃ¨me de debug
   */
  testDebugSystem() {
    this.logger.info("Test du syst\xE8me de debug lanc\xE9 via commande");
    this.logger.testSystem();
    new import_obsidian8.Notice("\u{1F9EA} Test de debug ex\xE9cut\xE9 - v\xE9rifiez la console (F12)", 4e3);
  }
  /**
   * Force la sauvegarde immÃ©diate des logs
   */
  async saveLogsNow() {
    if (!this.settings.debug.logToFile) {
      new import_obsidian8.Notice("\u26A0\uFE0F Sauvegarde fichier d\xE9sactiv\xE9e", 3e3);
      return;
    }
    this.logger.info("Sauvegarde manuelle des logs demand\xE9e");
    await this.logger.saveLogsToFile();
    new import_obsidian8.Notice("\u{1F4BE} Logs sauvegard\xE9s avec succ\xE8s", 2e3);
  }
  // ====================================================================
  // MÃ‰THODES UTILITAIRES
  // ====================================================================
  /**
   * Nettoie les ressources avant arrÃªt du plugin
   */
  cleanupResources() {
    this.logger.debug("Nettoyage des ressources en cours");
    this.logger.clearBuffer();
    this.logger.debug("Ressources nettoy\xE9es");
  }
  /**
   * Retourne la liste des services chargÃ©s pour les logs
   */
  getLoadedServices() {
    const services = ["LoggerService"];
    if (this.layoutService)
      services.push("LayoutService");
    if (this.fileService)
      services.push("FileService");
    if (this.viewSwitcher)
      services.push("ViewSwitcher");
    if (this.modelDetector)
      services.push("ModelDetector");
    if (this.noteCreator)
      services.push("NoteCreatorService");
    return services;
  }
  // ====================================================================
  // MÃ‰THODES D'ACCÃˆS POUR LES AUTRES COMPOSANTS
  // ====================================================================
  /**
   * Retourne le service de logging pour utilisation dans d'autres composants
   * @returns Instance du LoggerService
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Retourne la configuration actuelle du plugin
   * @returns Configuration complÃ¨te
   */
  getSettings() {
    return this.settings;
  }
  /**
   * Met Ã  jour une partie de la configuration
   * @param updates Mises Ã  jour partielles
   */
  async updateSettings(updates) {
    this.settings = { ...this.settings, ...updates };
    await this.saveSettings();
    this.logger.config("Configuration mise \xE0 jour via API", updates);
  }
  // ====================================================================
  // GESTION DES ERREURS GLOBALES
  // ====================================================================
  /**
   * Gestionnaire d'erreur global pour le plugin
   * @param error Erreur capturÃ©e
   * @param context Contexte oÃ¹ l'erreur s'est produite
   */
  handleError(error, context) {
    this.logger.error(`Erreur dans ${context}`, {
      message: error.message,
      stack: error.stack,
      context
    });
    new import_obsidian8.Notice(`\u274C Erreur Agile Board: ${error.message}`, 5e3);
  }
  // ====================================================================
  // HOOKS POUR INTÃ‰GRATION AVEC LES SERVICES EXISTANTS
  // ====================================================================
  /**
   * Hook appelÃ© aprÃ¨s l'initialisation complÃ¨te
   * Permet aux services existants de s'initialiser avec le logger
   */
  onInitializationComplete() {
    this.logger.success("Hook d'initialisation compl\xE8te appel\xE9");
  }
  /**
   * Hook appelÃ© lors du changement de configuration debug
   * Permet aux services de rÃ©agir aux changements
   */
  onDebugSettingsChanged() {
    this.logger.config("Configuration debug modifi\xE9e - notification aux services");
  }
};
