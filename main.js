/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgileBoardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/constants/layouts.ts
var BUILT_IN_LAYOUTS = {
  // ===========================================================================
  // SECTION 1 : LAYOUTS DE PRODUCTIVITÉ ET PRIORISATION
  // ===========================================================================
  /**
   * MATRICE D'EISENHOWER - Système de priorisation présidentiel
   * 
   * MÉTHODOLOGIE :
   * Créée par le président Dwight D. Eisenhower, cette matrice classe
   * les tâches selon deux axes orthogonaux : Urgent vs Important.
   * 
   * PHILOSOPHIE :
   * "Ce qui est important est rarement urgent et ce qui est urgent 
   * est rarement important." - Eisenhower
   * 
   * QUADRANTS :
   * 1. Urgent ET Important (Q1) → FAIRE immédiatement
   * 2. Important mais PAS Urgent (Q2) → PLANIFIER (zone optimale)
   * 3. Urgent mais PAS Important (Q3) → DÉLÉGUER
   * 4. NI Urgent NI Important (Q4) → ÉLIMINER
   * 
   * DIAGRAMME VISUEL :
   * ┌─────────────────┬─────────────────┐
   * │ URGENT ET       │ PAS URGENT      │
   * │ IMPORTANT       │ MAIS IMPORTANT  │
   * │ ⚡ DO NOW ⚡    │ 📅 SCHEDULE 📅  │
   * │ (Crises,        │ (Planification, │
   * │  Urgences)      │  Prévention)    │
   * ├─────────────────┼─────────────────┤
   * │ URGENT MAIS     │ NI URGENT       │
   * │ PAS IMPORTANT   │ NI IMPORTANT    │
   * │ 👥 DELEGATE 👥  │ 🗑️ DELETE 🗑️   │
   * │ (Interruptions, │ (Distractions,  │
   * │  Certains mails)│  Réseaux soc.)  │
   * └─────────────────┴─────────────────┘
   * 
   * GRILLE TECHNIQUE : 4 quadrants de 12×12 chacun
   * CAS D'USAGE : Gestion quotidienne, décisions stratégiques, leadership
   */
  layout_eisenhower: [
    {
      title: "Urgent et Important",
      x: 0,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q1 : Actions immédiates, gestion de crise
    },
    {
      title: "Pas urgent mais Important",
      x: 12,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q2 : Zone optimale de productivité, planification
    },
    {
      title: "Urgent mais Pas important",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q3 : Candidats à la délégation
    },
    {
      title: "Ni urgent ni important",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q4 : Activités à éliminer ou réduire
    }
  ],
  /**
   * GETTING THINGS DONE (GTD) - Méthode David Allen
   * 
   * MÉTHODOLOGIE :
   * Système complet de productivité développé par David Allen.
   * Basé sur l'externalisation de la mémoire et la clarification systématique.
   * 
   * PRINCIPE CENTRAL :
   * "Votre esprit est fait pour avoir des idées, pas pour les retenir."
   * 
   * FLUX GTD :
   * CAPTURER → CLARIFIER → ORGANISER → RÉVISER → FAIRE
   * 
   * ZONES FONCTIONNELLES :
   * 1. Inbox : Capture de tout ce qui arrive
   * 2. Actions suivantes : Tâches concrètes et faisables
   * 3. En attente : Délégué ou dépendant d'autres
   * 4. Projets : Résultats nécessitant plusieurs actions
   * 5. Someday/Maybe : Idées pour le futur
   * 6. Référence : Informations à conserver
   * 
   * DIAGRAMME VISUEL :
   * ┌──────────────┬──────────────┐
   * │   📥 INBOX   │ ➡️ ACTIONS   │
   * │              │   SUIVANTES  │
   * │ (Collecte    │ (Prochaines  │
   * │  rapide)     │  tâches)     │
   * ├──────┬───────┼──────┬───────┤
   * │⏳ EN │📋 PROJ│🤔 SM │       │
   * │ATTEN.│   ETS │  /M  │       │
   * ├──────┴───────┴──────┴───────┤
   * │      📚 RÉFÉRENCE           │
   * │   (Documentation,           │
   * │    informations)            │
   * └─────────────────────────────┘
   * 
   * GRILLE TECHNIQUE : Optimisée pour le flux GTD
   * CAS D'USAGE : Productivité personnelle, gestion complète des tâches
   */
  layout_gtd: [
    {
      title: "Inbox",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Zone de capture : tout ce qui arrive sans traitement
    },
    {
      title: "Actions suivantes",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // Tâches clarifiées et prêtes à être exécutées
    },
    {
      title: "En attente",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // Délégué ou en attente de quelqu'un/quelque chose d'autre
    },
    {
      title: "Projets",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // Résultats désirés nécessitant plus d'une action
    },
    {
      title: "Someday Maybe",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // Idées intéressantes pour plus tard
    },
    {
      title: "R\xE9f\xE9rence",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Informations utiles à conserver pour consultation
    }
  ],
  // ===========================================================================
  // SECTION 2 : LAYOUTS DE FLUX DE TRAVAIL (WORKFLOW)
  // ===========================================================================
  /**
   * TABLEAU KANBAN CLASSIQUE - Visualisation du flux de travail
   * 
   * MÉTHODOLOGIE :
   * Originaire du système de production Toyota, adapté au travail intellectuel.
   * Principe : visualiser le travail, limiter le travail en cours (WIP).
   * 
   * PHILOSOPHIE :
   * Flux tiré (pull) plutôt que poussé (push).
   * Optimisation du débit global plutôt que de l'efficacité locale.
   * 
   * COLONNES STANDARD :
   * 1. À faire (Backlog) : Tâches en attente
   * 2. En cours (Doing/WIP) : Travail actuel (limité)
   * 3. Terminé (Done) : Travail complété
   * 
   * DIAGRAMME VISUEL :
   * ┌────────────┬────────────┬────────────┐
   * │            │            │            │
   * │  📋 À      │  ⚙️ EN     │  ✅ TERMI- │
   * │   FAIRE    │   COURS    │    NÉ      │
   * │            │            │            │
   * │ • Tâche A  │ • Tâche X  │ • Tâche 1  │
   * │ • Tâche B  │ • Tâche Y  │ • Tâche 2  │
   * │ • Tâche C  │            │ • Tâche 3  │
   * │ • ...      │ [WIP: 2]   │ • ...      │
   * │            │            │            │
   * └────────────┴────────────┴────────────┘
   * 
   * GRILLE TECHNIQUE : 3 colonnes égales sur toute la hauteur
   * CAS D'USAGE : Développement logiciel, gestion d'équipe, projets itératifs
   */
  layout_kanban: [
    {
      title: "\xC0 faire",
      x: 0,
      y: 0,
      w: 8,
      h: 24
      // Backlog : tâches priorisées en attente
    },
    {
      title: "En cours",
      x: 8,
      y: 0,
      w: 8,
      h: 24
      // Work In Progress : limite recommandée selon l'équipe
    },
    {
      title: "Termin\xE9",
      x: 16,
      y: 0,
      w: 8,
      h: 24
      // Done : validation et archivage des tâches complétées
    }
  ],
  // ===========================================================================
  // SECTION 3 : LAYOUTS DE PLANIFICATION TEMPORELLE
  // ===========================================================================
  /**
   * PLANIFICATEUR HEBDOMADAIRE - Organisation par jour de la semaine
   * 
   * MÉTHODOLOGIE :
   * Planification cyclique basée sur la semaine de travail standard.
   * Équilibre entre productivité professionnelle et bien-être personnel.
   * 
   * PHILOSOPHIE :
   * Rythme hebdomadaire naturel avec distinction travail/repos.
   * Vision d'ensemble pour une planification équilibrée.
   * 
   * ORGANISATION :
   * - 5 jours de travail avec sections dédiées
   * - Weekend groupé pour activités personnelles
   * - Zone de notes pour observations et réflexions
   * 
   * DIAGRAMME VISUEL :
   * ┌─────┬─────┬─────┬─────┐
   * │ LUN │ MAR │ MER │ JEU │
   * │     │     │     │     │
   * │ 📅  │ 📅  │ 📅  │ 📅  │
   * │     │     │     │     │
   * ├─────┼─────┼─────┴─────┤
   * │ VEN │ W-E │   📝      │
   * │     │ 🏖️  │   NOTES   │
   * │ 📅  │     │           │
   * │     │     │           │
   * └─────┴─────┴───────────┘
   * 
   * GRILLE TECHNIQUE : Layout asymétrique optimisé
   * CAS D'USAGE : Planning personnel, coordination d'équipe, revues hebdomadaires
   */
  layout_weekly: [
    {
      title: "Lundi",
      x: 0,
      y: 0,
      w: 6,
      h: 12
      // Démarrage de semaine, objectifs et planification
    },
    {
      title: "Mardi",
      x: 6,
      y: 0,
      w: 6,
      h: 12
      // Productivité optimale, tâches importantes
    },
    {
      title: "Mercredi",
      x: 12,
      y: 0,
      w: 6,
      h: 12
      // Milieu de semaine, ajustements et révisions
    },
    {
      title: "Jeudi",
      x: 18,
      y: 0,
      w: 6,
      h: 12
      // Finalisation des livrables de la semaine
    },
    {
      title: "Vendredi",
      x: 0,
      y: 12,
      w: 8,
      h: 12
      // Clôture, bilans et préparation semaine suivante
    },
    {
      title: "Weekend",
      x: 8,
      y: 12,
      w: 8,
      h: 12
      // Repos, activités personnelles, famille, loisirs
    },
    {
      title: "Notes",
      x: 16,
      y: 12,
      w: 8,
      h: 12
      // Observations, idées, réflexions et apprentissages
    }
  ],
  /**
   * PLANIFICATEUR QUOTIDIEN - Structure détaillée d'une journée
   * 
   * MÉTHODOLOGIE :
   * Organisation méticuleuse d'une journée avec focus sur l'apprentissage
   * et la réflexion. Inspiré des méthodes de développement personnel.
   * 
   * PHILOSOPHIE :
   * Journée intentionnelle avec boucle d'amélioration continue.
   * Équilibre entre action et réflexion.
   * 
   * STRUCTURE :
   * - Objectifs clairs et limités (max 3)
   * - Tâches prioritaires identifiées
   * - Planning temporel structuré
   * - Capture d'apprentissages
   * - Réflexion et bilan de fin de journée
   * 
   * DIAGRAMME VISUEL :
   * ┌─────────────┬─────────────┐
   * │ 🎯 OBJECTIFS│ ⭐ PRIORITÉS │
   * │   DU JOUR   │             │
   * │             │             │
   * ├─────┬───────┼─────┬───────┤
   * │📅PLA│📝 NOT│📚APP│💭 RÉF │
   * │NING │   ES │RENT.│  LEX. │
   * │     │      │     │       │
   * ├─────┴──────┴─────┴───────┤
   * │      💡 RÉFLEXIONS       │
   * │     ET BILAN QUOTIDIEN   │
   * └─────────────────────────┘
   * 
   * GRILLE TECHNIQUE : 6 sections pour journée structurée
   * CAS D'USAGE : Développement personnel, productivité quotidienne
   */
  layout_daily: [
    {
      title: "Objectifs du jour",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Maximum 3 objectifs SMART pour la journée
    },
    {
      title: "T\xE2ches prioritaires",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // Actions importantes qui font avancer les objectifs
    },
    {
      title: "Planning",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // Emploi du temps, rendez-vous, créneaux de travail
    },
    {
      title: "Notes",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // Capture rapide d'idées, observations, informations
    },
    {
      title: "Apprentissages",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // Ce que j'ai appris aujourd'hui (compétences, insights)
    },
    {
      title: "R\xE9flexions",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Bilan de journée, points d'amélioration, gratitude
    }
  ],
  // ===========================================================================
  // SECTION 4 : LAYOUTS DE GESTION DE PROJET
  // ===========================================================================
  /**
   * GESTION DE PROJET COMPLÈTE - Vue d'ensemble projet
   * 
   * MÉTHODOLOGIE :
   * Approche holistique de la gestion de projet intégrant tous les aspects
   * essentiels. Inspiré des méthodologies PMI et Agile.
   * 
   * PHILOSOPHIE :
   * Vision systémique du projet avec équilibre entre planification
   * et adaptabilité.
   * 
   * COMPOSANTS :
   * - Vue d'ensemble : Contexte et vision globale
   * - Objectifs : Résultats mesurables attendus
   * - Étapes : Jalons et phases du projet
   * - Ressources : Équipe, budget, outils
   * - Risques : Identification et mitigation
   * - Suivi : Métriques et progression
   * 
   * DIAGRAMME VISUEL :
   * ┌─────────────────────────────────┐
   * │       🎯 VUE D'ENSEMBLE         │
   * │    (Vision, contexte, enjeux)   │
   * ├───────────┬───────────┬─────────┤
   * │📋 OBJECTI │🚀 ÉTAPES  │💼 RESSO-│
   * │   FS      │           │   URCES │
   * │           │           │         │
   * ├───────────┴─────┬─────┴─────────┤
   * │  ⚠️ RISQUES     │ 📊 SUIVI     │
   * │                 │               │
   * └─────────────────┴───────────────┘
   * 
   * GRILLE TECHNIQUE : Vue hiérarchique avec header
   * CAS D'USAGE : Gestion de projet, initiatives stratégiques, lancements
   */
  layout_project: [
    {
      title: "Vue d'ensemble",
      x: 0,
      y: 0,
      w: 24,
      h: 6
      // Contexte, vision, objectifs généraux, parties prenantes
    },
    {
      title: "Objectifs",
      x: 0,
      y: 6,
      w: 8,
      h: 9
      // Objectifs SMART, critères de succès, KPIs
    },
    {
      title: "\xC9tapes",
      x: 8,
      y: 6,
      w: 8,
      h: 9
      // Jalons, phases, roadmap, planning général
    },
    {
      title: "Ressources",
      x: 16,
      y: 6,
      w: 8,
      h: 9
      // Équipe, budget, outils, compétences nécessaires
    },
    {
      title: "Risques",
      x: 0,
      y: 15,
      w: 12,
      h: 9
      // Identification, évaluation, plans de mitigation
    },
    {
      title: "Suivi",
      x: 12,
      y: 15,
      w: 12,
      h: 9
      // Métriques, avancement, reporting, ajustements
    }
  ],
  // ===========================================================================
  // SECTION 5 : LAYOUTS BASIQUES ET POLYVALENTS
  // ===========================================================================
  /**
   * BOARD SIMPLE - Approche minimaliste 2 colonnes
   * 
   * MÉTHODOLOGIE :
   * Simplicité volontaire pour démarrage rapide ou usages non-spécialisés.
   * Basé sur la dichotomie pensée/action.
   * 
   * PHILOSOPHIE :
   * "La simplicité est la sophistication suprême" - Leonardo da Vinci
   * Parfait pour débuter ou pour des besoins basiques.
   * 
   * APPLICATIONS :
   * - Brainstorming : Idées → Actions
   * - Comparaison : Pour → Contre
   * - Processus : Input → Output
   * - Planning : Cette semaine → Semaine prochaine
   * 
   * DIAGRAMME VISUEL :
   * ┌─────────────┬─────────────┐
   * │             │             │
   * │   💡 IDEAS  │ ⚡ ACTIONS  │
   * │             │             │
   * │             │             │
   * │             │             │
   * │             │             │
   * │             │             │
   * │             │             │
   * └─────────────┴─────────────┘
   * 
   * GRILLE TECHNIQUE : 2 colonnes égales, simplicité maximale
   * CAS D'USAGE : Brainstorming, comparaisons, projets simples, démarrage
   */
  layout_simple: [
    {
      title: "Ideas",
      x: 0,
      y: 0,
      w: 12,
      h: 24
      // Idées, concepts, possibilités, réflexions
    },
    {
      title: "Actions",
      x: 12,
      y: 0,
      w: 12,
      h: 24
      // Actions concrètes, tâches, étapes suivantes
    }
  ],
  // ===========================================================================
  // SECTION 6 : LAYOUTS DE PRISE DE NOTES
  // ===========================================================================
  /**
   * NOTES CORNELL - Système de prise de notes universitaire
   * 
   * MÉTHODOLOGIE :
   * Développé à l'université Cornell par Walter Pauk dans les années 1950.
   * Optimise la prise de notes, la révision et la mémorisation.
   * 
   * PHILOSOPHIE :
   * Structure prédéfinie qui force l'organisation et la synthèse.
   * Séparation claire entre capture, analyse et mémorisation.
   * 
   * ZONES FONCTIONNELLES :
   * 1. Notes principales : Capture du contenu principal
   * 2. Mots-clés/Questions : Indices de révision et concepts clés
   * 3. Résumé : Synthèse personnelle et points clés
   * 
   * PROCESSUS :
   * PENDANT → Prendre des notes dans la zone principale
   * APRÈS → Ajouter mots-clés et questions dans la marge
   * RÉVISION → Utiliser les mots-clés pour réviser
   * SYNTHÈSE → Écrire un résumé personnel
   * 
   * DIAGRAMME VISUEL :
   * ┌────────────────────┬───────┐
   * │                    │       │
   * │     📝 NOTES       │ 🏷️    │
   * │   (Contenu         │ MOTS- │
   * │    principal)      │ CLÉS  │
   * │                    │       │
   * │                    │       │
   * ├────────────────────┴───────┤
   * │      📋 RÉSUMÉ             │
   * │   (Synthèse personnelle)   │
   * └────────────────────────────┘
   * 
   * GRILLE TECHNIQUE : Zone principale + marge + footer
   * CAS D'USAGE : Cours, conférences, lectures, formations
   */
  layout_cornell: [
    {
      title: "Notes",
      x: 0,
      y: 0,
      w: 16,
      h: 18
      // Zone principale de prise de notes pendant l'écoute
    },
    {
      title: "Mots-cl\xE9s",
      x: 16,
      y: 0,
      w: 8,
      h: 18
      // Marge pour concepts clés, questions, indices de révision
    },
    {
      title: "R\xE9sum\xE9",
      x: 0,
      y: 18,
      w: 24,
      h: 6
      // Synthèse personnelle en fin de session
    }
  ],
  // ===========================================================================
  // SECTION 7 : LAYOUTS D'INTÉGRATION AVEC PLUGINS OBSIDIAN
  // ===========================================================================
  /**
   * DASHBOARD TASKS - Intégration avancée avec le plugin Tasks
   * 
   * MÉTHODOLOGIE :
   * Optimisé pour exploiter les capacités du plugin Tasks d'Obsidian.
   * Affichage intelligent des tâches par contexte temporel et projet.
   * 
   * PHILOSOPHIE :
   * Centralisation et contextualisation des tâches pour une vision
   * d'ensemble de la charge de travail.
   * 
   * ZONES TEMPORELLES :
   * - Aujourd'hui : Focus sur l'immédiat
   * - Cette semaine : Vision à court terme
   * - En retard : Gestion des dépassements
   * - Projets actifs : Vision organisationnelle
   * - Statistiques : Métriques et tendances
   * 
   * REQUÊTES TASKS INTÉGRÉES :
   * Utilise la syntaxe du plugin Tasks pour des requêtes dynamiques.
   * 
   * DIAGRAMME VISUEL :
   * ┌─────────┬─────────┬─────────┐
   * │ 📅 AUJ. │📅 SEMN │⚠️ RETARD│
   * │         │         │         │
   * │ tasks   │ tasks   │ tasks   │
   * │ due     │ due     │ due     │
   * │ today   │ this    │ before  │
   * │         │ week    │ today   │
   * ├─────────┴─────────┼─────────┤
   * │  📊 PROJETS       │📈 STATS │
   * │    ACTIFS         │         │
   * │ (par projet)      │(métriq.)│
   * └───────────────────┴─────────┘
   * 
   * REQUÊTES TASKS SUGGÉRÉES :
   * - Aujourd'hui : ```tasks due today not done```
   * - Cette semaine : ```tasks due this week not done```
   * - En retard : ```tasks due before today not done```
   * - Par projet : ```tasks group by project```
   * 
   * GRILLE TECHNIQUE : Vue temporelle + organisation + analytics
   * CAS D'USAGE : Gestion avancée des tâches, productivité, suivi projets
   */
  layout_tasks_dashboard: [
    {
      title: "T\xE2ches du jour",
      x: 0,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due today not done```
    },
    {
      title: "Cette semaine",
      x: 8,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due this week not done```
    },
    {
      title: "En retard",
      x: 16,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due before today not done```
    },
    {
      title: "Projets actifs",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // ```tasks group by project``` ou organisation manuelle
    },
    {
      title: "Statistiques",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // Métriques, tendances, analyse de productivité
    }
  ]
};
var LAYOUT_INFO = {
  layout_eisenhower: {
    name: "layout_eisenhower",
    displayName: "Matrice d'Eisenhower",
    description: "Syst\xE8me de priorisation bas\xE9 sur l'urgence et l'importance. Parfait pour la gestion quotidienne et les d\xE9cisions strat\xE9giques.",
    sections: ["Urgent et Important", "Pas urgent mais Important", "Urgent mais Pas important", "Ni urgent ni important"],
    blockCount: 4,
    category: "productivit\xE9"
  },
  layout_gtd: {
    name: "layout_gtd",
    displayName: "Getting Things Done (GTD)",
    description: "M\xE9thode compl\xE8te de productivit\xE9 de David Allen. Syst\xE8me d'externalisation de la m\xE9moire et de clarification syst\xE9matique.",
    sections: ["Inbox", "Actions suivantes", "En attente", "Projets", "Someday Maybe", "R\xE9f\xE9rence"],
    blockCount: 6,
    category: "productivit\xE9"
  },
  layout_kanban: {
    name: "layout_kanban",
    displayName: "Tableau Kanban",
    description: "Visualisation du flux de travail avec limitation du travail en cours. Id\xE9al pour le d\xE9veloppement et la gestion d'\xE9quipe.",
    sections: ["\xC0 faire", "En cours", "Termin\xE9"],
    blockCount: 3,
    category: "workflow"
  },
  layout_weekly: {
    name: "layout_weekly",
    displayName: "Planificateur Hebdomadaire",
    description: "Organisation par jour de la semaine avec \xE9quilibre travail/repos. Parfait pour la planification personnelle et la coordination d'\xE9quipe.",
    sections: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Weekend", "Notes"],
    blockCount: 7,
    category: "planification"
  },
  layout_daily: {
    name: "layout_daily",
    displayName: "Planificateur Quotidien",
    description: "Structure d\xE9taill\xE9e d'une journ\xE9e avec focus sur l'apprentissage et la r\xE9flexion. Id\xE9al pour le d\xE9veloppement personnel.",
    sections: ["Objectifs du jour", "T\xE2ches prioritaires", "Planning", "Notes", "Apprentissages", "R\xE9flexions"],
    blockCount: 6,
    category: "planification"
  },
  layout_project: {
    name: "layout_project",
    displayName: "Gestion de Projet",
    description: "Vue d'ensemble compl\xE8te d'un projet avec tous les aspects essentiels. Inspir\xE9 des m\xE9thodologies PMI et Agile.",
    sections: ["Vue d'ensemble", "Objectifs", "\xC9tapes", "Ressources", "Risques", "Suivi"],
    blockCount: 6,
    category: "projet"
  },
  layout_simple: {
    name: "layout_simple",
    displayName: "Board Simple",
    description: "Approche minimaliste \xE0 2 colonnes. Parfait pour d\xE9buter ou pour des besoins basiques de brainstorming et comparaison.",
    sections: ["Ideas", "Actions"],
    blockCount: 2,
    category: "basique"
  },
  layout_cornell: {
    name: "layout_cornell",
    displayName: "Notes Cornell",
    description: "Syst\xE8me de prise de notes universitaire optimisant la capture, r\xE9vision et m\xE9morisation. D\xE9velopp\xE9 \xE0 Cornell University.",
    sections: ["Notes", "Mots-cl\xE9s", "R\xE9sum\xE9"],
    blockCount: 3,
    category: "notes"
  },
  layout_tasks_dashboard: {
    name: "layout_tasks_dashboard",
    displayName: "Dashboard Tasks",
    description: "Int\xE9gration avanc\xE9e avec le plugin Tasks d'Obsidian. Affichage intelligent des t\xE2ches par contexte temporel et projet.",
    sections: ["T\xE2ches du jour", "Cette semaine", "En retard", "Projets actifs", "Statistiques"],
    blockCount: 5,
    category: "int\xE9gration"
  }
};

// src/services/LayoutService.ts
var LayoutService = class {
  /**
   * CONSTRUCTEUR avec injection de dépendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * INJECTION DE DÉPENDANCE :
   * Le plugin est injecté pour potentiel accès futur à :
   * - Configuration utilisateur
   * - Système de logs
   * - Événements du plugin
   * 
   * MODIFICATEUR private :
   * Le plugin est stocké pour usage interne uniquement
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Stockage interne des layouts validés
     * 
     * CHOIX DE STRUCTURE DE DONNÉES :
     * Map vs Object :
     * - Map : accès O(1), iteration garantie, clés dynamiques
     * - Object : plus de syntaxe, risque de pollution du prototype
     * 
     * GÉNÉRICS TYPESCRIPT :
     * Map<K, V> indique les types de clé et valeur
     * - K = string (nom du layout)
     * - V = BoardLayout[] (array de blocs)
     */
    this.models = /* @__PURE__ */ new Map();
  }
  // ===========================================================================
  // MÉTHODES DE CHARGEMENT ET INITIALISATION
  // ===========================================================================
  /**
   * Charge et valide tous les layouts intégrés
   * 
   * PROCESSUS DE CHARGEMENT :
   * 1. Vider le cache existant
   * 2. Itérer sur tous les layouts prédéfinis
   * 3. Valider chaque layout géométriquement
   * 4. Stocker les layouts valides
   * 5. Rejeter les layouts invalides avec warning
   * 6. Logger le résumé du chargement
   * 
   * GESTION D'ERREURS :
   * Les layouts invalides sont ignorés mais loggés.
   * Le plugin continue de fonctionner avec les layouts valides.
   * 
   * VALIDATION GÉOMÉTRIQUE :
   * - Vérification des limites de grille
   * - Détection des chevauchements
   * - Validation des types de données
   * 
   * @example
   * layoutService.load();
   * // Log: "📐 3 layouts chargés"
   * // Log: "📋 Layouts disponibles: layout_eisenhower, layout_kanban, ..."
   */
  load() {
    console.log("\u{1F4D0} Chargement des layouts int\xE9gr\xE9s...");
    this.models.clear();
    let loadedCount = 0;
    for (const [name, layout] of Object.entries(BUILT_IN_LAYOUTS)) {
      console.log(`\u{1F50D} Chargement du layout "${name}"...`);
      if (this.validateModel(name, layout)) {
        this.models.set(name, layout);
        loadedCount++;
        console.log(`\u2705 Layout "${name}" charg\xE9 (${layout.length} blocs)`);
      } else {
        console.warn(`\u274C Mod\xE8le "${name}" invalide`);
      }
    }
    console.log(`\u{1F4D0} ${loadedCount} layouts charg\xE9s`);
    this.logAvailableLayouts();
  }
  /**
   * Valide complètement un layout (géométrie + cohérence)
   * 
   * VALIDATION EN PLUSIEURS ÉTAPES :
   * 1. Validation individuelle de chaque bloc
   * 2. Vérification des limites de grille
   * 3. Détection des chevauchements
   * 4. Création d'une grille de test pour simulation
   * 
   * ALGORITHME DE CHEVAUCHEMENT :
   * - Créer une grille booléenne 24×100
   * - Pour chaque bloc, marquer ses cellules
   * - Si une cellule est déjà marquée = chevauchement
   * 
   * @param name - Nom du layout (pour les logs d'erreur)
   * @param layout - Array de blocs à valider
   * @returns boolean - true si le layout est entièrement valide
   * 
   * @example
   * const isValid = layoutService.validateModel("test", [
   *   { title: "Block 1", x: 0, y: 0, w: 12, h: 12 },
   *   { title: "Block 2", x: 12, y: 0, w: 12, h: 12 }
   * ]);
   * // true si pas de chevauchement, false sinon
   */
  validateModel(name, layout) {
    const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
    let isValid = true;
    for (const block of layout) {
      if (!this.isValidBlock(block)) {
        console.warn(`\u274C [${name}] Bloc invalide :`, block);
        isValid = false;
        continue;
      }
      if (!this.isBlockInBounds(block)) {
        console.warn(`\u274C [${name}] Bloc hors limites :`, block);
        isValid = false;
        continue;
      }
      if (!this.checkOverlap(grid, block, name)) {
        isValid = false;
      }
    }
    return isValid;
  }
  /**
   * Vérifie qu'un objet a la structure d'un BoardLayout valide
   * 
   * TYPE GUARD TYPESCRIPT :
   * Cette fonction est un "type guard" qui vérifie à l'exécution
   * qu'un objet correspond à l'interface BoardLayout.
   * 
   * VÉRIFICATIONS :
   * - Présence de toutes les propriétés requises
   * - Types corrects (string pour title, number pour les autres)
   * - Pas de vérification des valeurs (fait dans isBlockInBounds)
   * 
   * @param block - Objet à vérifier (type any pour flexibilité)
   * @returns block is BoardLayout - Type guard TypeScript
   * 
   * @example
   * const obj = { title: "Test", x: 0, y: 0, w: 5, h: 5 };
   * if (isValidBlock(obj)) {
   *   // TypeScript sait maintenant que obj est un BoardLayout
   *   console.log(obj.title); // Pas d'erreur TypeScript
   * }
   */
  isValidBlock(block) {
    return typeof block.title === "string" && // Titre doit être une chaîne
    typeof block.x === "number" && // Position X doit être un nombre
    typeof block.y === "number" && // Position Y doit être un nombre
    typeof block.w === "number" && // Largeur doit être un nombre
    typeof block.h === "number";
  }
  /**
   * Vérifie qu'un bloc respecte les limites de la grille
   * 
   * CONTRAINTES DE GRILLE :
   * - x >= 0 : pas de position négative
   * - y >= 0 : pas de position négative
   * - w > 0 : largeur positive
   * - h > 0 : hauteur positive
   * - x + w <= 24 : ne déborde pas à droite
   * - y + h <= 100 : ne déborde pas en bas
   * 
   * @param block - Bloc à vérifier (déjà validé par isValidBlock)
   * @returns boolean - true si dans les limites
   * 
   * @example
   * isBlockInBounds({ title: "Test", x: 20, y: 0, w: 5, h: 10 });
   * // false car x(20) + w(5) = 25 > 24 (déborde à droite)
   */
  isBlockInBounds(block) {
    return block.x >= 0 && // Position X positive
    block.y >= 0 && // Position Y positive
    block.w > 0 && // Largeur positive
    block.h > 0 && // Hauteur positive
    block.x + block.w <= 24 && // Pas de débordement horizontal
    block.y + block.h <= 100;
  }
  /**
   * Vérifie qu'un bloc ne chevauche pas avec les blocs déjà placés
   * 
   * ALGORITHME :
   * 1. Parcourir toutes les cellules du bloc
   * 2. Pour chaque cellule (x, y), vérifier si grid[x][y] est déjà true
   * 3. Si déjà true = chevauchement détecté
   * 4. Sinon, marquer la cellule comme occupée
   * 
   * EFFET DE BORD :
   * Cette fonction modifie la grille en marquant les cellules occupées.
   * C'est voulu pour la détection cumulative de chevauchements.
   * 
   * @param grid - Grille de test (modifiée par la fonction)
   * @param block - Bloc à placer
   * @param modelName - Nom du layout (pour les logs d'erreur)
   * @returns boolean - true si pas de chevauchement
   * 
   * @example
   * const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
   * const block1 = { title: "A", x: 0, y: 0, w: 10, h: 10 };
   * const block2 = { title: "B", x: 5, y: 5, w: 10, h: 10 };
   * 
   * checkOverlap(grid, block1, "test"); // true (première fois)
   * checkOverlap(grid, block2, "test"); // false (chevauchement en (5,5)-(9,9))
   */
  checkOverlap(grid, block, modelName) {
    for (let x = block.x; x < block.x + block.w; x++) {
      for (let y = block.y; y < block.y + block.h; y++) {
        if (grid[x][y]) {
          console.warn(`\u274C [${modelName}] Chevauchement d\xE9tect\xE9 au bloc "${block.title}" \xE0 (${x}, ${y})`);
          return false;
        }
        grid[x][y] = true;
      }
    }
    return true;
  }
  /**
   * Affiche un résumé des layouts chargés dans la console
   * 
   * UTILITÉ :
   * - Débogage : voir quels layouts sont disponibles
   * - Vérification : confirmer que le chargement s'est bien passé
   * - Documentation : liste des sections de chaque layout
   * 
   * FORMAT DE SORTIE :
   * ```
   * 📋 Layouts disponibles: layout_eisenhower, layout_kanban
   *   • layout_eisenhower: 4 sections (Urgent et Important, Pas urgent...)
   *   • layout_kanban: 3 sections (À faire, En cours, Terminé)
   * ```
   */
  logAvailableLayouts() {
    const layouts = Array.from(this.models.keys());
    console.log("\u{1F4CB} Layouts disponibles:", layouts);
    for (const [name, layout] of this.models) {
      const sections = layout.map((b) => b.title).join(", ");
      console.log(`  \u2022 ${name}: ${layout.length} sections (${sections})`);
    }
  }
  // ===========================================================================
  // MÉTHODES D'ACCÈS PUBLIC (API DU SERVICE)
  // ===========================================================================
  /**
   * Récupère un layout par son nom
   * 
   * API PRINCIPALE :
   * Cette méthode est l'interface principale pour obtenir un layout.
   * Utilisée par BoardView, ViewSwitcher, etc.
   * 
   * RETOUR UNDEFINED :
   * Retourne undefined si le layout n'existe pas.
   * Plus sûr que de lever une exception.
   * 
   * @param name - Nom du layout (ex: "layout_eisenhower")
   * @returns BoardLayout[] | undefined - Layout ou undefined si inexistant
   * 
   * @example
   * const layout = layoutService.getModel("layout_eisenhower");
   * if (layout) {
   *   // Layout trouvé, on peut l'utiliser
   *   console.log(`Layout avec ${layout.length} blocs`);
   * } else {
   *   // Layout inexistant
   *   console.error("Layout non trouvé");
   * }
   */
  getModel(name) {
    return this.models.get(name);
  }
  /**
   * Retourne la liste de tous les noms de layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : lister les layouts dans un menu
   * - Validation : vérifier qu'un layout existe
   * - Débogage : voir ce qui est disponible
   * 
   * @returns string[] - Array des noms de layouts
   * 
   * @example
   * const names = layoutService.getAllModelNames();
   * console.log(names); // ["layout_eisenhower", "layout_kanban", ...]
   * 
   * // Utilisation dans une interface
   * names.forEach(name => {
   *   const displayName = getLayoutDisplayName(name);
   *   addMenuItem(displayName, () => createNote(name));
   * });
   */
  getAllModelNames() {
    return Array.from(this.models.keys());
  }
  /**
   * Obtient le nom d'affichage convivial d'un layout
   * 
   * MAPPING TECHNIQUE → USER-FRIENDLY :
   * "layout_eisenhower" → "Matrice d'Eisenhower"
   * 
   * FALLBACK :
   * Si aucun nom d'affichage n'est défini, retourne le nom technique.
   * Évite les erreurs si les métadonnées sont incomplètes.
   * 
   * @param layoutName - Nom technique du layout
   * @returns string - Nom d'affichage ou nom technique si non trouvé
   * 
   * @example
   * const displayName = layoutService.getLayoutDisplayName("layout_eisenhower");
   * console.log(displayName); // "Matrice d'Eisenhower"
   * 
   * const unknownName = layoutService.getLayoutDisplayName("layout_custom");
   * console.log(unknownName); // "layout_custom" (fallback)
   */
  getLayoutDisplayName(layoutName) {
    const layoutInfo = LAYOUT_INFO[layoutName];
    return layoutInfo ? layoutInfo.displayName : layoutName;
  }
  /**
   * Obtient les métadonnées complètes d'un layout
   * 
   * MÉTADONNÉES ENRICHIES :
   * - Nom technique et d'affichage
   * - Description et cas d'usage
   * - Liste des sections
   * - Nombre de blocs
   * - Catégorie pour organisation
   * 
   * GÉNÉRATION AUTOMATIQUE :
   * Si les métadonnées prédéfinies n'existent pas, génère des métadonnées
   * basiques à partir du layout lui-même.
   * 
   * @param name - Nom du layout
   * @returns LayoutInfo | undefined - Métadonnées ou undefined si layout inexistant
   * 
   * @example
   * const info = layoutService.getModelInfo("layout_eisenhower");
   * if (info) {
   *   console.log(`${info.displayName}: ${info.description}`);
   *   console.log(`Sections: ${info.sections.join(', ')}`);
   *   console.log(`Catégorie: ${info.category}`);
   * }
   */
  getModelInfo(name) {
    const model = this.models.get(name);
    if (!model)
      return void 0;
    const info = LAYOUT_INFO[name];
    return info || {
      name,
      displayName: name,
      // Nom technique par défaut
      description: "Layout personnalis\xE9",
      // Description générique
      sections: model.map((block) => block.title),
      // Extraire les titres des blocs
      blockCount: model.length,
      // Compter les blocs
      category: "custom"
      // Catégorie par défaut
    };
  }
  /**
   * Retourne les métadonnées de tous les layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : afficher tous les layouts avec détails
   * - Filtrage : grouper par catégorie
   * - Documentation : générer de l'aide automatiquement
   * 
   * PERFORMANCE :
   * Génère les métadonnées à la demande.
   * Pour de meilleures performances avec beaucoup de layouts,
   * on pourrait envisager un cache.
   * 
   * @returns LayoutInfo[] - Array de toutes les métadonnées
   */
  getAllModelsInfo() {
    return Array.from(this.models.keys()).map((name) => this.getModelInfo(name)).filter((info) => info !== void 0);
  }
};

// src/services/FileService.ts
var FileService = class {
  /**
   * CONSTRUCTEUR avec injection de dépendance
   * 
   * @param app - Instance principale d'Obsidian
   * 
   * CONCEPT OBSIDIAN - APP :
   * L'objet App donne accès à toutes les fonctionnalités d'Obsidian :
   * - app.vault : Système de fichiers
   * - app.metadataCache : Cache des métadonnées
   * - app.workspace : Gestion des vues et onglets
   * 
   * MODIFICATEUR private :
   * Rend la propriété accessible uniquement dans cette classe
   */
  constructor(app) {
    this.app = app;
  }
  // ===========================================================================
  // MÉTHODES PRINCIPALES DE PARSING
  // ===========================================================================
  /**
   * Parse toutes les sections H1 d'un fichier markdown
   * 
   * ALGORITHME :
   * 1. Lire le contenu du fichier
   * 2. Découper en lignes
   * 3. Identifier les titres H1 (lignes commençant par "# ")
   * 4. Extraire le contenu entre chaque titre
   * 5. Créer des objets FileSection avec métadonnées
   * 
   * GESTION DES CAS LIMITES :
   * - Fichier vide : retourne objet vide
   * - Pas de sections H1 : retourne objet vide
   * - Sections vides : incluses avec tableau de lignes vide
   * - Dernière section : va jusqu'à la fin du fichier
   * 
   * @param file - Fichier Obsidian à parser
   * @returns Promise<FileSections> - Dictionnaire des sections trouvées
   * 
   * @example
   * // Pour un fichier contenant :
   * // # Section 1
   * // Contenu 1
   * // # Section 2  
   * // Contenu 2
   * 
   * const sections = await fileService.parseSections(file);
   * // Retourne :
   * // {
   * //   "Section 1": { start: 0, end: 2, lines: ["Contenu 1"] },
   * //   "Section 2": { start: 2, end: 4, lines: ["Contenu 2"] }
   * // }
   */
  async parseSections(file) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = {};
    let currentSection = null;
    let sectionStart = 0;
    console.log("\u{1F4D6} Parsing sections du fichier:", file.basename);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const headerMatch = line.match(/^# ([^\n#].*?)\s*$/);
      if (headerMatch) {
        if (currentSection !== null) {
          const sectionLines = lines.slice(sectionStart + 1, i);
          sections[currentSection] = {
            start: sectionStart,
            // Index de la ligne du titre
            end: i,
            // Index de la ligne suivante (exclus)
            lines: sectionLines
            // Contenu de la section
          };
          console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
        }
        currentSection = headerMatch[1].trim();
        sectionStart = i;
      }
    }
    if (currentSection !== null) {
      const sectionLines = lines.slice(sectionStart + 1);
      sections[currentSection] = {
        start: sectionStart,
        end: lines.length,
        // Fin du fichier
        lines: sectionLines
      };
      console.log(`\u{1F4C4} Section "${currentSection}": ${sectionLines.length} lignes`);
    }
    console.log("\u2705 Sections trouv\xE9es:", Object.keys(sections));
    return sections;
  }
  // ===========================================================================
  // MÉTHODES DE MODIFICATION DES FICHIERS
  // ===========================================================================
  /**
   * Crée automatiquement les sections manquantes dans un fichier
   * 
   * PROCESSUS :
   * 1. Parser les sections existantes
   * 2. Comparer avec les sections requises par le layout
   * 3. Identifier les sections manquantes
   * 4. Trouver le point d'insertion optimal
   * 5. Générer le contenu des nouvelles sections
   * 6. Insérer et sauvegarder
   * 
   * STRATÉGIE D'INSERTION :
   * - Après le frontmatter YAML (s'il existe)
   * - Sinon au début du fichier
   * - Chaque section avec titre H1 et ligne vide
   * 
   * @param file - Fichier à modifier
   * @param layout - Layout définissant les sections requises
   * @returns Promise<boolean> - true si des sections ont été créées
   * 
   * @example
   * // Layout requiert : ["Section A", "Section B", "Section C"]
   * // Fichier contient : ["Section A", "Section C"]
   * // Résultat : Ajoute "Section B" au fichier
   */
  async createMissingSections(file, layout) {
    console.log("\u{1F527} V\xE9rification des sections manquantes...");
    const sections = await this.parseSections(file);
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = requiredSections.filter(
      (section) => !existingSections.includes(section)
    );
    if (missingSections.length === 0) {
      console.log("\u2705 Toutes les sections sont pr\xE9sentes");
      return false;
    }
    console.log("\u{1F4DD} Sections manquantes d\xE9tect\xE9es:", missingSections);
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const insertionPoint = this.findInsertionPoint(lines);
    const newSectionLines = [];
    for (const sectionTitle of missingSections) {
      newSectionLines.push("");
      newSectionLines.push(`# ${sectionTitle}`);
      newSectionLines.push("");
    }
    const updatedLines = [
      ...lines.slice(0, insertionPoint),
      // Contenu avant insertion
      ...newSectionLines,
      // Nouvelles sections
      ...lines.slice(insertionPoint)
      // Contenu après insertion
    ];
    await this.app.vault.modify(file, updatedLines.join("\n"));
    console.log(`\u2705 ${missingSections.length} sections ajout\xE9es:`, missingSections);
    return true;
  }
  /**
   * Trouve le point d'insertion optimal pour les nouvelles sections
   * 
   * LOGIQUE :
   * 1. Chercher un frontmatter YAML (entre --- ... ---)
   * 2. Si frontmatter trouvé : insérer après
   * 3. Sinon : insérer au début du fichier
   * 
   * FRONTMATTER YAML :
   * Bloc de métadonnées au début des fichiers markdown :
   * ---
   * title: Mon titre
   * tags: [tag1, tag2]
   * ---
   * 
   * @param lines - Lignes du fichier
   * @returns number - Index de ligne où insérer
   * 
   * @example
   * // Fichier avec frontmatter :
   * // ---
   * // title: Test
   * // ---
   * // # Existing Section
   * 
   * findInsertionPoint(lines); // Retourne 3 (après le frontmatter)
   */
  findInsertionPoint(lines) {
    let frontmatterEnd = 0;
    let inFrontmatter = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (i === 0 && line === "---") {
        inFrontmatter = true;
        continue;
      }
      if (inFrontmatter && line === "---") {
        frontmatterEnd = i + 1;
        break;
      }
    }
    if (frontmatterEnd === 0) {
      return 0;
    } else {
      return frontmatterEnd;
    }
  }
  /**
   * Met à jour le contenu d'une section spécifique
   * 
   * PROCESSUS :
   * 1. Parser les sections pour trouver la section cible
   * 2. Remplacer son contenu par le nouveau
   * 3. Conserver le titre et la structure
   * 4. Sauvegarder le fichier
   * 
   * UTILISATION :
   * Appelée par MarkdownFrame quand l'utilisateur modifie une section
   * dans l'interface Board.
   * 
   * @param file - Fichier à modifier
   * @param sectionName - Nom de la section à mettre à jour
   * @param newContent - Nouveau contenu (sans le titre #)
   * 
   * @example
   * await fileService.updateSection(file, "Urgent et Important", "- Nouvelle tâche\n- Autre tâche");
   */
  async updateSection(file, sectionName, newContent) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const sections = await this.parseSections(file);
    const section = sections[sectionName];
    if (!section) {
      console.warn(`\u26A0\uFE0F Section "${sectionName}" non trouv\xE9e pour mise \xE0 jour`);
      return;
    }
    const newLines = [
      ...lines.slice(0, section.start + 1),
      // Avant la section (inclus le titre)
      ...newContent.split("\n"),
      // Nouveau contenu
      ...lines.slice(section.end)
      // Après la section
    ];
    await this.app.vault.modify(file, newLines.join("\n"));
    console.log(`\u2705 Section "${sectionName}" mise \xE0 jour`);
  }
  // ===========================================================================
  // MÉTHODES UTILITAIRES
  // ===========================================================================
  /**
   * Identifie les sections manquantes par rapport à un layout
   * 
   * ALGORITHME SIMPLE :
   * Filtre les sections requises qui ne sont pas dans les sections existantes.
   * 
   * FONCTION PURE :
   * - Pas d'effets de bord
   * - Même entrée = même sortie
   * - Facilement testable
   * 
   * @param existingSections - Sections actuellement présentes
   * @param requiredSections - Sections requises par le layout
   * @returns string[] - Liste des sections manquantes
   * 
   * @example
   * const missing = fileService.getMissingSections(
   *   ["Section A", "Section C"],           // Existantes
   *   ["Section A", "Section B", "Section C"]  // Requises
   * );
   * // Retourne : ["Section B"]
   */
  getMissingSections(existingSections, requiredSections) {
    return requiredSections.filter(
      (section) => !existingSections.includes(section)
    );
  }
};

// src/views/BoardView.ts
var import_obsidian = require("obsidian");

// src/components/MarkdownFrame.ts
var MarkdownFrame = class {
  // ===========================================================================
  // CONSTRUCTEUR ET INITIALISATION
  // ===========================================================================
  /**
   * CONSTRUCTEUR du composant MarkdownFrame
   * * @param app - Instance principale d'Obsidian
   * @param container - Élément DOM parent où injecter le composant
   * @param file - Fichier source contenant cette section
   * @param section - Métadonnées de la section (lignes, position)
   * @param onChange - Callback appelé lors des modifications
   * * INJECTION DE DÉPENDANCES :
   * - app : Pour accès aux APIs Obsidian (rendu, navigation)
   * - container : Pour manipulation DOM
   * - file : Pour contexte de rendu (chemins relatifs, etc.)
   * - onChange : Pour notifier le parent des changements
   * * INITIALISATION :
   * Le constructeur démarre immédiatement l'initialisation complète.
   * * @example
   * const frame = new MarkdownFrame(
   * app,
   * frameElement,
   * currentFile,
   * sectionData,
   * (newContent) => saveToFile(sectionName, newContent)
   * );
   */
  constructor(app, container, file, section, onChange) {
    this.app = app;
    this.container = container;
    this.file = file;
    this.section = section;
    this.onChange = onChange;
    // ===========================================================================
    // PROPRIÉTÉS D'ÉTAT DU COMPOSANT
    // ===========================================================================
    /**
     * Indicateur du mode d'édition actuel
     * * ÉTATS POSSIBLES :
     * - false : Mode preview (affichage rendu)
     * - true : Mode édition (textarea visible)
     */
    this.isEditing = false;
    this.content = section.lines.join("\n");
    this.initializeFrame();
  }
  /**
   * Initialise complètement l'interface du composant
   * * ÉTAPES D'INITIALISATION :
   * 1. Configuration du conteneur principal
   * 2. Création du conteneur preview
   * 3. Création du conteneur d'édition
   * 4. Affichage initial en mode preview
   * * PATTERN TEMPLATE METHOD :
   * Orchestration de l'initialisation en étapes définies.
   */
  initializeFrame() {
    this.setupContainer();
    this.createPreviewContainer();
    this.createEditorContainer();
    this.showPreview();
  }
  /**
   * Configure le conteneur principal du composant
   * * NETTOYAGE :
   * Vide le conteneur existant pour éviter les conflits.
   * * STYLES CSS :
   * - Position relative pour positionnement des enfants
   * - Overflow hidden pour contenir le contenu
   * - Dimensions 100% pour remplir l'espace disponible
   */
  setupContainer() {
    this.container.empty();
    this.container.style.cssText = `
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    `;
  }
  // ===========================================================================
  // CRÉATION DES INTERFACES PREVIEW ET ÉDITION
  // ===========================================================================
  /**
   * Crée et configure le conteneur de preview (affichage rendu)
   * * RESPONSABILITÉS :
   * - Affichage du contenu markdown rendu
   * - Gestion des interactions (clics, tâches, liens)
   * - Détection du basculement vers l'édition
   * * STYLES :
   * Intégration avec les variables CSS d'Obsidian pour cohérence visuelle.
   */
  createPreviewContainer() {
    this.previewContainer = this.container.createDiv("markdown-preview");
    this.previewContainer.style.cssText = `
      width: 100%;
      height: 100%;
      overflow: auto;
      padding: 0.5rem;
      cursor: text;
      box-sizing: border-box;
    `;
    this.renderContent();
    this.setupPreviewEvents();
  }
  /**
   * Crée et configure le conteneur d'édition (textarea)
   * * RESPONSABILITÉS :
   * - Interface de modification directe du markdown
   * - Sauvegarde automatique des changements
   * - Gestion des raccourcis clavier (Escape)
   * * VISIBILITÉ :
   * Initialement caché, affiché seulement en mode édition.
   */
  createEditorContainer() {
    this.editorContainer = this.container.createDiv("markdown-editor");
    this.editorContainer.style.cssText = `
      width: 100%;
      height: 100%;
      display: none;
      box-sizing: border-box;
    `;
    this.textArea = this.editorContainer.createEl("textarea");
    this.textArea.style.cssText = `
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      resize: none;
      font-family: var(--font-text);
      font-size: var(--font-size-normal);
      background: transparent;
      color: var(--text-normal);
      padding: 0.5rem;
      box-sizing: border-box;
      line-height: 1.6;
    `;
    this.textArea.value = this.content;
    this.setupEditorEvents();
  }
  // ===========================================================================
  // MOTEUR DE RENDU MARKDOWN
  // ===========================================================================
  /**
   * Rend le contenu markdown avec le moteur officiel d'Obsidian
   * * MOTEUR DE RENDU :
   * Utilise MarkdownRenderer.renderMarkdown() qui supporte :
   * - Toutes les extensions markdown d'Obsidian
   * - Plugins tiers (Tasks, Dataview, etc.)
   * - Liens internes et navigation
   * - Syntaxe avancée (callouts, etc.)
   * * FALLBACK :
   * En cas d'erreur, utilise un moteur de rendu simple
   * pour maintenir la fonctionnalité de base.
   * * GESTION DU CONTENU VIDE :
   * Affiche un placeholder engageant pour inciter à l'édition.
   */
  async renderContent() {
    this.previewContainer.empty();
    if (!this.content.trim()) {
      this.renderEmptyState();
      return;
    }
    try {
      const { MarkdownRenderer, Component } = require("obsidian");
      const component = new Component();
      await MarkdownRenderer.renderMarkdown(
        this.content,
        // Contenu à rendre
        this.previewContainer,
        // Conteneur de destination
        this.file.path,
        // Contexte de fichier (pour liens relatifs)
        component
        // Composant pour cycle de vie
      );
      console.log("\u2705 Contenu rendu avec le moteur Obsidian (plugins support\xE9s)");
      this.setupInteractions();
    } catch (error) {
      console.warn("\u26A0\uFE0F Erreur rendu Obsidian, fallback vers rendu simple:", error);
      this.previewContainer.innerHTML = this.renderSimpleMarkdown(this.content);
    }
  }
  /**
   * Configure les interactions avec les éléments rendus
   * * INTERACTIONS SUPPORTÉES :
   * 1. Tâches cochables (Tasks plugin)
   * 2. Liens internes Obsidian
   * 3. Liens externes
   * 4. Éléments Dataview
   * * PATTERN EVENT DELEGATION :
   * Ajoute des écouteurs sur les éléments spécifiques
   * plutôt que sur le conteneur global.
   * * PRÉVENTION DE PROPAGATION :
   * Empêche les clics sur éléments interactifs de déclencher
   * le mode édition.
   */
  setupInteractions() {
    const taskCheckboxes = this.previewContainer.querySelectorAll('input[type="checkbox"].task-list-item-checkbox');
    taskCheckboxes.forEach((checkbox) => {
      checkbox.addEventListener("change", (event) => {
        const target = event.target;
        this.handleTaskToggle(target);
      });
    });
    const internalLinks = this.previewContainer.querySelectorAll("a.internal-link");
    internalLinks.forEach((link) => {
      link.addEventListener("click", (event) => {
        event.preventDefault();
        const href = link.getAttribute("data-href") || link.getAttribute("href");
        if (href) {
          this.app.workspace.openLinkText(href, this.file.path);
        }
      });
    });
    const interactiveElements = this.previewContainer.querySelectorAll("input, button, a, .dataview, .task-list-item");
    interactiveElements.forEach((element) => {
      element.addEventListener("click", (event) => {
        event.stopPropagation();
      });
    });
  }
  /**
   * Gère le cochage/décochage des tâches
   * * ALGORITHME :
   * 1. Identifier la tâche modifiée dans le DOM
   * 2. Trouver la ligne correspondante dans le markdown
   * 3. Mettre à jour la syntaxe de tâche ([ ] ↔ [x])
   * 4. Déclencher la sauvegarde automatique
   * * SYNCHRONISATION :
   * Maintient la cohérence entre affichage et source markdown.
   * * @param checkbox - Élément checkbox qui a été modifié
   * * @example
   * // Utilisateur coche une tâche dans l'affichage
   * // handleTaskToggle() met à jour le markdown :
   * // "- [ ] Tâche" → "- [x] Tâche"
   */
  handleTaskToggle(checkbox) {
    const isChecked = checkbox.checked;
    const listItem = checkbox.closest("li");
    if (!listItem)
      return;
    const taskText = this.getTaskTextFromListItem(listItem);
    if (!taskText)
      return;
    const lines = this.content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (this.isTaskLine(line) && this.getTaskTextFromLine(line) === taskText) {
        const newCheckState = isChecked ? "[x]" : "[ ]";
        lines[i] = line.replace(/\[[ x]\]/, newCheckState);
        this.content = lines.join("\n");
        clearTimeout(this.changeTimeout);
        this.changeTimeout = setTimeout(() => {
          this.onChange(this.content);
        }, 500);
        console.log(`\u2705 T\xE2che ${isChecked ? "coch\xE9e" : "d\xE9coch\xE9e"}: ${taskText}`);
        break;
      }
    }
  }
  /**
   * Extrait le texte d'une tâche depuis un élément de liste DOM
   * * @param listItem - Élément <li> contenant la tâche
   * @returns string | null - Texte de la tâche ou null si non trouvé
   */
  getTaskTextFromListItem(listItem) {
    var _a;
    const textNode = listItem.childNodes[listItem.childNodes.length - 1];
    return ((_a = textNode == null ? void 0 : textNode.textContent) == null ? void 0 : _a.trim()) || null;
  }
  /**
   * Vérifie si une ligne markdown est une tâche
   * * @param line - Ligne de texte à vérifier
   * @returns boolean - true si c'est une ligne de tâche
   * * @example
   * isTaskLine("- [x] Tâche terminée");  // true
   * isTaskLine("- [ ] Tâche à faire");   // true
   * isTaskLine("- Simple liste");        // false
   */
  isTaskLine(line) {
    return /^[\s]*[-*+] \[[ x]\]/.test(line);
  }
  /**
   * Extrait le texte d'une tâche depuis une ligne markdown
   * * @param line - Ligne markdown contenant une tâche
   * @returns string - Texte de la tâche (sans la syntaxe de liste/checkbox)
   */
  getTaskTextFromLine(line) {
    const match = line.match(/^[\s]*[-*+] \[[ x]\] (.+)$/);
    return match ? match[1].trim() : "";
  }
  /**
   * Moteur de rendu markdown simple (fallback)
   * * UTILISATION :
   * Quand le moteur Obsidian n'est pas disponible ou échoue.
   * Supporte la syntaxe markdown de base.
   * * FONCTIONNALITÉS :
   * - Liens internes [[...]]
   * - Gras **texte**
   * - Italique *texte*
   * - Listes simples
   * * @param content - Contenu markdown à rendre
   * @returns string - HTML généré
   */
  renderSimpleMarkdown(content) {
    let html = content;
    html = html.replace(/\[\[([^\]]+)\]\]/g, '<span class="internal-link">$1</span>');
    html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
    html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
    html = html.replace(/^[\s]*[-*+] (.+)$/gm, "<li>$1</li>");
    const lines = html.split("\n");
    let result = "";
    let inList = false;
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.includes("<li>")) {
        if (!inList) {
          result += "<ul>\n";
          inList = true;
        }
        result += line + "\n";
      } else {
        if (inList) {
          result += "</ul>\n";
          inList = false;
        }
        if (trimmed === "") {
          result += "<br>\n";
        } else {
          result += `<p>${trimmed}</p>
`;
        }
      }
    }
    if (inList) {
      result += "</ul>\n";
    }
    return result;
  }
  /**
   * Affiche un état vide engageant pour inciter à l'édition
   * * DESIGN UX :
   * Message clair et incitatif plutôt qu'un vide intimidant.
   * Style cohérent avec l'interface Obsidian.
   */
  renderEmptyState() {
    const placeholder = this.previewContainer.createDiv("empty-placeholder");
    placeholder.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      min-height: 80px;
      color: var(--text-muted);
      font-style: italic;
      cursor: text;
    `;
    placeholder.textContent = "Cliquez pour commencer \xE0 \xE9crire...";
  }
  // ===========================================================================
  // GESTION DES ÉVÉNEMENTS ET INTERACTIONS
  // ===========================================================================
  /**
   * Configure les événements du mode preview
   * * DÉTECTION INTELLIGENTE :
   * Distingue les clics sur éléments interactifs des clics d'édition.
   * Évite le basculement involontaire vers l'édition.
   */
  setupPreviewEvents() {
    this.previewContainer.addEventListener("click", (event) => {
      const target = event.target;
      if (this.isInteractiveElement(target)) {
        console.log("\u{1F3AF} Clic sur \xE9l\xE9ment interactif, pas de mode \xE9dition");
        return;
      }
      console.log("\u{1F5B1}\uFE0F Clic sur preview \u2192 mode \xE9dition");
      this.enterEditMode();
    });
  }
  /**
   * Détecte si un élément est interactif (ne doit pas déclencher l'édition)
   * * ÉLÉMENTS INTERACTIFS :
   * - Éléments HTML standard : input, button, a, select
   * - Éléments Obsidian : liens internes, tags
   * - Éléments de plugins : dataview, tasks
   * - Éléments avec attributs spéciaux
   * * ALGORITHME :
   * Remonte la hiérarchie DOM pour vérifier tous les parents.
   * Un élément est interactif si lui ou un parent l'est.
   * * @param element - Élément à vérifier
   * @returns boolean - true si interactif
   */
  isInteractiveElement(element) {
    let current = element;
    while (current && current !== this.previewContainer) {
      const tagName = current.tagName.toLowerCase();
      const classList = Array.from(current.classList);
      if (["input", "button", "a", "select", "textarea"].includes(tagName)) {
        return true;
      }
      const interactiveClasses = [
        "internal-link",
        "external-link",
        "tag",
        "dataview",
        "task-list-item-checkbox",
        "task-list-item",
        "cm-hmd-codeblock",
        "block-language-dataview",
        "block-language-tasks"
      ];
      if (interactiveClasses.some((cls) => classList.includes(cls))) {
        return true;
      }
      if (current.hasAttribute("href") || current.hasAttribute("data-href") || current.hasAttribute("data-task") || current.hasAttribute("contenteditable")) {
        return true;
      }
      current = current.parentElement;
    }
    return false;
  }
  /**
   * Configure les événements du mode édition
   * * ÉVÉNEMENTS GÉRÉS :
   * - input : Sauvegarde différée des modifications
   * - blur : Retour automatique au mode preview
   * - keydown : Raccourcis clavier (Escape)
   */
  setupEditorEvents() {
    this.textArea.addEventListener("input", () => {
      this.content = this.textArea.value;
      clearTimeout(this.changeTimeout);
      this.changeTimeout = setTimeout(() => {
        this.onChange(this.content);
      }, 1e3);
    });
    this.textArea.addEventListener("blur", () => {
      console.log("\u{1F4DD} Blur sur textarea \u2192 mode preview");
      this.exitEditMode();
    });
    this.textArea.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        console.log("\u2328\uFE0F Escape \u2192 mode preview");
        this.exitEditMode();
      }
    });
  }
  // ===========================================================================
  // GESTION DES MODES (PREVIEW ↔ ÉDITION)
  // ===========================================================================
  /**
   * Bascule vers le mode édition
   * * PROCESSUS :
   * 1. Marquer l'état comme "en édition"
   * 2. Cacher le preview
   * 3. Afficher l'éditeur
   * 4. Synchroniser le contenu
   * 5. Donner le focus au textarea
   */
  enterEditMode() {
    this.isEditing = true;
    this.previewContainer.style.display = "none";
    this.editorContainer.style.display = "block";
    this.textArea.value = this.content;
    this.textArea.focus();
    console.log("\u270F\uFE0F Mode \xE9dition activ\xE9");
  }
  /**
   * Bascule vers le mode preview
   * * PROCESSUS :
   * 1. Vérifier qu'on est bien en édition
   * 2. Récupérer le contenu du textarea
   * 3. Cacher l'éditeur
   * 4. Afficher le preview
   * 5. Re-rendre le contenu
   */
  exitEditMode() {
    if (!this.isEditing)
      return;
    this.isEditing = false;
    this.content = this.textArea.value;
    this.editorContainer.style.display = "none";
    this.previewContainer.style.display = "block";
    this.renderContent();
    console.log("\u{1F441}\uFE0F Mode preview activ\xE9");
  }
  /**
   * Force l'affichage du mode preview
   * * UTILISATION :
   * Initialisation du composant et réinitialisations.
   */
  showPreview() {
    this.previewContainer.style.display = "block";
    this.editorContainer.style.display = "none";
    this.isEditing = false;
  }
  // ===========================================================================
  // API PUBLIQUE DU COMPOSANT
  // ===========================================================================
  /**
   * Met à jour le contenu de la section
   * * UTILISATION :
   * Quand le fichier source est modifié externement.
   * Maintient la synchronisation avec la source de vérité.
   * * @param section - Nouvelles données de section
   */
  updateContent(section) {
    this.section = section;
    this.content = section.lines.join("\n");
    if (this.isEditing) {
      this.textArea.value = this.content;
    } else {
      this.renderContent();
    }
  }
  /**
   * Obtient le contenu actuel de la section
   * * @returns string - Contenu markdown actuel
   */
  getContent() {
    return this.isEditing ? this.textArea.value : this.content;
  }
  /**
   * Détruit proprement le composant
   * * NETTOYAGE :
   * - Vide le conteneur DOM
   * - Annule les timers en cours
   * - Libère les références
   * * UTILISATION :
   * Appelée lors du nettoyage de la BoardView.
   */
  destroy() {
    this.container.empty();
    console.log("\u{1F5D1}\uFE0F MarkdownFrame d\xE9truite");
  }
};

// src/views/BoardView.ts
var BOARD_VIEW_TYPE = "agile-board-view";
var BoardView = class extends import_obsidian.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.gridContainer = null;
    this.frames = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    console.log("\u{1F3AF} BoardView constructor appel\xE9");
  }
  getViewType() {
    return BOARD_VIEW_TYPE;
  }
  getDisplayText() {
    return this.file ? `${this.file.basename} (Board)` : "Agile Board";
  }
  getIcon() {
    return "layout-grid";
  }
  async onLoadFile(file) {
    console.log("\u{1F4C2} onLoadFile appel\xE9 pour:", file.basename);
    await this.renderBoardLayout();
  }
  async onUnloadFile(file) {
    console.log("\u{1F4C2} onUnloadFile appel\xE9 pour:", file.basename);
    this.cleanup();
  }
  // Méthode publique pour recharger le board
  async renderBoardLayout() {
    var _a;
    console.log("\u{1F3A8} renderBoardLayout d\xE9but");
    if (!this.file) {
      console.log("\u274C Pas de fichier dans renderBoardLayout");
      return;
    }
    console.log("\u{1F4C4} Fichier actuel:", this.file.basename);
    this.cleanup();
    const fileCache = this.app.metadataCache.getFileCache(this.file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    console.log("\u{1F3AF} Layout name d\xE9tect\xE9:", layoutName);
    if (!layoutName) {
      console.log("\u274C Pas de layout agile-board trouv\xE9");
      this.showNoLayoutMessage();
      return;
    }
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.log("\u274C Layout non trouv\xE9 dans le service");
      this.showLayoutNotFoundMessage(layoutName);
      return;
    }
    let sections = await this.plugin.fileService.parseSections(this.file);
    console.log("\u{1F4DA} Sections pars\xE9es:", Object.keys(sections));
    const existingSections = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    const missingSections = this.plugin.fileService.getMissingSections(existingSections, requiredSections);
    if (missingSections.length > 0) {
      console.log("\u{1F527} Sections manquantes d\xE9tect\xE9es:", missingSections);
      this.showMissingSectionsMessage(missingSections, layout);
      return;
    }
    console.log("\u2705 Rendu Board pour:", this.file.basename, "avec layout:", layoutName);
    this.createGrid();
    this.createFrames(layout, sections);
  }
  cleanup() {
    for (const frame of this.frames.values()) {
      frame.destroy();
    }
    this.frames.clear();
    if (this.gridContainer) {
      this.gridContainer.remove();
      this.gridContainer = null;
    }
    this.contentEl.empty();
  }
  createGrid() {
    console.log("\u{1F532} Cr\xE9ation de la grille");
    this.gridContainer = this.contentEl.createDiv("agile-board-grid");
    this.gridContainer.style.cssText = `
      display: grid;
      grid-template-columns: repeat(24, 1fr);
      gap: 0.5rem;
      padding: 1rem;
      height: 100%;
      overflow: auto;
      background: var(--background-primary);
    `;
  }
  createFrames(layout, sections) {
    if (!this.gridContainer) {
      console.log("\u274C Pas de gridContainer pour cr\xE9er les frames");
      return;
    }
    console.log("\u{1F5BC}\uFE0F Cr\xE9ation de", layout.length, "frames");
    for (const block of layout) {
      console.log("\u{1F5BC}\uFE0F Cr\xE9ation frame pour:", block.title);
      const frameElement = this.gridContainer.createDiv("agile-board-frame");
      frameElement.style.cssText = `
        grid-column: ${block.x + 1} / span ${block.w};
        grid-row: ${block.y + 1} / span ${block.h};
        min-height: 100px;
        display: flex;
        flex-direction: column;
        border: 2px solid var(--background-modifier-border);
        border-radius: 6px;
        background: var(--background-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      `;
      const titleElement = frameElement.createDiv("frame-title");
      titleElement.style.cssText = `
        padding: 0.5rem 0.75rem;
        font-weight: 500;
        color: var(--text-normal);
        border-bottom: 1px solid var(--background-modifier-border);
        background: var(--background-secondary);
        font-size: 1.1rem;
      `;
      titleElement.textContent = block.title;
      const contentElement = frameElement.createDiv("frame-content");
      contentElement.style.cssText = `
        flex: 1;
        overflow: auto;
        background: var(--background-primary);
      `;
      const section = sections[block.title];
      if (section) {
        const frame = new MarkdownFrame(
          this.app,
          contentElement,
          this.file,
          section,
          (content) => this.onFrameContentChanged(block.title, content)
        );
        this.frames.set(block.title, frame);
        console.log(`\u2705 Frame \xE9ditable cr\xE9\xE9e pour "${block.title}"`);
      } else {
        contentElement.style.padding = "0.75rem";
        contentElement.innerHTML = `
          <p><strong>\u274C Section manquante:</strong> ${block.title}</p>
          <p><em>Sections disponibles:</em> ${Object.keys(sections).join(", ")}</p>
        `;
        console.log(`\u274C Section "${block.title}" non trouv\xE9e`);
      }
    }
    console.log("\u2705 Toutes les frames cr\xE9\xE9es");
  }
  async onFrameContentChanged(sectionName, content) {
    if (!this.file)
      return;
    console.log(`\u{1F4BE} Changement d\xE9tect\xE9 dans la section "${sectionName}"`);
    try {
      const fileContent = await this.app.vault.read(this.file);
      const lines = fileContent.split("\n");
      const sections = await this.plugin.fileService.parseSections(this.file);
      const section = sections[sectionName];
      if (!section) {
        console.log(`\u274C Section "${sectionName}" non trouv\xE9e pour la sauvegarde`);
        return;
      }
      const newLines = [
        ...lines.slice(0, section.start + 1),
        // Avant la section (inclus le titre)
        ...content.split("\n"),
        // Nouveau contenu
        ...lines.slice(section.end)
        // Après la section
      ];
      await this.app.vault.modify(this.file, newLines.join("\n"));
      console.log(`\u2705 Section "${sectionName}" sauvegard\xE9e`);
    } catch (error) {
      console.error(`\u274C Erreur sauvegarde section "${sectionName}":`, error);
    }
  }
  showNoLayoutMessage() {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("no-layout-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-muted);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Pas de layout agile-board</h3>
        <p>Cette note n'a pas de layout agile-board configur\xE9</p>
        <p>Ajoutez dans le frontmatter:<br><code>agile-board: layout_eisenhower</code></p>
      </div>
    `;
  }
  showLayoutNotFoundMessage(layoutName) {
    this.contentEl.empty();
    const message = this.contentEl.createDiv("layout-not-found-message");
    message.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.2em;
      color: var(--text-error);
      text-align: center;
      padding: 2rem;
    `;
    message.innerHTML = `
      <div>
        <h3>\u274C Layout "${layoutName}" introuvable</h3>
        <p>Layouts disponibles: ${this.plugin.layoutService.getAllModelNames().join(", ")}</p>
      </div>
    `;
  }
  showMissingSectionsMessage(missingBlocks, layout) {
    this.contentEl.empty();
    const errorContainer = this.contentEl.createDiv("missing-sections-overlay");
    errorContainer.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      height: 100%;
      padding: 2rem;
      text-align: center;
      background: var(--background-primary);
    `;
    const title = errorContainer.createEl("h2");
    title.textContent = "\u{1F527} Sections manquantes d\xE9tect\xE9es";
    title.style.cssText = `
      color: var(--text-normal);
      margin-bottom: 1rem;
    `;
    const description = errorContainer.createEl("p");
    description.textContent = "Les sections suivantes sont requises pour ce layout :";
    description.style.cssText = `
      color: var(--text-muted);
      margin-bottom: 1rem;
    `;
    const sectionsList = errorContainer.createEl("ul");
    sectionsList.style.cssText = `
      list-style: none;
      padding: 0;
      margin: 1rem 0;
      color: var(--text-normal);
    `;
    missingBlocks.forEach((section) => {
      const listItem = sectionsList.createEl("li");
      listItem.textContent = `# ${section}`;
      listItem.style.cssText = `
        font-family: var(--font-monospace);
        background: var(--background-secondary);
        padding: 0.5rem;
        margin: 0.25rem 0;
        border-radius: 4px;
      `;
    });
    const buttonContainer = errorContainer.createDiv();
    buttonContainer.style.cssText = `
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    `;
    const autoCreateButton = buttonContainer.createEl("button", { cls: "mod-cta" });
    autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
    autoCreateButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--interactive-accent);
      color: var(--text-on-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    autoCreateButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      console.log("\u{1F527} Cr\xE9ation automatique des sections manquantes...");
      autoCreateButton.textContent = "\u23F3 Cr\xE9ation...";
      autoCreateButton.disabled = true;
      try {
        await this.plugin.fileService.createMissingSections(this.file, layout);
        console.log("\u2705 Sections cr\xE9\xE9es, rechargement du board...");
        setTimeout(() => {
          this.renderBoardLayout();
        }, 500);
      } catch (error) {
        console.error("\u274C Erreur cr\xE9ation sections:", error);
        autoCreateButton.textContent = "\u274C Erreur";
        setTimeout(() => {
          autoCreateButton.textContent = "\u2728 Cr\xE9er automatiquement";
          autoCreateButton.disabled = false;
        }, 2e3);
      }
    });
    const markdownButton = buttonContainer.createEl("button");
    markdownButton.textContent = "\u{1F4DD} Mode Markdown";
    markdownButton.style.cssText = `
      padding: 0.75rem 1.5rem;
      background: var(--background-secondary);
      color: var(--text-normal);
      border: 1px solid var(--background-modifier-border);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    `;
    markdownButton.addEventListener("click", async () => {
      if (!this.file)
        return;
      const leaf = this.app.workspace.activeLeaf;
      if (leaf) {
        await leaf.setViewState({
          type: "markdown",
          state: { file: this.file.path }
        });
      }
    });
  }
};

// src/managers/ViewSwitcher.ts
var import_obsidian2 = require("obsidian");
var ViewSwitcher = class {
  /**
   * CONSTRUCTEUR avec injection de dépendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * INJECTION DE DÉPENDANCE :
   * Le plugin donne accès à :
   * - app : Instance Obsidian pour les opérations
   * - layoutService : Pour vérifier les layouts disponibles
   * - registerEvent : Pour s'abonner aux événements
   */
  constructor(plugin) {
    this.plugin = plugin;
  }
  // ===========================================================================
  // MÉTHODES DE BASCULEMENT ENTRE VUES
  // ===========================================================================
  /**
   * Bascule vers la vue Board pour un fichier donné
   * 
   * PROCESSUS :
   * 1. Obtenir l'onglet actif (activeLeaf)
   * 2. Changer son type de vue vers BOARD_VIEW_TYPE
   * 3. Passer le chemin du fichier en paramètre d'état
   * 
   * CONCEPT OBSIDIAN - SETVIEWSTATE :
   * setViewState permet de changer complètement le type de vue d'un onglet.
   * C'est comme transformer un onglet "texte" en onglet "image" par exemple.
   * 
   * @param file - Fichier à afficher en mode Board
   * 
   * @example
   * // L'utilisateur clique sur le bouton "Mode Board"
   * viewSwitcher.switchToBoardView(currentFile);
   * // L'onglet passe de MarkdownView à BoardView
   */
  async switchToBoardView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: BOARD_VIEW_TYPE,
        // Notre type de vue personnalisé
        state: { file: file.path }
        // État initial : quel fichier afficher
      });
      console.log("\u{1F3AF} Basculement vers Board View");
    }
  }
  /**
   * Bascule vers la vue Markdown standard pour un fichier donné
   * 
   * PROCESSUS INVERSE :
   * Même principe que switchToBoardView mais vers la vue standard d'Obsidian.
   * 
   * @param file - Fichier à afficher en mode Markdown
   * 
   * @example
   * // L'utilisateur clique sur le bouton "Mode Markdown"
   * viewSwitcher.switchToMarkdownView(currentFile);
   * // L'onglet passe de BoardView à MarkdownView
   */
  async switchToMarkdownView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      await activeLeaf.setViewState({
        type: "markdown",
        // Type de vue standard d'Obsidian
        state: { file: file.path }
        // Même fichier, vue différente
      });
      console.log("\u{1F4DD} Basculement vers Markdown View");
    }
  }
  // ===========================================================================
  // MÉTHODES DE DÉTECTION DE CONTEXTE
  // ===========================================================================
  /**
   * Vérifie si la vue actuelle est notre BoardView
   * 
   * UTILITÉ :
   * Permet de savoir quel bouton afficher (Board → Markdown ou Markdown → Board).
   * 
   * MÉTHODE OBSIDIAN :
   * getActiveViewOfType() cherche une vue d'un type spécifique dans l'espace de travail.
   * Retourne l'instance ou null si aucune vue de ce type n'est active.
   * 
   * @returns boolean - true si on est en mode Board
   * 
   * @example
   * if (viewSwitcher.isCurrentViewBoardView()) {
   *   showMarkdownButton();
   * } else {
   *   showBoardButton();
   * }
   */
  isCurrentViewBoardView() {
    return this.plugin.app.workspace.getActiveViewOfType(BoardView) !== null;
  }
  /**
   * Vérifie si la vue actuelle est la MarkdownView standard
   * 
   * COMPLÉMENT DE isCurrentViewBoardView :
   * Ces deux méthodes permettent de couvrir tous les cas de figure.
   * 
   * @returns boolean - true si on est en mode Markdown
   */
  isCurrentViewMarkdownView() {
    return this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView) !== null;
  }
  /**
   * Vérifie si un fichier a un layout agile-board configuré
   * 
   * LOGIQUE MÉTIER :
   * - Seuls les fichiers avec layout agile-board peuvent utiliser la vue Board
   * - Cette vérification détermine si les boutons doivent être affichés
   * 
   * ACCÈS AUX MÉTADONNÉES :
   * - metadataCache : Cache des métadonnées des fichiers
   * - getFileCache : Obtient les métadonnées d'un fichier
   * - frontmatter : Bloc YAML en début de fichier
   * 
   * @param file - Fichier à vérifier
   * @returns boolean - true si le fichier a un layout agile-board
   * 
   * @example
   * // Fichier avec frontmatter :
   * // ---
   * // agile-board: layout_eisenhower
   * // ---
   * hasAgileBoardLayout(file); // true
   * 
   * // Fichier normal sans frontmatter
   * hasAgileBoardLayout(file); // false
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    return ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]) !== void 0;
  }
  // ===========================================================================
  // MÉTHODES DE GESTION DES BOUTONS D'INTERFACE
  // ===========================================================================
  /**
   * Configure les écouteurs d'événements pour la gestion automatique des boutons
   * 
   * ÉVÉNEMENTS OBSIDIAN SURVEILLÉS :
   * 1. active-leaf-change : Changement d'onglet actif
   * 2. file-open : Ouverture d'un nouveau fichier
   * 3. metadataCache.on('changed') : Modification des métadonnées
   * 
   * PATTERN OBSERVER :
   * S'abonne aux événements système plutôt que de sonder constamment.
   * Plus efficace et réactif.
   * 
   * DÉLAIS (setTimeout) :
   * Petits délais pour laisser le temps à Obsidian de finaliser les changements
   * avant de mettre à jour l'interface.
   * 
   * @example
   * viewSwitcher.addSwitchButton();
   * // À partir de maintenant, les boutons apparaissent/disparaissent automatiquement
   */
  addSwitchButton() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", () => {
        setTimeout(() => this.updateSwitchButton(), 50);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.path === file.path) {
          setTimeout(() => this.updateSwitchButtonForFile(file), 100);
        }
      })
    );
    setTimeout(() => this.updateSwitchButton(), 100);
  }
  /**
   * Met à jour les boutons pour un fichier spécifique
   * 
   * UTILISATION :
   * Appelée depuis l'extérieur (ModelDetector) quand un changement est détecté.
   * Version optimisée qui évite de re-analyser le contexte.
   * 
   * @param file - Fichier pour lequel mettre à jour les boutons
   */
  updateSwitchButtonForFile(file) {
    const hasLayout = this.hasAgileBoardLayout(file);
    if (hasLayout) {
      if (this.isCurrentViewMarkdownView()) {
        this.ensureBoardModeButton();
      } else if (this.isCurrentViewBoardView()) {
        this.ensureNormalModeButton();
      }
    } else {
      this.removeSwitchButtons();
    }
  }
  /**
   * Met à jour les boutons selon le contexte actuel
   * 
   * LOGIQUE GLOBALE :
   * 1. Identifier le fichier actif
   * 2. Vérifier s'il a un layout agile-board
   * 3. Déterminer la vue actuelle
   * 4. Afficher le bouton approprié
   * 
   * MÉTHODE PRINCIPALE :
   * Point d'entrée pour toutes les mises à jour automatiques.
   */
  updateSwitchButton() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const hasLayout = this.hasAgileBoardLayout(activeFile);
    if (!hasLayout) {
      this.removeSwitchButtons();
      return;
    }
    if (this.isCurrentViewMarkdownView()) {
      this.ensureBoardModeButton();
    } else if (this.isCurrentViewBoardView()) {
      this.ensureNormalModeButton();
    } else {
      this.removeSwitchButtons();
    }
  }
  /**
   * S'assure qu'un bouton "Mode Board" est présent en vue Markdown
   * 
   * PROCESSUS :
   * 1. Trouver la vue Markdown active
   * 2. Localiser la zone des actions de vue (.view-actions)
   * 3. Supprimer le bouton existant s'il y en a un
   * 4. Créer et configurer le nouveau bouton
   * 5. Ajouter les styles et l'événement click
   * 
   * GESTION D'ERREURS :
   * Try-catch pour éviter que les erreurs d'interface cassent le plugin.
   * 
   * CONCEPT OBSIDIAN - addAction :
   * addAction() est la méthode officielle pour ajouter des boutons aux vues.
   * Paramètres : (icône, tooltip, callback)
   */
  ensureBoardModeButton() {
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!markdownView)
      return;
    const viewActions = markdownView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = markdownView.addAction("layout-grid", "Mode Board", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToBoardView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "board-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Board ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Board:", error);
    }
  }
  /**
   * S'assure qu'un bouton "Mode Markdown" est présent en vue Board
   * 
   * PROCESSUS SIMILAIRE à ensureBoardModeButton mais pour BoardView.
   * 
   * DIFFÉRENCES :
   * - Utilise getActiveViewOfType(BoardView)
   * - Icône 'document' au lieu de 'layout-grid'
   * - Callback vers switchToMarkdownView
   */
  ensureNormalModeButton() {
    const boardView = this.plugin.app.workspace.getActiveViewOfType(BoardView);
    if (!boardView)
      return;
    const viewActions = boardView.containerEl.querySelector(".view-actions");
    if (!viewActions)
      return;
    const existingButton = viewActions.querySelector(".agile-board-switch-button");
    if (existingButton) {
      existingButton.remove();
    }
    try {
      const button = boardView.addAction("document", "Mode Markdown", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.switchToMarkdownView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "normal-mode");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      console.log("\u{1F518} Bouton Mode Markdown ajout\xE9");
    } catch (error) {
      console.error("Erreur lors de l'ajout du bouton Mode Markdown:", error);
    }
  }
  /**
   * Supprime tous les boutons de basculement de l'interface
   * 
   * UTILISATION :
   * - Quand on ouvre un fichier sans layout agile-board
   * - Quand on bascule vers une vue non supportée
   * - Lors du nettoyage du plugin
   * 
   * SÉLECTEUR GLOBAL :
   * Utilise document.querySelectorAll pour trouver tous les boutons,
   * même s'ils sont dans des onglets différents.
   * 
   * CLASSE IDENTIFICATRICE :
   * Tous nos boutons ont la classe 'agile-board-switch-button'
   * pour un nettoyage facile et sûr.
   */
  removeSwitchButtons() {
    const buttons = document.querySelectorAll(".agile-board-switch-button");
    buttons.forEach((button) => button.remove());
  }
  // ===========================================================================
  // MÉTHODES DE CYCLE DE VIE
  // ===========================================================================
  /**
   * Nettoie les ressources utilisées par le ViewSwitcher
   * 
   * APPELÉE PAR :
   * Le plugin principal lors de son déchargement (onunload).
   * 
   * NETTOYAGE :
   * - Supprime tous les boutons de l'interface
   * - Les écouteurs d'événements sont automatiquement nettoyés par Obsidian
   *   grâce à registerEvent() utilisé dans addSwitchButton()
   * 
   * IMPORTANCE :
   * Évite les fuites mémoire et les boutons orphelins dans l'interface.
   */
  stop() {
    this.removeSwitchButtons();
  }
};

// src/managers/ModelDetector.ts
var ModelDetector = class {
  /**
   * CONSTRUCTEUR avec injection de dépendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * DÉPENDANCES UTILISÉES :
   * - plugin.app : Pour accéder aux APIs Obsidian
   * - plugin.layoutService : Pour valider les layouts
   * - plugin.viewSwitcher : Pour mettre à jour l'interface
   * - plugin.registerEvent : Pour l'abonnement sécurisé aux événements
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Cache des fichiers déjà traités
     * 
     * STRUCTURE DE DONNÉES :
     * Set<string> pour un accès O(1) et éviter les doublons.
     * 
     * CLÉ DE CACHE :
     * "chemin-du-fichier-timestamp" pour invalidation automatique
     * quand le fichier est modifié.
     * 
     * AVANTAGES :
     * - Évite les retraitements inutiles
     * - Performance optimisée pour les gros vaults
     * - Invalidation automatique lors des modifications
     */
    this.processedFiles = /* @__PURE__ */ new Set();
  }
  // ===========================================================================
  // MÉTHODES DE CYCLE DE VIE
  // ===========================================================================
  /**
   * Initialise la surveillance des événements Obsidian
   * 
   * ÉVÉNEMENTS SURVEILLÉS :
   * 1. metadataCache.on('changed') : Modification des métadonnées
   * 2. workspace.on('file-open') : Ouverture de fichier
   * 3. workspace.on('active-leaf-change') : Changement d'onglet actif
   * 
   * DÉLAIS D'INITIALISATION :
   * Délai de 1 seconde pour laisser Obsidian finir son initialisation
   * avant de traiter les fichiers déjà ouverts.
   * 
   * PATTERN REGISTER-EVENT :
   * Utilise plugin.registerEvent() pour un nettoyage automatique
   * des écouteurs lors du déchargement du plugin.
   * 
   * @example
   * modelDetector.onLoad();
   * // À partir de maintenant, les changements sont détectés automatiquement
   */
  onLoad() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        this.handleMetadataChanged(file);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          if (activeFile) {
            this.handleFileOpen(activeFile);
          }
        }, 100);
      })
    );
    setTimeout(() => {
      this.processAllOpenFiles();
    }, 1e3);
  }
  /**
   * Nettoie les ressources utilisées par le détecteur
   * 
   * APPELÉE PAR :
   * Le plugin principal lors de son déchargement (onunload).
   * 
   * NETTOYAGE :
   * - Vide le cache des fichiers traités
   * - Les écouteurs d'événements sont automatiquement nettoyés par Obsidian
   * 
   * IMPORTANCE :
   * Évite les fuites mémoire et prépare un rechargement propre du plugin.
   */
  onUnload() {
    this.processedFiles.clear();
  }
  // ===========================================================================
  // GESTIONNAIRES D'ÉVÉNEMENTS PRIVÉS
  // ===========================================================================
  /**
   * Gère les changements de métadonnées d'un fichier
   * 
   * DÉCLENCHEMENT :
   * Quand l'utilisateur modifie le frontmatter d'un fichier.
   * Par exemple, ajouter ou changer "agile-board: layout_kanban".
   * 
   * LOGIQUE :
   * Les métadonnées changées peuvent affecter l'affichage des boutons,
   * donc on relance le traitement du fichier.
   * 
   * @param file - Fichier dont les métadonnées ont changé
   * 
   * @example
   * // L'utilisateur ajoute dans le frontmatter :
   * // agile-board: layout_eisenhower
   * // → handleMetadataChanged() est appelée
   * // → Les boutons de basculement apparaissent
   */
  handleMetadataChanged(file) {
    console.log("\u{1F4DD} M\xE9tadonn\xE9es chang\xE9es pour:", file.basename);
    this.processFile(file);
  }
  /**
   * Gère l'ouverture d'un fichier
   * 
   * DÉCLENCHEMENT :
   * - Ouverture d'un nouveau fichier
   * - Basculement vers un onglet existant
   * - Navigation par liens internes
   * 
   * @param file - Fichier qui vient d'être ouvert/activé
   */
  handleFileOpen(file) {
    console.log("\u{1F4C2} Fichier ouvert:", file.basename);
    this.processFile(file);
  }
  /**
   * Traite tous les fichiers déjà ouverts au démarrage
   * 
   * UTILISATION :
   * Appelée une fois lors de l'initialisation pour traiter les fichiers
   * qui étaient déjà ouverts avant l'activation du plugin.
   * 
   * MÉTHODE OBSIDIAN :
   * iterateAllLeaves() parcourt tous les onglets ouverts dans l'espace de travail.
   * 
   * FILTRAGE :
   * Seuls les onglets avec vue markdown et fichier valide sont traités.
   * 
   * @example
   * // Au démarrage d'Obsidian avec 3 fichiers ouverts :
   * // processAllOpenFiles() va traiter les 3 fichiers
   * // et afficher les boutons appropriés
   */
  processAllOpenFiles() {
    console.log("\u{1F50D} Traitement initial de tous les fichiers ouverts...");
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === "markdown" && view.file) {
        this.processFile(view.file);
      }
    });
  }
  // ===========================================================================
  // LOGIQUE MÉTIER PRINCIPALE
  // ===========================================================================
  /**
   * Traite un fichier individuel et met à jour l'interface si nécessaire
   * 
   * ALGORITHME :
   * 1. Filtrer les fichiers non-markdown
   * 2. Générer une clé de cache unique
   * 3. Vérifier si déjà traité (cache hit)
   * 4. Détecter si le fichier a un layout agile-board
   * 5. Mettre à jour l'interface via ViewSwitcher
   * 6. Nettoyer le cache si nécessaire
   * 
   * OPTIMISATION DE CACHE :
   * La clé inclut le timestamp de modification (mtime) pour invalider
   * automatiquement le cache quand le fichier change.
   * 
   * @param file - Fichier à traiter
   * 
   * @example
   * // Première fois : traitement complet
   * processFile(myFile); // Cache miss → traitement
   * 
   * // Deuxième fois (fichier inchangé) : cache hit
   * processFile(myFile); // Cache hit → pas de traitement
   * 
   * // Après modification du fichier : cache invalidé
   * processFile(myFile); // Cache miss → traitement
   */
  processFile(file) {
    if (!file.path.endsWith(".md"))
      return;
    const fileKey = `${file.path}-${file.stat.mtime}`;
    if (this.processedFiles.has(fileKey))
      return;
    this.processedFiles.add(fileKey);
    this.cleanupProcessedFiles();
    const hasLayout = this.hasAgileBoardLayout(file);
    console.log(`\u{1F3AF} Fichier "${file.basename}" - Layout agile-board: ${hasLayout ? "OUI" : "NON"}`);
    setTimeout(() => {
      this.plugin.viewSwitcher.updateSwitchButtonForFile(file);
    }, 50);
  }
  /**
   * Vérifie si un fichier a un layout agile-board valide
   * 
   * VALIDATION EN DEUX ÉTAPES :
   * 1. Vérifier la présence du champ 'agile-board' dans le frontmatter
   * 2. Vérifier que le layout existe dans le LayoutService
   * 
   * GESTION D'ERREURS :
   * Si un layout est spécifié mais n'existe pas, log un warning
   * mais retourne false (traitement gracieux).
   * 
   * @param file - Fichier à vérifier
   * @returns boolean - true si le fichier a un layout valide
   * 
   * @example
   * // Fichier avec frontmatter valide :
   * // ---
   * // agile-board: layout_eisenhower
   * // ---
   * hasAgileBoardLayout(file); // true
   * 
   * // Fichier avec layout inexistant :
   * // ---
   * // agile-board: layout_inexistant
   * // ---
   * hasAgileBoardLayout(file); // false + warning
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return false;
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      console.warn(`\u26A0\uFE0F Layout "${layoutName}" sp\xE9cifi\xE9 mais non trouv\xE9`);
      return false;
    }
    return true;
  }
  // ===========================================================================
  // GESTION DU CACHE ET OPTIMISATIONS
  // ===========================================================================
  /**
   * Nettoie le cache pour éviter une croissance excessive
   * 
   * STRATÉGIE DE NETTOYAGE :
   * - Limite : 100 entrées maximum dans le cache
   * - Méthode : Garder les 50 entrées les plus récentes
   * - Déclenchement : À chaque ajout dans le cache
   * 
   * POURQUOI NETTOYER :
   * - Éviter la fuite mémoire avec de gros vaults
   * - Maintenir des performances optimales
   * - Les anciennes entrées sont probablement obsolètes
   * 
   * ALGORITHME LRU SIMPLE :
   * Les entrées sont dans l'ordre d'insertion dans le Set.
   * On garde les dernières ajoutées (= les plus récemment utilisées).
   * 
   * @example
   * // Cache avec 100+ entrées
   * cleanupProcessedFiles();
   * // → Cache réduit à 50 entrées les plus récentes
   */
  cleanupProcessedFiles() {
    if (this.processedFiles.size > 100) {
      const entries = Array.from(this.processedFiles);
      const toKeep = entries.slice(-50);
      this.processedFiles.clear();
      toKeep.forEach((entry) => this.processedFiles.add(entry));
      console.log("\u{1F9F9} Cache nettoy\xE9: gard\xE9 50 entr\xE9es sur", entries.length);
    }
  }
  // ===========================================================================
  // MÉTHODES UTILITAIRES PUBLIQUES
  // ===========================================================================
  /**
   * Force une mise à jour complète de tous les fichiers ouverts
   * 
   * UTILISATION :
   * - Commande de débogage
   * - Après rechargement de layouts
   * - Récupération d'état incohérent
   * 
   * PROCESSUS :
   * 1. Vider complètement le cache
   * 2. Retraiter tous les fichiers ouverts
   * 3. Mettre à jour toute l'interface
   * 
   * PERFORMANCE :
   * Opération coûteuse, à utiliser avec parcimonie.
   * 
   * @example
   * // L'utilisateur utilise la commande "Force Update Board Buttons"
   * modelDetector.forceUpdate();
   * // → Tous les boutons sont recalculés et mis à jour
   */
  forceUpdate() {
    this.processedFiles.clear();
    this.processAllOpenFiles();
    console.log("\u{1F504} Mise \xE0 jour forc\xE9e termin\xE9e");
  }
};

// src/types/index.ts
var DEFAULT_LAYOUTS = {
  EISENHOWER: "layout_eisenhower",
  KANBAN: "layout_kanban",
  GTD: "layout_gtd",
  WEEKLY: "layout_weekly",
  DAILY: "layout_daily"
};

// src/utils/settings.ts
function createDefaultSettings() {
  return {
    // Layout utilisé par défaut pour les nouvelles notes
    // Eisenhower est choisi car c'est un système de priorisation universel
    defaultModel: DEFAULT_LAYOUTS.EISENHOWER,
    // Activer le basculement automatique vers la vue board
    // Améliore l'expérience utilisateur en affichant directement le board
    autoSwitchEnabled: true,
    // Délai de 1 seconde avant sauvegarde automatique
    // Évite de sauvegarder à chaque frappe tout en restant réactif
    debounceDelay: 1e3
  };
}

// src/main.ts
var AgileBoardPlugin = class extends import_obsidian3.Plugin {
  // =============================================================================
  // MÉTHODES DU CYCLE DE VIE OBSIDIAN
  // =============================================================================
  /**
   * MÉTHODE onload() - Point d'entrée du plugin
   * 
   * CONCEPT OBSIDIAN :
   * Cette méthode est appelée automatiquement par Obsidian quand :
   * - L'utilisateur active le plugin
   * - Obsidian démarre avec le plugin déjà activé
   * 
   * RESPONSABILITÉS :
   * - Initialiser tous les composants du plugin
   * - Enregistrer les vues, commandes, et événements
   * - Préparer l'interface utilisateur
   * 
   * Le mot-clé "async" permet d'utiliser "await" pour les opérations asynchrones
   */
  async onload() {
    console.log("\u{1F680} Loading Agile Board Plugin...");
    try {
      await this.loadSettings();
      await this.initializeServices();
      this.registerView(
        BOARD_VIEW_TYPE,
        // Identifiant unique de la vue
        (leaf) => new BoardView(leaf, this)
        // Factory function pour créer la vue
      );
      await this.initializeManagers();
      this.registerCommands();
      this.addStatusBarItem().setText("Agile Board Ready");
      console.log("\u2705 Agile Board Plugin loaded successfully");
      console.log("\u{1F4CB} Layouts disponibles:", this.layoutService.getAllModelNames());
    } catch (error) {
      console.error("\u274C Erreur lors du chargement du plugin:", error);
    }
  }
  /**
   * MÉTHODE onunload() - Nettoyage du plugin
   * 
   * CONCEPT OBSIDIAN :
   * Cette méthode est appelée quand :
   * - L'utilisateur désactive le plugin
   * - Obsidian se ferme
   * - Le plugin est rechargé
   * 
   * RESPONSABILITÉS :
   * - Nettoyer les ressources utilisées
   * - Désactiver les gestionnaires d'événements
   * - Éviter les fuites mémoire
   */
  async onunload() {
    var _a, _b;
    console.log("\u{1F6D1} Unloading Agile Board Plugin...");
    (_a = this.modelDetector) == null ? void 0 : _a.onUnload();
    (_b = this.viewSwitcher) == null ? void 0 : _b.stop();
    console.log("\u2705 Agile Board Plugin unloaded");
  }
  // =============================================================================
  // MÉTHODES D'INITIALISATION PRIVÉES
  // =============================================================================
  /**
   * Initialise tous les services métier
   * 
   * PRINCIPE DE CONCEPTION :
   * - Les services sont initialisés avant les managers
   * - Chaque service reçoit les dépendances dont il a besoin
   * - L'ordre d'initialisation est important
   */
  async initializeServices() {
    this.layoutService = new LayoutService(this);
    this.layoutService.load();
    this.fileService = new FileService(this.app);
  }
  /**
   * Initialise tous les gestionnaires de fonctionnalités
   * 
   * ORDRE D'INITIALISATION :
   * 1. Créer les instances avec leurs dépendances
   * 2. Activer leurs fonctionnalités (boutons, surveillance, etc.)
   */
  async initializeManagers() {
    this.viewSwitcher = new ViewSwitcher(this);
    this.viewSwitcher.addSwitchButton();
    this.modelDetector = new ModelDetector(this);
    this.modelDetector.onLoad();
  }
  // =============================================================================
  // MÉTHODES D'ENREGISTREMENT DES COMMANDES
  // =============================================================================
  /**
   * Enregistre toutes les commandes du plugin
   * 
   * CONCEPT OBSIDIAN - COMMANDES :
   * Les commandes sont des actions que l'utilisateur peut déclencher via :
   * - La palette de commandes (Ctrl+P)
   * - Des raccourcis clavier personnalisés
   * - Des boutons dans l'interface
   */
  registerCommands() {
    this.addCommand({
      id: "switch-to-board-view",
      // Identifiant unique
      name: "Switch to Board View",
      // Nom affiché dans la palette
      callback: () => this.activateBoardView()
      // Fonction à exécuter
    });
    this.registerCreationCommands();
    this.registerUtilityCommands();
  }
  /**
   * Enregistre les commandes de création de notes avec layouts prédéfinis
   * 
   * PATTERN DE CONCEPTION :
   * - Définir une liste de layouts disponibles
   * - Créer dynamiquement une commande pour chaque layout
   * - Utiliser une convention de nommage cohérente
   */
  registerCreationCommands() {
    const layouts = [
      { id: "eisenhower", name: "Eisenhower Matrix" },
      { id: "kanban", name: "Kanban Board" },
      { id: "gtd", name: "GTD Board" },
      { id: "weekly", name: "Weekly Planner" },
      { id: "daily", name: "Daily Planner" },
      { id: "project", name: "Project Board" },
      { id: "simple", name: "Simple Board" },
      { id: "cornell", name: "Cornell Notes" },
      { id: "tasks-dashboard", name: "Tasks Dashboard" },
      { id: "dataview-analytics", name: "Dataview Analytics" }
    ];
    layouts.forEach((layout) => {
      this.addCommand({
        id: `create-${layout.id}-note`,
        // ID unique : create-kanban-note
        name: `Create ${layout.name} Note`,
        // Nom : Create Kanban Board Note
        callback: () => {
          const layoutName = `layout_${layout.id.replace("-", "_")}`;
          this.createNoteWithLayout(layoutName);
        }
      });
    });
  }
  /**
   * Enregistre les commandes utilitaires et de débogage
   * 
   * TYPES DE COMMANDES UTILITAIRES :
   * - Informations : Lister les layouts disponibles
   * - Maintenance : Créer les sections manquantes
   * - Débogage : Forcer la mise à jour des boutons
   */
  registerUtilityCommands() {
    this.addCommand({
      id: "list-layouts",
      name: "List Available Layouts",
      callback: () => this.showAvailableLayouts()
    });
    this.addCommand({
      id: "create-missing-sections",
      name: "Create Missing Sections for Current Layout",
      checkCallback: (checking) => {
        var _a;
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        const fileCache = this.app.metadataCache.getFileCache(activeFile);
        const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
        if (!layoutName)
          return false;
        if (!checking) {
          this.createMissingSectionsForCurrentFile();
        }
        return true;
      }
    });
    this.addCommand({
      id: "force-update-buttons",
      name: "Force Update Board Buttons",
      callback: () => {
        this.modelDetector.forceUpdate();
        console.log("\u{1F504} Boutons mis \xE0 jour manuellement");
      }
    });
  }
  // =============================================================================
  // MÉTHODES D'ACTION PUBLIQUES
  // =============================================================================
  /**
   * Active la vue Board pour le fichier actuellement ouvert
   * 
   * CONCEPT OBSIDIAN - WORKSPACES ET VUES :
   * - workspace : Gestion des onglets et panneaux
   * - leaf : Un onglet individuel dans l'interface
   * - setViewState : Changer le type de vue d'un onglet
   */
  async activateBoardView() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      console.log("\u274C Aucun fichier actif");
      return;
    }
    const leaf = this.app.workspace.activeLeaf;
    if (leaf) {
      await leaf.setViewState({
        type: BOARD_VIEW_TYPE,
        // Notre type de vue personnalisé
        state: { file: activeFile.path }
        // État initial : quel fichier afficher
      });
      console.log("\u{1F3AF} Basculement vers Board View pour:", activeFile.basename);
    }
  }
  /**
   * Crée une nouvelle note avec un layout spécifique
   * 
   * PROCESSUS DE CRÉATION :
   * 1. Vérifier que le layout existe
   * 2. Générer le contenu markdown avec frontmatter
   * 3. Créer le fichier dans le vault
   * 4. Ouvrir le fichier dans l'interface
   * 
   * @param layoutName - Nom du layout à utiliser (ex: "layout_eisenhower")
   */
  async createNoteWithLayout(layoutName) {
    const layout = this.layoutService.getModel(layoutName);
    if (!layout) {
      console.error(`\u274C Layout "${layoutName}" non trouv\xE9`);
      return;
    }
    const frontmatter = `---
agile-board: ${layoutName}
---

`;
    const sections = layout.map((block) => `# ${block.title}

`).join("");
    const content = frontmatter + sections;
    const layoutDisplayName = this.layoutService.getLayoutDisplayName(layoutName);
    const timestamp = new Date().toISOString().split("T")[0];
    const fileName = `${layoutDisplayName} ${timestamp}.md`;
    try {
      const file = await this.app.vault.create(fileName, content);
      await this.app.workspace.getLeaf().openFile(file);
      console.log(`\u2705 Note "${fileName}" cr\xE9\xE9e avec layout ${layoutName}`);
    } catch (error) {
      console.error(`\u274C Erreur cr\xE9ation note:`, error);
    }
  }
  // =============================================================================
  // MÉTHODES D'INTERFACE UTILISATEUR
  // =============================================================================
  /**
   * Affiche une modale avec la liste des layouts disponibles
   * 
   * CONCEPT OBSIDIAN - MODALES :
   * Une modale est une fenêtre popup qui s'affiche par-dessus l'interface
   */
  showAvailableLayouts() {
    const layouts = this.layoutService.getAllModelsInfo();
    let message = "Layouts disponibles :\n\n";
    layouts.forEach((layout) => {
      message += `\u2022 **${layout.displayName}** (${layout.blockCount} sections)
`;
      message += `  Sections: ${layout.sections.join(", ")}

`;
    });
    const modal = new (require("obsidian")).Modal(this.app);
    modal.contentEl.innerHTML = `
      <h2>Layouts Agile Board</h2>
      <div style="white-space: pre-wrap; font-family: var(--font-text);">${message}</div>
    `;
    modal.open();
  }
  /**
   * Crée les sections manquantes pour le fichier actuellement ouvert
   * 
   * PROCESSUS :
   * 1. Vérifier le contexte (fichier actif avec layout)
   * 2. Déléguer au FileService pour créer les sections
   * 3. Rafraîchir la vue Board si nécessaire
   */
  async createMissingSectionsForCurrentFile() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const fileCache = this.app.metadataCache.getFileCache(activeFile);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return;
    const layout = this.layoutService.getModel(layoutName);
    if (!layout)
      return;
    try {
      const sectionsCreated = await this.fileService.createMissingSections(activeFile, layout);
      if (sectionsCreated) {
        console.log("\u2705 Sections manquantes cr\xE9\xE9es pour:", activeFile.basename);
        const boardView = this.app.workspace.getActiveViewOfType(BoardView);
        if (boardView) {
          setTimeout(() => {
            boardView.renderBoardLayout();
          }, 500);
        }
      } else {
        console.log("\u2139\uFE0F Aucune section manquante \xE0 cr\xE9er");
      }
    } catch (error) {
      console.error("\u274C Erreur lors de la cr\xE9ation des sections:", error);
    }
  }
  // =============================================================================
  // MÉTHODES DE GESTION DES PARAMÈTRES
  // =============================================================================
  /**
   * Charge les paramètres du plugin depuis le stockage d'Obsidian
   * 
   * CONCEPT OBSIDIAN - PERSISTANCE :
   * - loadData() : Récupère les données sauvegardées du plugin
   * - Les données sont stockées dans .obsidian/plugins/[plugin-id]/data.json
   * - Object.assign() fusionne les paramètres par défaut avec les sauvegardés
   */
  async loadSettings() {
    this.settings = Object.assign(
      {},
      // Objet de base vide
      createDefaultSettings(),
      // Paramètres par défaut
      await this.loadData()
      // Paramètres sauvegardés (peuvent être null)
    );
  }
  /**
   * Sauvegarde les paramètres actuels du plugin
   * 
   * UTILISATION :
   * Appelée chaque fois que l'utilisateur modifie un paramètre
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
