/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AgileBoardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/types.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["NONE"] = 0] = "NONE";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 3] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 4] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 5] = "VERBOSE";
  return LogLevel2;
})(LogLevel || {});

// src/services/LoggerService.ts
var LoggerService = class {
  // Buffer de strings
  constructor(plugin, settings) {
    this.logBuffer = [];
    this.plugin = plugin;
    this.settings = settings;
  }
  /**
   * Met Ã  jour les paramÃ¨tres de debug
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  safeStringify(data, maxLength = 500) {
    if (!data)
      return "";
    try {
      let result = JSON.stringify(data);
      if (result.length > maxLength) {
        result = result.substring(0, maxLength) + "...[truncated]";
      }
      return result;
    } catch (error) {
      return "[unstringifiable object]";
    }
  }
  /**
   * Ajoute un message au buffer
   */
  addToBuffer(level, message, data, source) {
    const now = new Date();
    const pad = (num) => num.toString().padStart(2, "0");
    const timestamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    const levelStr = LogLevel[level];
    const dataStr = data ? ` | Data: ${this.safeStringify(data)}` : "";
    const sourceStr = source ? ` | Source: ${source}` : "";
    const logEntry = `[${timestamp}] ${levelStr}: ${message}${dataStr}${sourceStr}`;
    this.logBuffer.push(logEntry);
    if (this.logBuffer.length > 1e3) {
      this.logBuffer = this.logBuffer.slice(-500);
    }
  }
  /**
   * Log d'erreur
   */
  error(message, error, source) {
    if (!this.settings.enabled || this.settings.logLevel < 1 /* ERROR */)
      return;
    this.addToBuffer(1 /* ERROR */, message, error, source);
    if (this.settings.logToConsole) {
      console.error(`\u274C [Agile-Board] ${message}`, error);
    }
  }
  /**
   * Log d'avertissement
   */
  warn(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 2 /* WARN */)
      return;
    this.addToBuffer(2 /* WARN */, message, data, source);
    if (this.settings.logToConsole) {
      console.warn(`\u26A0\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log d'information
   */
  info(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 3 /* INFO */)
      return;
    this.addToBuffer(3 /* INFO */, message, data, source);
    if (this.settings.logToConsole) {
      console.info(`\u2139\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de debug
   */
  debug(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 4 /* DEBUG */)
      return;
    this.addToBuffer(4 /* DEBUG */, message, data, source);
    if (this.settings.logToConsole) {
      console.debug(`\u{1F527} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log verbose
   */
  verbose(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 5 /* VERBOSE */)
      return;
    this.addToBuffer(5 /* VERBOSE */, message, data, source);
    if (this.settings.logToConsole) {
      console.debug(`\u{1F50D} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de dÃ©marrage (toujours affichÃ©)
   */
  startup(message, data) {
    this.addToBuffer(3 /* INFO */, `STARTUP: ${message}`, data, "startup");
    console.log(`\u{1F680} [Agile-Board] ${message}`, data);
  }
  /**
   * Log de succÃ¨s
   */
  success(message, data, source) {
    if (!this.settings.enabled || this.settings.logLevel < 3 /* INFO */)
      return;
    this.addToBuffer(3 /* INFO */, `SUCCESS: ${message}`, data, source);
    if (this.settings.logToConsole) {
      console.log(`\u2705 [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de configuration
   */
  config(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 4 /* DEBUG */)
      return;
    this.addToBuffer(4 /* DEBUG */, `CONFIG: ${message}`, data, "config");
    if (this.settings.logToConsole) {
      console.debug(`\u2699\uFE0F [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log de navigation
   */
  navigation(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 5 /* VERBOSE */)
      return;
    this.addToBuffer(5 /* VERBOSE */, `NAV: ${message}`, data, "navigation");
    if (this.settings.logToConsole) {
      console.debug(`\u{1F9ED} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Log d'opÃ©ration sur fichier
   */
  fileOperation(message, data) {
    if (!this.settings.enabled || this.settings.logLevel < 4 /* DEBUG */)
      return;
    this.addToBuffer(4 /* DEBUG */, `FILE: ${message}`, data, "file");
    if (this.settings.logToConsole) {
      console.debug(`\u{1F4C1} [Agile-Board] ${message}`, data);
    }
  }
  /**
   * Test du systÃ¨me de logging
   */
  testSystem() {
    this.info("Test du syst\xE8me de logging lanc\xE9");
    this.debug("Message de debug test");
    this.verbose("Message verbeux test");
    this.warn("Message d'avertissement test");
    this.error("Message d'erreur test (test uniquement)");
    this.success("Test du syst\xE8me de logging termin\xE9");
  }
  /**
   * Retourne les statistiques du logger
   */
  getStats() {
    return {
      totalLogs: this.logBuffer.length,
      // Pour un buffer de strings, on analyse le contenu pour compter par type
      errorCount: this.logBuffer.filter(
        (log) => log.includes("ERROR:") || log.includes("\u274C") || log.includes("Message d'erreur")
      ).length,
      warningCount: this.logBuffer.filter(
        (log) => log.includes("WARN:") || log.includes("\u26A0\uFE0F") || log.includes("Message d'avertissement")
      ).length,
      debugCount: this.logBuffer.filter(
        (log) => log.includes("DEBUG:") || log.includes("\u{1F527}") || log.includes("VERBOSE:") || log.includes("\u{1F50D}")
      ).length,
      lastLogTime: new Date().toISOString(),
      // Timestamp actuel
      bufferSize: this.logBuffer.length,
      isEnabled: this.settings.enabled,
      currentLevel: LogLevel[this.settings.logLevel],
      fileLoggingEnabled: this.settings.logToFile
    };
  }
  /**
   * Vide le buffer de logs
   */
  clearBuffer() {
    this.logBuffer.length = 0;
    this.debug("Buffer de logs vid\xE9");
  }
  /**
   * Retourne tout le contenu du buffer
   */
  getBuffer() {
    return [...this.logBuffer];
  }
  /**
   * Sauvegarde les logs dans un fichier
   */
  async saveLogsToFile() {
    if (!this.settings.logToFile || this.logBuffer.length === 0) {
      return;
    }
    try {
      const fileName = this.settings.logFileName || "agile-board-debug.log";
      const content = this.logBuffer.join("\n");
      const adapter = this.plugin.app.vault.adapter;
      const exists = await adapter.exists(fileName);
      if (exists) {
        const existingContent = await adapter.read(fileName);
        const newContent = existingContent + "\n" + content;
        if (newContent.length > (this.settings.maxLogFileSize || 5 * 1024 * 1024)) {
          const lines = newContent.split("\n");
          const halfLines = lines.slice(Math.floor(lines.length / 2));
          await adapter.write(fileName, halfLines.join("\n"));
        } else {
          await adapter.write(fileName, newContent);
        }
      } else {
        await adapter.write(fileName, content);
      }
      this.debug(`Logs sauvegard\xE9s dans ${fileName} (${this.logBuffer.length} entr\xE9es)`);
    } catch (error) {
      console.error("[Agile-Board] Erreur lors de la sauvegarde des logs:", error);
    }
  }
  /**
   * Formate un message de log avec horodatage et source
   */
  formatLogMessage(level, message, source) {
    const timestamp = this.settings.showTimestamps ? `[${new Date().toISOString()}] ` : "";
    const sourceStr = this.settings.showSourceLocation && source ? ` (${source})` : "";
    const levelStr = LogLevel[level];
    return `${timestamp}${levelStr}: ${message}${sourceStr}`;
  }
  /**
   * Retourne la configuration actuelle
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Active ou dÃ©sactive le logging
   */
  setEnabled(enabled) {
    this.settings.enabled = enabled;
    this.config(`Logging ${enabled ? "activ\xE9" : "d\xE9sactiv\xE9"}`);
  }
  /**
   * Change le niveau de log
   */
  setLogLevel(level) {
    this.settings.logLevel = level;
    this.config(`Niveau de log chang\xE9 vers: ${LogLevel[level]}`);
  }
};

// src/constants/layouts.ts
var BUILT_IN_LAYOUTS = {
  // ===========================================================================
  // SECTION 1 : LAYOUTS DE PRODUCTIVITÃ‰ ET PRIORISATION
  // ===========================================================================
  /**
   * MATRICE D'EISENHOWER - SystÃ¨me de priorisation prÃ©sidentiel
   * 
   * MÃ‰THODOLOGIE :
   * CrÃ©Ã©e par le prÃ©sident Dwight D. Eisenhower, cette matrice classe
   * les tÃ¢ches selon deux axes orthogonaux : Urgent vs Important.
   * 
   * PHILOSOPHIE :
   * "Ce qui est important est rarement urgent et ce qui est urgent 
   * est rarement important." - Eisenhower
   * 
   * QUADRANTS :
   * 1. Urgent ET Important (Q1) â†’ FAIRE immÃ©diatement
   * 2. Important mais PAS Urgent (Q2) â†’ PLANIFIER (zone optimale)
   * 3. Urgent mais PAS Important (Q3) â†’ DÃ‰LÃ‰GUER
   * 4. NI Urgent NI Important (Q4) â†’ Ã‰LIMINER
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ URGENT ET       â”‚ PAS URGENT      â”‚
   * â”‚ IMPORTANT       â”‚ MAIS IMPORTANT  â”‚
   * â”‚ âš¡ DO NOW âš¡    â”‚ ğŸ“… SCHEDULE ğŸ“…  â”‚
   * â”‚ (Crises,        â”‚ (Planification, â”‚
   * â”‚  Urgences)      â”‚  PrÃ©vention)    â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ URGENT MAIS     â”‚ NI URGENT       â”‚
   * â”‚ PAS IMPORTANT   â”‚ NI IMPORTANT    â”‚
   * â”‚ ğŸ‘¥ DELEGATE ğŸ‘¥  â”‚ ğŸ—‘ï¸ DELETE ğŸ—‘ï¸   â”‚
   * â”‚ (Interruptions, â”‚ (Distractions,  â”‚
   * â”‚  Certains mails)â”‚  RÃ©seaux soc.)  â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 4 quadrants de 12Ã—12 chacun
   * CAS D'USAGE : Gestion quotidienne, dÃ©cisions stratÃ©giques, leadership
   */
  layout_eisenhower: [
    {
      title: "Urgent et Important",
      x: 0,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q1 : Actions immÃ©diates, gestion de crise
    },
    {
      title: "Pas urgent mais Important",
      x: 12,
      y: 0,
      w: 12,
      h: 12
      // Quadrant Q2 : Zone optimale de productivitÃ©, planification
    },
    {
      title: "Urgent mais Pas important",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q3 : Candidats Ã  la dÃ©lÃ©gation
    },
    {
      title: "Ni urgent ni important",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // Quadrant Q4 : ActivitÃ©s Ã  Ã©liminer ou rÃ©duire
    }
  ],
  /**
   * GETTING THINGS DONE (GTD) - MÃ©thode David Allen
   * 
   * MÃ‰THODOLOGIE :
   * SystÃ¨me complet de productivitÃ© dÃ©veloppÃ© par David Allen.
   * BasÃ© sur l'externalisation de la mÃ©moire et la clarification systÃ©matique.
   * 
   * PRINCIPE CENTRAL :
   * "Votre esprit est fait pour avoir des idÃ©es, pas pour les retenir."
   * 
   * FLUX GTD :
   * CAPTURER â†’ CLARIFIER â†’ ORGANISER â†’ RÃ‰VISER â†’ FAIRE
   * 
   * ZONES FONCTIONNELLES :
   * 1. Inbox : Capture de tout ce qui arrive
   * 2. Actions suivantes : TÃ¢ches concrÃ¨tes et faisables
   * 3. En attente : DÃ©lÃ©guÃ© ou dÃ©pendant d'autres
   * 4. Projets : RÃ©sultats nÃ©cessitant plusieurs actions
   * 5. Someday/Maybe : IdÃ©es pour le futur
   * 6. RÃ©fÃ©rence : Informations Ã  conserver
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚   ğŸ“¥ INBOX   â”‚ â¡ï¸ ACTIONS   â”‚
   * â”‚              â”‚   SUIVANTES  â”‚
   * â”‚ (Collecte    â”‚ (Prochaines  â”‚
   * â”‚  rapide)     â”‚  tÃ¢ches)     â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚â³ EN â”‚ğŸ“‹ PROJâ”‚ğŸ¤” SM â”‚       â”‚
   * â”‚ATTEN.â”‚   ETS â”‚  /M  â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ“š RÃ‰FÃ‰RENCE           â”‚
   * â”‚   (Documentation,           â”‚
   * â”‚    informations)            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : OptimisÃ©e pour le flux GTD
   * CAS D'USAGE : ProductivitÃ© personnelle, gestion complÃ¨te des tÃ¢ches
   */
  layout_gtd: [
    {
      title: "Inbox",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Zone de capture : tout ce qui arrive sans traitement
    },
    {
      title: "Actions suivantes",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // TÃ¢ches clarifiÃ©es et prÃªtes Ã  Ãªtre exÃ©cutÃ©es
    },
    {
      title: "En attente",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // DÃ©lÃ©guÃ© ou en attente de quelqu'un/quelque chose d'autre
    },
    {
      title: "Projets",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // RÃ©sultats dÃ©sirÃ©s nÃ©cessitant plus d'une action
    },
    {
      title: "Someday Maybe",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // IdÃ©es intÃ©ressantes pour plus tard
    },
    {
      title: "R\xE9f\xE9rence",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Informations utiles Ã  conserver pour consultation
    }
  ],
  // ===========================================================================
  // SECTION 2 : LAYOUTS DE FLUX DE TRAVAIL (WORKFLOW)
  // ===========================================================================
  /**
   * TABLEAU KANBAN CLASSIQUE - Visualisation du flux de travail
   * 
   * MÃ‰THODOLOGIE :
   * Originaire du systÃ¨me de production Toyota, adaptÃ© au travail intellectuel.
   * Principe : visualiser le travail, limiter le travail en cours (WIP).
   * 
   * PHILOSOPHIE :
   * Flux tirÃ© (pull) plutÃ´t que poussÃ© (push).
   * Optimisation du dÃ©bit global plutÃ´t que de l'efficacitÃ© locale.
   * 
   * COLONNES STANDARD :
   * 1. Ã€ faire (Backlog) : TÃ¢ches en attente
   * 2. En cours (Doing/WIP) : Travail actuel (limitÃ©)
   * 3. TerminÃ© (Done) : Travail complÃ©tÃ©
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚            â”‚            â”‚            â”‚
   * â”‚  ğŸ“‹ Ã€      â”‚  âš™ï¸ EN     â”‚  âœ… TERMI- â”‚
   * â”‚   FAIRE    â”‚   COURS    â”‚    NÃ‰      â”‚
   * â”‚            â”‚            â”‚            â”‚
   * â”‚ â€¢ TÃ¢che A  â”‚ â€¢ TÃ¢che X  â”‚ â€¢ TÃ¢che 1  â”‚
   * â”‚ â€¢ TÃ¢che B  â”‚ â€¢ TÃ¢che Y  â”‚ â€¢ TÃ¢che 2  â”‚
   * â”‚ â€¢ TÃ¢che C  â”‚            â”‚ â€¢ TÃ¢che 3  â”‚
   * â”‚ â€¢ ...      â”‚ [WIP: 2]   â”‚ â€¢ ...      â”‚
   * â”‚            â”‚            â”‚            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 3 colonnes Ã©gales sur toute la hauteur
   * CAS D'USAGE : DÃ©veloppement logiciel, gestion d'Ã©quipe, projets itÃ©ratifs
   */
  layout_kanban: [
    {
      title: "\xC0 faire",
      x: 0,
      y: 0,
      w: 8,
      h: 24
      // Backlog : tÃ¢ches priorisÃ©es en attente
    },
    {
      title: "En cours",
      x: 8,
      y: 0,
      w: 8,
      h: 24
      // Work In Progress : limite recommandÃ©e selon l'Ã©quipe
    },
    {
      title: "Termin\xE9",
      x: 16,
      y: 0,
      w: 8,
      h: 24
      // Done : validation et archivage des tÃ¢ches complÃ©tÃ©es
    }
  ],
  // ===========================================================================
  // SECTION 3 : LAYOUTS DE PLANIFICATION TEMPORELLE
  // ===========================================================================
  /**
   * PLANIFICATEUR HEBDOMADAIRE - Organisation par jour de la semaine
   * 
   * MÃ‰THODOLOGIE :
   * Planification cyclique basÃ©e sur la semaine de travail standard.
   * Ã‰quilibre entre productivitÃ© professionnelle et bien-Ãªtre personnel.
   * 
   * PHILOSOPHIE :
   * Rythme hebdomadaire naturel avec distinction travail/repos.
   * Vision d'ensemble pour une planification Ã©quilibrÃ©e.
   * 
   * ORGANISATION :
   * - 5 jours de travail avec sections dÃ©diÃ©es
   * - Weekend groupÃ© pour activitÃ©s personnelles
   * - Zone de notes pour observations et rÃ©flexions
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   * â”‚ LUN â”‚ MAR â”‚ MER â”‚ JEU â”‚
   * â”‚     â”‚     â”‚     â”‚     â”‚
   * â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚ ğŸ“…  â”‚
   * â”‚     â”‚     â”‚     â”‚     â”‚
   * â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¤
   * â”‚ VEN â”‚ W-E â”‚   ğŸ“      â”‚
   * â”‚     â”‚ ğŸ–ï¸  â”‚   NOTES   â”‚
   * â”‚ ğŸ“…  â”‚     â”‚           â”‚
   * â”‚     â”‚     â”‚           â”‚
   * â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Layout asymÃ©trique optimisÃ©
   * CAS D'USAGE : Planning personnel, coordination d'Ã©quipe, revues hebdomadaires
   */
  layout_weekly: [
    {
      title: "Lundi",
      x: 0,
      y: 0,
      w: 6,
      h: 12
      // DÃ©marrage de semaine, objectifs et planification
    },
    {
      title: "Mardi",
      x: 6,
      y: 0,
      w: 6,
      h: 12
      // ProductivitÃ© optimale, tÃ¢ches importantes
    },
    {
      title: "Mercredi",
      x: 12,
      y: 0,
      w: 6,
      h: 12
      // Milieu de semaine, ajustements et rÃ©visions
    },
    {
      title: "Jeudi",
      x: 18,
      y: 0,
      w: 6,
      h: 12
      // Finalisation des livrables de la semaine
    },
    {
      title: "Vendredi",
      x: 0,
      y: 12,
      w: 8,
      h: 12
      // ClÃ´ture, bilans et prÃ©paration semaine suivante
    },
    {
      title: "Weekend",
      x: 8,
      y: 12,
      w: 8,
      h: 12
      // Repos, activitÃ©s personnelles, famille, loisirs
    },
    {
      title: "Notes",
      x: 16,
      y: 12,
      w: 8,
      h: 12
      // Observations, idÃ©es, rÃ©flexions et apprentissages
    }
  ],
  /**
   * PLANIFICATEUR QUOTIDIEN - Structure dÃ©taillÃ©e d'une journÃ©e
   * 
   * MÃ‰THODOLOGIE :
   * Organisation mÃ©ticuleuse d'une journÃ©e avec focus sur l'apprentissage
   * et la rÃ©flexion. InspirÃ© des mÃ©thodes de dÃ©veloppement personnel.
   * 
   * PHILOSOPHIE :
   * JournÃ©e intentionnelle avec boucle d'amÃ©lioration continue.
   * Ã‰quilibre entre action et rÃ©flexion.
   * 
   * STRUCTURE :
   * - Objectifs clairs et limitÃ©s (max 3)
   * - TÃ¢ches prioritaires identifiÃ©es
   * - Planning temporel structurÃ©
   * - Capture d'apprentissages
   * - RÃ©flexion et bilan de fin de journÃ©e
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ ğŸ¯ OBJECTIFSâ”‚ â­ PRIORITÃ‰S â”‚
   * â”‚   DU JOUR   â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ğŸ“…PLAâ”‚ğŸ“ NOTâ”‚ğŸ“šAPPâ”‚ğŸ’­ RÃ‰F â”‚
   * â”‚NING â”‚   ES â”‚RENT.â”‚  LEX. â”‚
   * â”‚     â”‚      â”‚     â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ’¡ RÃ‰FLEXIONS       â”‚
   * â”‚     ET BILAN QUOTIDIEN   â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 6 sections pour journÃ©e structurÃ©e
   * CAS D'USAGE : DÃ©veloppement personnel, productivitÃ© quotidienne
   */
  layout_daily: [
    {
      title: "Objectifs du jour",
      x: 0,
      y: 0,
      w: 12,
      h: 8
      // Maximum 3 objectifs SMART pour la journÃ©e
    },
    {
      title: "T\xE2ches prioritaires",
      x: 12,
      y: 0,
      w: 12,
      h: 8
      // Actions importantes qui font avancer les objectifs
    },
    {
      title: "Planning",
      x: 0,
      y: 8,
      w: 8,
      h: 8
      // Emploi du temps, rendez-vous, crÃ©neaux de travail
    },
    {
      title: "Notes",
      x: 8,
      y: 8,
      w: 8,
      h: 8
      // Capture rapide d'idÃ©es, observations, informations
    },
    {
      title: "Apprentissages",
      x: 16,
      y: 8,
      w: 8,
      h: 8
      // Ce que j'ai appris aujourd'hui (compÃ©tences, insights)
    },
    {
      title: "R\xE9flexions",
      x: 0,
      y: 16,
      w: 24,
      h: 8
      // Bilan de journÃ©e, points d'amÃ©lioration, gratitude
    }
  ],
  // ===========================================================================
  // SECTION 4 : LAYOUTS DE GESTION DE PROJET
  // ===========================================================================
  /**
   * GESTION DE PROJET COMPLÃˆTE - Vue d'ensemble projet
   * 
   * MÃ‰THODOLOGIE :
   * Approche holistique de la gestion de projet intÃ©grant tous les aspects
   * essentiels. InspirÃ© des mÃ©thodologies PMI et Agile.
   * 
   * PHILOSOPHIE :
   * Vision systÃ©mique du projet avec Ã©quilibre entre planification
   * et adaptabilitÃ©.
   * 
   * COMPOSANTS :
   * - Vue d'ensemble : Contexte et vision globale
   * - Objectifs : RÃ©sultats mesurables attendus
   * - Ã‰tapes : Jalons et phases du projet
   * - Ressources : Ã‰quipe, budget, outils
   * - Risques : Identification et mitigation
   * - Suivi : MÃ©triques et progression
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚       ğŸ¯ VUE D'ENSEMBLE         â”‚
   * â”‚    (Vision, contexte, enjeux)   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚ğŸ“‹ OBJECTI â”‚ğŸš€ Ã‰TAPES  â”‚ğŸ’¼ RESSO-â”‚
   * â”‚   FS      â”‚           â”‚   URCES â”‚
   * â”‚           â”‚           â”‚         â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚  âš ï¸ RISQUES     â”‚ ğŸ“Š SUIVI     â”‚
   * â”‚                 â”‚               â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Vue hiÃ©rarchique avec header
   * CAS D'USAGE : Gestion de projet, initiatives stratÃ©giques, lancements
   */
  layout_project: [
    {
      title: "Vue d'ensemble",
      x: 0,
      y: 0,
      w: 24,
      h: 6
      // Contexte, vision, objectifs gÃ©nÃ©raux, parties prenantes
    },
    {
      title: "Objectifs",
      x: 0,
      y: 6,
      w: 8,
      h: 9
      // Objectifs SMART, critÃ¨res de succÃ¨s, KPIs
    },
    {
      title: "\xC9tapes",
      x: 8,
      y: 6,
      w: 8,
      h: 9
      // Jalons, phases, roadmap, planning gÃ©nÃ©ral
    },
    {
      title: "Ressources",
      x: 16,
      y: 6,
      w: 8,
      h: 9
      // Ã‰quipe, budget, outils, compÃ©tences nÃ©cessaires
    },
    {
      title: "Risques",
      x: 0,
      y: 15,
      w: 12,
      h: 9
      // Identification, Ã©valuation, plans de mitigation
    },
    {
      title: "Suivi",
      x: 12,
      y: 15,
      w: 12,
      h: 9
      // MÃ©triques, avancement, reporting, ajustements
    }
  ],
  // ===========================================================================
  // SECTION 5 : LAYOUTS BASIQUES ET POLYVALENTS
  // ===========================================================================
  /**
   * BOARD SIMPLE - Approche minimaliste 2 colonnes
   * 
   * MÃ‰THODOLOGIE :
   * SimplicitÃ© volontaire pour dÃ©marrage rapide ou usages non-spÃ©cialisÃ©s.
   * BasÃ© sur la dichotomie pensÃ©e/action.
   * 
   * PHILOSOPHIE :
   * "La simplicitÃ© est la sophistication suprÃªme" - Leonardo da Vinci
   * Parfait pour dÃ©buter ou pour des besoins basiques.
   * 
   * APPLICATIONS :
   * - Brainstorming : IdÃ©es â†’ Actions
   * - Comparaison : Pour â†’ Contre
   * - Processus : Input â†’ Output
   * - Planning : Cette semaine â†’ Semaine prochaine
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚             â”‚             â”‚
   * â”‚   ğŸ’¡ IDEAS  â”‚ âš¡ ACTIONS  â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â”‚             â”‚             â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : 2 colonnes Ã©gales, simplicitÃ© maximale
   * CAS D'USAGE : Brainstorming, comparaisons, projets simples, dÃ©marrage
   */
  layout_simple: [
    {
      title: "Ideas",
      x: 0,
      y: 0,
      w: 12,
      h: 24
      // IdÃ©es, concepts, possibilitÃ©s, rÃ©flexions
    },
    {
      title: "Actions",
      x: 12,
      y: 0,
      w: 12,
      h: 24
      // Actions concrÃ¨tes, tÃ¢ches, Ã©tapes suivantes
    }
  ],
  // ===========================================================================
  // SECTION 6 : LAYOUTS DE PRISE DE NOTES
  // ===========================================================================
  /**
   * NOTES CORNELL - SystÃ¨me de prise de notes universitaire
   * 
   * MÃ‰THODOLOGIE :
   * DÃ©veloppÃ© Ã  l'universitÃ© Cornell par Walter Pauk dans les annÃ©es 1950.
   * Optimise la prise de notes, la rÃ©vision et la mÃ©morisation.
   * 
   * PHILOSOPHIE :
   * Structure prÃ©dÃ©finie qui force l'organisation et la synthÃ¨se.
   * SÃ©paration claire entre capture, analyse et mÃ©morisation.
   * 
   * ZONES FONCTIONNELLES :
   * 1. Notes principales : Capture du contenu principal
   * 2. Mots-clÃ©s/Questions : Indices de rÃ©vision et concepts clÃ©s
   * 3. RÃ©sumÃ© : SynthÃ¨se personnelle et points clÃ©s
   * 
   * PROCESSUS :
   * PENDANT â†’ Prendre des notes dans la zone principale
   * APRÃˆS â†’ Ajouter mots-clÃ©s et questions dans la marge
   * RÃ‰VISION â†’ Utiliser les mots-clÃ©s pour rÃ©viser
   * SYNTHÃˆSE â†’ Ã‰crire un rÃ©sumÃ© personnel
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚                    â”‚       â”‚
   * â”‚     ğŸ“ NOTES       â”‚ ğŸ·ï¸    â”‚
   * â”‚   (Contenu         â”‚ MOTS- â”‚
   * â”‚    principal)      â”‚ CLÃ‰S  â”‚
   * â”‚                    â”‚       â”‚
   * â”‚                    â”‚       â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚      ğŸ“‹ RÃ‰SUMÃ‰             â”‚
   * â”‚   (SynthÃ¨se personnelle)   â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * GRILLE TECHNIQUE : Zone principale + marge + footer
   * CAS D'USAGE : Cours, confÃ©rences, lectures, formations
   */
  layout_cornell: [
    {
      title: "Notes",
      x: 0,
      y: 0,
      w: 16,
      h: 18
      // Zone principale de prise de notes pendant l'Ã©coute
    },
    {
      title: "Mots-cl\xE9s",
      x: 16,
      y: 0,
      w: 8,
      h: 18
      // Marge pour concepts clÃ©s, questions, indices de rÃ©vision
    },
    {
      title: "R\xE9sum\xE9",
      x: 0,
      y: 18,
      w: 24,
      h: 6
      // SynthÃ¨se personnelle en fin de session
    }
  ],
  // ===========================================================================
  // SECTION 7 : LAYOUTS D'INTÃ‰GRATION AVEC PLUGINS OBSIDIAN
  // ===========================================================================
  /**
   * DASHBOARD TASKS - IntÃ©gration avancÃ©e avec le plugin Tasks
   * 
   * MÃ‰THODOLOGIE :
   * OptimisÃ© pour exploiter les capacitÃ©s du plugin Tasks d'Obsidian.
   * Affichage intelligent des tÃ¢ches par contexte temporel et projet.
   * 
   * PHILOSOPHIE :
   * Centralisation et contextualisation des tÃ¢ches pour une vision
   * d'ensemble de la charge de travail.
   * 
   * ZONES TEMPORELLES :
   * - Aujourd'hui : Focus sur l'immÃ©diat
   * - Cette semaine : Vision Ã  court terme
   * - En retard : Gestion des dÃ©passements
   * - Projets actifs : Vision organisationnelle
   * - Statistiques : MÃ©triques et tendances
   * 
   * REQUÃŠTES TASKS INTÃ‰GRÃ‰ES :
   * Utilise la syntaxe du plugin Tasks pour des requÃªtes dynamiques.
   * 
   * DIAGRAMME VISUEL :
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚ ğŸ“… AUJ. â”‚ğŸ“… SEMN â”‚âš ï¸ RETARDâ”‚
   * â”‚         â”‚         â”‚         â”‚
   * â”‚ tasks   â”‚ tasks   â”‚ tasks   â”‚
   * â”‚ due     â”‚ due     â”‚ due     â”‚
   * â”‚ today   â”‚ this    â”‚ before  â”‚
   * â”‚         â”‚ week    â”‚ today   â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚  ğŸ“Š PROJETS       â”‚ğŸ“ˆ STATS â”‚
   * â”‚    ACTIFS         â”‚         â”‚
   * â”‚ (par projet)      â”‚(mÃ©triq.)â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   * 
   * REQUÃŠTES TASKS SUGGÃ‰RÃ‰ES :
   * - Aujourd'hui : ```tasks due today not done```
   * - Cette semaine : ```tasks due this week not done```
   * - En retard : ```tasks due before today not done```
   * - Par projet : ```tasks group by project```
   * 
   * GRILLE TECHNIQUE : Vue temporelle + organisation + analytics
   * CAS D'USAGE : Gestion avancÃ©e des tÃ¢ches, productivitÃ©, suivi projets
   */
  layout_tasks_dashboard: [
    {
      title: "T\xE2ches du jour",
      x: 0,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due today not done```
    },
    {
      title: "Cette semaine",
      x: 8,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due this week not done```
    },
    {
      title: "En retard",
      x: 16,
      y: 0,
      w: 8,
      h: 12
      // ```tasks due before today not done```
    },
    {
      title: "Projets actifs",
      x: 0,
      y: 12,
      w: 12,
      h: 12
      // ```tasks group by project``` ou organisation manuelle
    },
    {
      title: "Statistiques",
      x: 12,
      y: 12,
      w: 12,
      h: 12
      // MÃ©triques, tendances, analyse de productivitÃ©
    }
  ]
};
var LAYOUT_INFO = {
  layout_eisenhower: {
    name: "layout_eisenhower",
    displayName: "Matrice d'Eisenhower",
    description: "Syst\xE8me de priorisation bas\xE9 sur l'urgence et l'importance. Parfait pour la gestion quotidienne et les d\xE9cisions strat\xE9giques.",
    sections: ["Urgent et Important", "Pas urgent mais Important", "Urgent mais Pas important", "Ni urgent ni important"],
    blockCount: 4,
    category: "productivit\xE9"
  },
  layout_gtd: {
    name: "layout_gtd",
    displayName: "Getting Things Done (GTD)",
    description: "M\xE9thode compl\xE8te de productivit\xE9 de David Allen. Syst\xE8me d'externalisation de la m\xE9moire et de clarification syst\xE9matique.",
    sections: ["Inbox", "Actions suivantes", "En attente", "Projets", "Someday Maybe", "R\xE9f\xE9rence"],
    blockCount: 6,
    category: "productivit\xE9"
  },
  layout_kanban: {
    name: "layout_kanban",
    displayName: "Tableau Kanban",
    description: "Visualisation du flux de travail avec limitation du travail en cours. Id\xE9al pour le d\xE9veloppement et la gestion d'\xE9quipe.",
    sections: ["\xC0 faire", "En cours", "Termin\xE9"],
    blockCount: 3,
    category: "workflow"
  },
  layout_weekly: {
    name: "layout_weekly",
    displayName: "Planificateur Hebdomadaire",
    description: "Organisation par jour de la semaine avec \xE9quilibre travail/repos. Parfait pour la planification personnelle et la coordination d'\xE9quipe.",
    sections: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Weekend", "Notes"],
    blockCount: 7,
    category: "planification"
  },
  layout_daily: {
    name: "layout_daily",
    displayName: "Planificateur Quotidien",
    description: "Structure d\xE9taill\xE9e d'une journ\xE9e avec focus sur l'apprentissage et la r\xE9flexion. Id\xE9al pour le d\xE9veloppement personnel.",
    sections: ["Objectifs du jour", "T\xE2ches prioritaires", "Planning", "Notes", "Apprentissages", "R\xE9flexions"],
    blockCount: 6,
    category: "planification"
  },
  layout_project: {
    name: "layout_project",
    displayName: "Gestion de Projet",
    description: "Vue d'ensemble compl\xE8te d'un projet avec tous les aspects essentiels. Inspir\xE9 des m\xE9thodologies PMI et Agile.",
    sections: ["Vue d'ensemble", "Objectifs", "\xC9tapes", "Ressources", "Risques", "Suivi"],
    blockCount: 6,
    category: "projet"
  },
  layout_simple: {
    name: "layout_simple",
    displayName: "Board Simple",
    description: "Approche minimaliste \xE0 2 colonnes. Parfait pour d\xE9buter ou pour des besoins basiques de brainstorming et comparaison.",
    sections: ["Ideas", "Actions"],
    blockCount: 2,
    category: "basique"
  },
  layout_cornell: {
    name: "layout_cornell",
    displayName: "Notes Cornell",
    description: "Syst\xE8me de prise de notes universitaire optimisant la capture, r\xE9vision et m\xE9morisation. D\xE9velopp\xE9 \xE0 Cornell University.",
    sections: ["Notes", "Mots-cl\xE9s", "R\xE9sum\xE9"],
    blockCount: 3,
    category: "notes"
  },
  layout_tasks_dashboard: {
    name: "layout_tasks_dashboard",
    displayName: "Dashboard Tasks",
    description: "Int\xE9gration avanc\xE9e avec le plugin Tasks d'Obsidian. Affichage intelligent des t\xE2ches par contexte temporel et projet.",
    sections: ["T\xE2ches du jour", "Cette semaine", "En retard", "Projets actifs", "Statistiques"],
    blockCount: 5,
    category: "int\xE9gration"
  }
};

// src/services/LayoutService.ts
var LayoutService = class {
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Stockage interne des layouts validÃ©s
     * 
     * CHOIX DE STRUCTURE DE DONNÃ‰ES :
     * Map vs Object :
     * - Map : accÃ¨s O(1), iteration garantie, clÃ©s dynamiques
     * - Object : plus de syntaxe, risque de pollution du prototype
     * 
     * GÃ‰NÃ‰RICS TYPESCRIPT :
     * Map<K, V> indique les types de clÃ© et valeur
     * - K = string (nom du layout)
     * - V = BoardLayout[] (array de blocs)
     */
    this.models = /* @__PURE__ */ new Map();
    this.logger = plugin.logger;
  }
  // ===========================================================================
  // MÃ‰THODES DE CHARGEMENT ET INITIALISATION
  // ===========================================================================
  /**
   * Charge et valide tous les layouts intÃ©grÃ©s
   * 
   * PROCESSUS DE CHARGEMENT :
   * 1. Vider le cache existant
   * 2. ItÃ©rer sur tous les layouts prÃ©dÃ©finis
   * 3. Valider chaque layout gÃ©omÃ©triquement
   * 4. Stocker les layouts valides
   * 5. Rejeter les layouts invalides avec warning
   * 6. Logger le rÃ©sumÃ© du chargement
   * 
   * GESTION D'ERREURS :
   * Les layouts invalides sont ignorÃ©s mais loggÃ©s.
   * Le plugin continue de fonctionner avec les layouts valides.
   * 
   * VALIDATION GÃ‰OMÃ‰TRIQUE :
   * - VÃ©rification des limites de grille
   * - DÃ©tection des chevauchements
   * - Validation des types de donnÃ©es
   * 
   * @example
   * layoutService.load();
   * // Log: "ğŸ“ 3 layouts chargÃ©s"
   * // Log: "ğŸ“‹ Layouts disponibles: layout_eisenhower, layout_kanban, ..."
   */
  load() {
    this.logger.info("\u{1F4D0} Chargement des layouts int\xE9gr\xE9s...");
    this.models.clear();
    let loadedCount = 0;
    for (const [name, layout] of Object.entries(BUILT_IN_LAYOUTS)) {
      console.log(`\u{1F50D} Chargement du layout "${name}"...`);
      if (this.validateModel(name, layout)) {
        this.models.set(name, layout);
        loadedCount++;
        console.log(`\u2705 Layout "${name}" charg\xE9 (${layout.length} blocs)`);
      } else {
        console.warn(`\u274C Mod\xE8le "${name}" invalide`);
      }
    }
    console.log(`\u{1F4D0} ${loadedCount} layouts charg\xE9s`);
    this.logAvailableLayouts();
  }
  /**
   * Valide complÃ¨tement un layout (gÃ©omÃ©trie + cohÃ©rence)
   * 
   * VALIDATION EN PLUSIEURS Ã‰TAPES :
   * 1. Validation individuelle de chaque bloc
   * 2. VÃ©rification des limites de grille
   * 3. DÃ©tection des chevauchements
   * 4. CrÃ©ation d'une grille de test pour simulation
   * 
   * ALGORITHME DE CHEVAUCHEMENT :
   * - CrÃ©er une grille boolÃ©enne 24Ã—100
   * - Pour chaque bloc, marquer ses cellules
   * - Si une cellule est dÃ©jÃ  marquÃ©e = chevauchement
   * 
   * @param name - Nom du layout (pour les logs d'erreur)
   * @param layout - Array de blocs Ã  valider
   * @returns boolean - true si le layout est entiÃ¨rement valide
   * 
   * @example
   * const isValid = layoutService.validateModel("test", [
   *   { title: "Block 1", x: 0, y: 0, w: 12, h: 12 },
   *   { title: "Block 2", x: 12, y: 0, w: 12, h: 12 }
   * ]);
   * // true si pas de chevauchement, false sinon
   */
  validateModel(name, layout) {
    const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
    let isValid = true;
    for (const block of layout) {
      if (!this.isValidBlock(block)) {
        console.warn(`\u274C [${name}] Bloc invalide :`, block);
        isValid = false;
        continue;
      }
      if (!this.isBlockInBounds(block)) {
        console.warn(`\u274C [${name}] Bloc hors limites :`, block);
        isValid = false;
        continue;
      }
      if (!this.checkOverlap(grid, block, name)) {
        isValid = false;
      }
    }
    return isValid;
  }
  /**
   * VÃ©rifie qu'un objet a la structure d'un BoardLayout valide
   * 
   * TYPE GUARD TYPESCRIPT :
   * Cette fonction est un "type guard" qui vÃ©rifie Ã  l'exÃ©cution
   * qu'un objet correspond Ã  l'interface BoardLayout.
   * 
   * VÃ‰RIFICATIONS :
   * - PrÃ©sence de toutes les propriÃ©tÃ©s requises
   * - Types corrects (string pour title, number pour les autres)
   * - Pas de vÃ©rification des valeurs (fait dans isBlockInBounds)
   * 
   * @param block - Objet Ã  vÃ©rifier (type any pour flexibilitÃ©)
   * @returns block is BoardLayout - Type guard TypeScript
   * 
   * @example
   * const obj = { title: "Test", x: 0, y: 0, w: 5, h: 5 };
   * if (isValidBlock(obj)) {
   *   // TypeScript sait maintenant que obj est un BoardLayout
   *   console.log(obj.title); // Pas d'erreur TypeScript
   * }
   */
  isValidBlock(block) {
    return typeof block.title === "string" && // Titre doit Ãªtre une chaÃ®ne
    typeof block.x === "number" && // Position X doit Ãªtre un nombre
    typeof block.y === "number" && // Position Y doit Ãªtre un nombre
    typeof block.w === "number" && // Largeur doit Ãªtre un nombre
    typeof block.h === "number";
  }
  /**
   * VÃ©rifie qu'un bloc respecte les limites de la grille
   * 
   * CONTRAINTES DE GRILLE :
   * - x >= 0 : pas de position nÃ©gative
   * - y >= 0 : pas de position nÃ©gative
   * - w > 0 : largeur positive
   * - h > 0 : hauteur positive
   * - x + w <= 24 : ne dÃ©borde pas Ã  droite
   * - y + h <= 100 : ne dÃ©borde pas en bas
   * 
   * @param block - Bloc Ã  vÃ©rifier (dÃ©jÃ  validÃ© par isValidBlock)
   * @returns boolean - true si dans les limites
   * 
   * @example
   * isBlockInBounds({ title: "Test", x: 20, y: 0, w: 5, h: 10 });
   * // false car x(20) + w(5) = 25 > 24 (dÃ©borde Ã  droite)
   */
  isBlockInBounds(block) {
    const MIN_SIZE = 2;
    return block.x >= 0 && // Position X positive
    block.y >= 0 && // Position Y positive
    block.w > MIN_SIZE && // Largeur positive
    block.h > MIN_SIZE && // Hauteur positive
    block.x + block.w <= 24 && // Pas de dÃ©bordement horizontal
    block.y + block.h <= 100;
  }
  /**
   * VÃ©rifie qu'un bloc ne chevauche pas avec les blocs dÃ©jÃ  placÃ©s
   * 
   * ALGORITHME :
   * 1. Parcourir toutes les cellules du bloc
   * 2. Pour chaque cellule (x, y), vÃ©rifier si grid[x][y] est dÃ©jÃ  true
   * 3. Si dÃ©jÃ  true = chevauchement dÃ©tectÃ©
   * 4. Sinon, marquer la cellule comme occupÃ©e
   * 
   * EFFET DE BORD :
   * Cette fonction modifie la grille en marquant les cellules occupÃ©es.
   * C'est voulu pour la dÃ©tection cumulative de chevauchements.
   * 
   * @param grid - Grille de test (modifiÃ©e par la fonction)
   * @param block - Bloc Ã  placer
   * @param modelName - Nom du layout (pour les logs d'erreur)
   * @returns boolean - true si pas de chevauchement
   * 
   * @example
   * const grid = Array.from({ length: 24 }, () => Array(100).fill(false));
   * const block1 = { title: "A", x: 0, y: 0, w: 10, h: 10 };
   * const block2 = { title: "B", x: 5, y: 5, w: 10, h: 10 };
   * 
   * checkOverlap(grid, block1, "test"); // true (premiÃ¨re fois)
   * checkOverlap(grid, block2, "test"); // false (chevauchement en (5,5)-(9,9))
   */
  checkOverlap(grid, block, modelName) {
    for (let x = block.x; x < block.x + block.w; x++) {
      for (let y = block.y; y < block.y + block.h; y++) {
        if (grid[x][y]) {
          console.warn(`\u274C [${modelName}] Chevauchement d\xE9tect\xE9 au bloc "${block.title}" \xE0 (${x}, ${y})`);
          return false;
        }
        grid[x][y] = true;
      }
    }
    return true;
  }
  /**
   * Affiche un rÃ©sumÃ© des layouts chargÃ©s dans la console
   * 
   * UTILITÃ‰ :
   * - DÃ©bogage : voir quels layouts sont disponibles
   * - VÃ©rification : confirmer que le chargement s'est bien passÃ©
   * - Documentation : liste des sections de chaque layout
   * 
   * FORMAT DE SORTIE :
   * ```
   * ğŸ“‹ Layouts disponibles: layout_eisenhower, layout_kanban
   *   â€¢ layout_eisenhower: 4 sections (Urgent et Important, Pas urgent...)
   *   â€¢ layout_kanban: 3 sections (Ã€ faire, En cours, TerminÃ©)
   * ```
   */
  logAvailableLayouts() {
    const layouts = Array.from(this.models.keys());
    console.log("\u{1F4CB} Layouts disponibles:", layouts);
    for (const [name, layout] of this.models) {
      const sections = layout.map((b) => b.title).join(", ");
      console.log(`  \u2022 ${name}: ${layout.length} sections (${sections})`);
    }
  }
  // ===========================================================================
  // MÃ‰THODES D'ACCÃˆS PUBLIC (API DU SERVICE)
  // ===========================================================================
  /**
   * RÃ©cupÃ¨re un layout par son nom
   * 
   * API PRINCIPALE :
   * Cette mÃ©thode est l'interface principale pour obtenir un layout.
   * UtilisÃ©e par BoardView, ViewSwitcher, etc.
   * 
   * RETOUR UNDEFINED :
   * Retourne undefined si le layout n'existe pas.
   * Plus sÃ»r que de lever une exception.
   * 
   * @param name - Nom du layout (ex: "layout_eisenhower")
   * @returns BoardLayout[] | undefined - Layout ou undefined si inexistant
   * 
   * @example
   * const layout = layoutService.getModel("layout_eisenhower");
   * if (layout) {
   *   // Layout trouvÃ©, on peut l'utiliser
   *   console.log(`Layout avec ${layout.length} blocs`);
   * } else {
   *   // Layout inexistant
   *   console.error("Layout non trouvÃ©");
   * }
   */
  getModel(name) {
    return this.models.get(name);
  }
  /**
   * Retourne la liste de tous les noms de layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : lister les layouts dans un menu
   * - Validation : vÃ©rifier qu'un layout existe
   * - DÃ©bogage : voir ce qui est disponible
   * 
   * @returns string[] - Array des noms de layouts
   * 
   * @example
   * const names = layoutService.getAllModelNames();
   * console.log(names); // ["layout_eisenhower", "layout_kanban", ...]
   * 
   * // Utilisation dans une interface
   * names.forEach(name => {
   *   const displayName = getLayoutDisplayName(name);
   *   addMenuItem(displayName, () => createNote(name));
   * });
   */
  getAllModelNames() {
    return Array.from(this.models.keys());
  }
  /**
   * Obtient le nom d'affichage convivial d'un layout
   * 
   * MAPPING TECHNIQUE â†’ USER-FRIENDLY :
   * "layout_eisenhower" â†’ "Matrice d'Eisenhower"
   * 
   * FALLBACK :
   * Si aucun nom d'affichage n'est dÃ©fini, retourne le nom technique.
   * Ã‰vite les erreurs si les mÃ©tadonnÃ©es sont incomplÃ¨tes.
   * 
   * @param layoutName - Nom technique du layout
   * @returns string - Nom d'affichage ou nom technique si non trouvÃ©
   * 
   * @example
   * const displayName = layoutService.getLayoutDisplayName("layout_eisenhower");
   * console.log(displayName); // "Matrice d'Eisenhower"
   * 
   * const unknownName = layoutService.getLayoutDisplayName("layout_custom");
   * console.log(unknownName); // "layout_custom" (fallback)
   */
  getLayoutDisplayName(layoutName) {
    const layoutInfo = LAYOUT_INFO[layoutName];
    return layoutInfo ? layoutInfo.displayName : layoutName;
  }
  /**
   * Obtient les mÃ©tadonnÃ©es complÃ¨tes d'un layout
   * 
   * MÃ‰TADONNÃ‰ES ENRICHIES :
   * - Nom technique et d'affichage
   * - Description et cas d'usage
   * - Liste des sections
   * - Nombre de blocs
   * - CatÃ©gorie pour organisation
   * 
   * GÃ‰NÃ‰RATION AUTOMATIQUE :
   * Si les mÃ©tadonnÃ©es prÃ©dÃ©finies n'existent pas, gÃ©nÃ¨re des mÃ©tadonnÃ©es
   * basiques Ã  partir du layout lui-mÃªme.
   * 
   * @param name - Nom du layout
   * @returns LayoutInfo | undefined - MÃ©tadonnÃ©es ou undefined si layout inexistant
   * 
   * @example
   * const info = layoutService.getModelInfo("layout_eisenhower");
   * if (info) {
   *   console.log(`${info.displayName}: ${info.description}`);
   *   console.log(`Sections: ${info.sections.join(', ')}`);
   *   console.log(`CatÃ©gorie: ${info.category}`);
   * }
   */
  getModelInfo(name) {
    const model = this.models.get(name);
    if (!model)
      return void 0;
    const info = LAYOUT_INFO[name];
    return info || {
      name,
      displayName: name,
      // Nom technique par dÃ©faut
      description: "Layout personnalis\xE9",
      // Description gÃ©nÃ©rique
      sections: model.map((block) => block.title),
      // Extraire les titres des blocs
      blockCount: model.length,
      // Compter les blocs
      category: "custom"
      // CatÃ©gorie par dÃ©faut
    };
  }
  /**
   * Retourne les mÃ©tadonnÃ©es de tous les layouts disponibles
   * 
   * UTILISATION :
   * - Interface utilisateur : afficher tous les layouts avec dÃ©tails
   * - Filtrage : grouper par catÃ©gorie
   * - Documentation : gÃ©nÃ©rer de l'aide automatiquement
   * 
   * PERFORMANCE :
   * GÃ©nÃ¨re les mÃ©tadonnÃ©es Ã  la demande.
   * Pour de meilleures performances avec beaucoup de layouts,
   * on pourrait envisager un cache.
   * 
   * @returns LayoutInfo[] - Array de toutes les mÃ©tadonnÃ©es
   */
  getAllModelsInfo() {
    return Array.from(this.models.keys()).map((name) => this.getModelInfo(name)).filter((info) => info !== void 0);
  }
};

// src/services/FileService.ts
var import_obsidian = require("obsidian");

// src/cache/FileCache.ts
var _FileCache = class {
  constructor() {
    // 5 minutes
    this.cache = /* @__PURE__ */ new Map();
    this.dispose();
    this.startCleanupTimer();
  }
  /**
   * RÃ©cupÃ¨re une valeur du cache ou la gÃ©nÃ¨re
   */
  async get(key, fileModified, loader) {
    const cached = this.cache.get(key);
    if (cached && !this.isExpired(cached) && cached.fileModified >= fileModified) {
      console.log(`[FileCache] HIT pour la cl\xE9 "${key}"`);
      return cached.data;
    }
    console.log(`[FileCache] MISS pour la cl\xE9 "${key}", chargement...`);
    const data = await loader();
    this.set(key, data, fileModified);
    return data;
  }
  /**
   * Stocke une valeur dans le cache
   */
  set(key, data, fileModified) {
    console.log(`[FileCache] SET cl\xE9 "${key}"`);
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      fileModified
    });
  }
  /**
   * VÃ©rifie si une entrÃ©e du cache est expirÃ©e
   */
  isExpired(cached) {
    return Date.now() - cached.timestamp > _FileCache.CACHE_TTL;
  }
  /**
   * DÃ©marre le timer de nettoyage automatique
   */
  startCleanupTimer() {
    this.cleanupTimer = window.setInterval(() => {
      this.cleanup();
    }, 6e4);
  }
  /**
   * Nettoie les entrÃ©es expirÃ©es
   */
  cleanup() {
    const now = Date.now();
    let removed = 0;
    for (const [key, cached] of this.cache) {
      if (this.isExpired(cached)) {
        this.cache.delete(key);
        removed++;
      }
    }
    if (removed > 0) {
      console.log(`[FileCache] CLEANUP : ${removed} entr\xE9es supprim\xE9es`);
    }
  }
  /**
   * Invalide le cache pour une clÃ© spÃ©cifique
   */
  invalidate(key) {
    console.log(`[FileCache] INVALIDATE cl\xE9 "${key}"`);
    this.cache.delete(key);
  }
  /**
   * Vide complÃ¨tement le cache
   */
  clear() {
    console.log(`[FileCache] CLEAR`);
    this.cache.clear();
  }
  /**
   * Dispose le cache et nettoie les ressources
   */
  dispose() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = void 0;
    }
    this.clear();
  }
  /**
   * Statistiques du cache pour debugging
   */
  getStats() {
    return {
      size: this.cache.size,
      hitRate: 0
      // Ã€ implÃ©menter si nÃ©cessaire
    };
  }
};
var FileCache = _FileCache;
FileCache.CACHE_TTL = 3e5;

// src/errors/AgileBoardError.ts
var AgileBoardError = class extends Error {
  constructor(message, code, context) {
    super(message);
    this.code = code;
    this.context = context;
    this.name = "AgileBoardError";
  }
  static layoutNotFound(layoutName) {
    return new AgileBoardError(
      `Layout "${layoutName}" non trouv\xE9`,
      "LAYOUT_NOT_FOUND",
      { layoutName }
    );
  }
  static fileReadError(filePath, originalError) {
    return new AgileBoardError(
      `Impossible de lire le fichier "${filePath}"`,
      "FILE_READ_ERROR",
      { filePath, originalError: originalError.message }
    );
  }
  static validationError(field, value) {
    return new AgileBoardError(
      `Validation \xE9chou\xE9e pour le champ "${field}"`,
      "VALIDATION_ERROR",
      { field, value }
    );
  }
};

// src/constants/parsing.ts
var _ParsingConstants = class {
  // ===============================================================
  // MÃ‰THODES UTILITAIRES
  // ===============================================================
  /**
   * VÃ©rifie si une ligne est un titre de section
   * @param line - Ligne Ã  vÃ©rifier
   * @returns true si c'est un titre de section
   */
  static isSectionHeader(line) {
    return _ParsingConstants.SECTION_HEADER_REGEX.test(line);
  }
  /**
   * Extrait le nom d'une section depuis une ligne de titre
   * @param line - Ligne contenant le titre
   * @returns Nom de la section ou null si pas trouvÃ©
   */
  static extractSectionName(line) {
    const match = line.match(_ParsingConstants.SECTION_HEADER_REGEX);
    return match ? match[1].trim() : null;
  }
  /**
   * GÃ©nÃ¨re un titre de section formatÃ©
   * @param sectionName - Nom de la section
   * @returns Titre formatÃ© (ex: "## Ma Section")
   */
  static formatSectionHeader(sectionName) {
    return `${"#".repeat(_ParsingConstants.SECTION_HEADER_LEVEL)} ${sectionName}`;
  }
  /**
   * GÃ©nÃ¨re dynamiquement la regex pour le titre principal selon le niveau
   */
  static getMainTitleRegex() {
    return new RegExp(`^#{${_ParsingConstants.SECTION_HEADER_LEVEL}} ([^\\n#].*?)$`);
  }
  /**
   * VÃ©rifie si une ligne est un titre principal (H2)
   * @param line - Ligne Ã  vÃ©rifier
   * @returns true si c'est un titre principal
   */
  //static isMainTitle(line: string): boolean {
  //    return ParsingConstants.getMainTitleRegex().test(line);
  //}
  /**
   * Nettoie un nom de fichier des caractÃ¨res interdits
   * @param fileName - Nom Ã  nettoyer
   * @returns Nom de fichier sÃ©curisÃ©
   */
  static sanitizeFileName(fileName) {
    return fileName.replace(_ParsingConstants.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim();
  }
  /**
   * VÃ©rifie si un fichier est un fichier markdown
   * @param filePath - Chemin du fichier
   * @returns true si c'est un fichier markdown
   */
  static isMarkdownFile(filePath) {
    return _ParsingConstants.MARKDOWN_EXTENSIONS.some(
      (ext) => filePath.toLowerCase().endsWith(ext)
    );
  }
};
var ParsingConstants = _ParsingConstants;
// ===============================================================
// CONSTANTES DE PARSING
// ===============================================================
/** Niveau de titre pour les sections (2 = ##) */
ParsingConstants.SECTION_HEADER_LEVEL = 2;
/** Regex pour dÃ©tecter les titres de sections (prÃ©-compilÃ©e pour performance) */
ParsingConstants.SECTION_HEADER_REGEX = new RegExp(`^#{${_ParsingConstants.SECTION_HEADER_LEVEL}} ([^
#].*?)\\s*$`);
/** Regex pour dÃ©tecter le frontmatter YAML */
ParsingConstants.FRONTMATTER_DELIMITER = /^---\s*$/;
/** Regex pour nettoyer les noms de fichiers */
ParsingConstants.INVALID_FILENAME_CHARS = /[<>:"/\\|?*]/g;
/** Extensions de fichiers markdown supportÃ©es */
ParsingConstants.MARKDOWN_EXTENSIONS = [".md", ".markdown"];

// src/services/FileService.ts
var FileService = class {
  constructor(app, layoutService, logger) {
    this.app = app;
    this.layoutService = layoutService;
    this.logger = logger;
    this.cache = new FileCache();
  }
  // ===================================================================
  // MÃ‰THODES DE L'ANCIEN FILESERVICE (MAINTIEN COMPATIBILITÃ‰)
  // ===================================================================
  /**
  * Met Ã  jour le contenu d'une section spÃ©cifique (mÃ©thode temporaire)
  */
  async updateSectionContent(file, sectionName, content) {
    try {
      const fileContent = await this.app.vault.read(file);
      const lines = fileContent.split("\n");
      const newLines = [];
      let inTargetSection = false;
      let sectionFound = false;
      for (const line of lines) {
        if (ParsingConstants.SECTION_HEADER_REGEX.test(line)) {
          if (inTargetSection) {
            newLines.push(...content.split("\n"));
            inTargetSection = false;
          }
          const currentSection = line.substring(2).trim();
          if (currentSection === sectionName) {
            inTargetSection = true;
            sectionFound = true;
            newLines.push(line);
            continue;
          }
        }
        if (!inTargetSection) {
          newLines.push(line);
        }
      }
      if (inTargetSection) {
        newLines.push(...content.split("\n"));
      }
      if (sectionFound) {
        await this.app.vault.modify(file, newLines.join("\n"));
        this.logger.info(`\u2705 Section "${sectionName}" mise \xE0 jour`);
      } else {
        this.logger.warn(`\u26A0\uFE0F Section "${sectionName}" non trouv\xE9e`);
      }
    } catch (error) {
      this.logger.error("\u274C Erreur mise \xE0 jour section:", error);
      throw error;
    }
  }
  /**
   * Parse les sections d'un fichier (mÃ©thode originale maintenue)
   */
  async parseSections(file) {
    const cacheKey = `sections-${file.path}`;
    return this.cache.get(
      cacheKey,
      file.stat.mtime,
      async () => {
        var _a;
        (_a = this.logger) == null ? void 0 : _a.debug("Parsing sections (cache miss)", { fileName: file.name });
        return this.parseFileContentOriginal(file);
      }
    );
  }
  /**
   * Parse original maintenu pour compatibilitÃ©
   */
  async parseFileContentOriginal(file) {
    var _a, _b;
    this.logger.info("Parsing sections from file: ", file.name);
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const sections = {};
      let currentSection = "";
      let currentContent = [];
      for (const line of lines) {
        if (ParsingConstants.SECTION_HEADER_REGEX.test(line)) {
          if (currentSection) {
            sections[currentSection] = currentContent.join("\n").trim();
          }
          currentSection = line.substring(2).trim();
          currentContent = [];
        } else if (currentSection) {
          currentContent.push(line);
        }
      }
      if (currentSection) {
        sections[currentSection] = currentContent.join("\n").trim();
      }
      (_a = this.logger) == null ? void 0 : _a.debug("Sections pars\xE9es", {
        fileName: file.name,
        sectionCount: Object.keys(sections).length
      });
      return sections;
    } catch (error) {
      (_b = this.logger) == null ? void 0 : _b.error("Erreur parsing sections", error);
      throw AgileBoardError.fileReadError(file.path, error);
    }
  }
  /**
   * Retourne les sections manquantes (mÃ©thode originale)
   */
  getMissingSections(existingSections, requiredSections) {
    return requiredSections.filter((section) => !existingSections.includes(section));
  }
  // ===================================================================
  // NOUVELLES MÃ‰THODES CONSOLIDÃ‰ES
  // ===================================================================
  /**
   * Analyse complÃ¨te d'un fichier avec layout
   */
  async analyzeFile(file) {
    const layoutName = this.getLayoutName(file);
    if (!layoutName) {
      throw AgileBoardError.validationError("layoutName", "Layout agile-board manquant");
    }
    const layout = this.layoutService.getModel(layoutName);
    if (!layout) {
      throw AgileBoardError.layoutNotFound(layoutName);
    }
    const sections = await this.parseSections(file);
    const existingNames = Object.keys(sections);
    const requiredSections = layout.map((block) => block.title);
    this.logger.info("Required sections:", requiredSections);
    this.logger.info("Existing sections:", existingNames);
    return {
      file,
      layoutName,
      existingSections: this.convertToDetailedSections(sections, requiredSections),
      missingSections: this.getMissingSections(existingNames, requiredSections),
      extraSections: existingNames.filter((name) => !requiredSections.includes(name)),
      correctOrder: requiredSections
    };
  }
  /**
   * Convertit les sections simples en sections dÃ©taillÃ©es
   */
  convertToDetailedSections(sections, requiredSections) {
    return Object.entries(sections).map(([name, content]) => ({
      name,
      startLine: 0,
      // Ã€ implÃ©menter si nÃ©cessaire
      endLine: 0,
      // Ã€ implÃ©menter si nÃ©cessaire
      content,
      lines: content.split("\n"),
      isFromLayout: requiredSections.includes(name)
    }));
  }
  /**
   * CrÃ©e les sections manquantes dans un fichier
   */
  async createMissingSections(file) {
    var _a, _b;
    try {
      const analysis = await this.analyzeFile(file);
      if (analysis.missingSections.length === 0) {
        new import_obsidian.Notice("\u2705 Toutes les sections sont d\xE9j\xE0 pr\xE9sentes", 2e3);
        return false;
      }
      const content = await this.app.vault.read(file);
      const newContent = this.addMissingSectionsToContent(
        content,
        analysis.missingSections
      );
      await this.app.vault.modify(file, newContent);
      this.cache.invalidate(`sections-${file.path}`);
      new import_obsidian.Notice(
        `\u2705 ${analysis.missingSections.length} section(s) ajout\xE9e(s)`,
        3e3
      );
      (_a = this.logger) == null ? void 0 : _a.success("Sections manquantes cr\xE9\xE9es", {
        fileName: file.name,
        addedSections: analysis.missingSections
      });
      return true;
    } catch (error) {
      (_b = this.logger) == null ? void 0 : _b.error("Erreur cr\xE9ation sections manquantes", error);
      new import_obsidian.Notice("\u274C Erreur lors de la cr\xE9ation des sections");
      throw error;
    }
  }
  /**
   * CrÃ©e une nouvelle note avec un layout spÃ©cifique
   */
  async createNoteWithLayout(options) {
    var _a, _b, _c;
    (_a = this.logger) == null ? void 0 : _a.fileOperation("D\xE9but cr\xE9ation de note", { options });
    try {
      this.validateNoteCreationOptions(options);
      const layout = this.layoutService.getModel(options.layoutName);
      if (!layout) {
        throw AgileBoardError.layoutNotFound(options.layoutName);
      }
      const layoutInfo = this.layoutService.getModelInfo(options.layoutName);
      const displayName = (layoutInfo == null ? void 0 : layoutInfo.displayName) || options.layoutName;
      const fileName = this.generateFileName(displayName, options);
      const content = this.generateNoteContent(options, layout, layoutInfo);
      const file = await this.createFile(fileName, content, options.folder);
      if (options.autoOpen !== false) {
        await this.openFile(file);
      }
      new import_obsidian.Notice(`\u2705 Note "${displayName}" cr\xE9\xE9e avec succ\xE8s !`, 3e3);
      const result = {
        file,
        layoutName: options.layoutName,
        displayName,
        sectionsCount: layout.length
      };
      (_b = this.logger) == null ? void 0 : _b.success("Note cr\xE9\xE9e avec succ\xE8s", {
        fileName: result.file.name,
        filePath: result.file.path,
        layoutName: result.layoutName,
        sectionsCount: result.sectionsCount
      });
      return result;
    } catch (error) {
      (_c = this.logger) == null ? void 0 : _c.error("Erreur cr\xE9ation de note", error);
      new import_obsidian.Notice("\u274C Erreur lors de la cr\xE9ation de la note");
      throw error;
    }
  }
  // ===================================================================
  // MÃ‰THODES UTILITAIRES PRIVÃ‰ES
  // ===================================================================
  getLayoutName(file) {
    var _a;
    const fileCache = this.app.metadataCache.getFileCache(file);
    return ((_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"]) || null;
  }
  addMissingSectionsToContent(content, missingSections) {
    const lines = content.split("\n");
    const newSections = missingSections.map((sectionName) => [
      "",
      ParsingConstants.formatSectionHeader(sectionName),
      // <-- dynamique !
      "",
      " contenu ici ",
      ""
    ]).flat();
    return [...lines, ...newSections].join("\n");
  }
  validateNoteCreationOptions(options) {
    if (!options.layoutName || typeof options.layoutName !== "string") {
      throw AgileBoardError.validationError("layoutName", options.layoutName);
    }
  }
  generateFileName(displayName, options) {
    if (options.customFileName) {
      return options.customFileName.endsWith(".md") ? options.customFileName : `${options.customFileName}.md`;
    }
    const timestamp = new Date().toISOString().slice(0, 16).replace("T", "_");
    return `${displayName}_${timestamp}.md`;
  }
  generateNoteContent(options, layout, layoutInfo) {
    const sections = layout.map((block) => {
      var _a;
      const customContent = ((_a = options.customContent) == null ? void 0 : _a[block.title]) || "";
      return [
        ParsingConstants.formatSectionHeader(block.title),
        // Utilisation dynamique du niveau
        "",
        customContent || " contenu ici ",
        ""
      ].join("\n");
    });
    return [
      "---",
      `agile-board: ${options.layoutName}`,
      "---",
      "",
      ...sections
    ].join("\n");
  }
  async createFile(fileName, content, folder) {
    const safeFileName = ParsingConstants.sanitizeFileName(fileName);
    const fullPath = folder ? `${folder}/${safeFileName}` : safeFileName;
    if (folder && !this.app.vault.getAbstractFileByPath(folder)) {
      await this.app.vault.createFolder(folder);
    }
    return await this.app.vault.create(fullPath, content);
  }
  async openFile(file) {
    const leaf = this.app.workspace.getUnpinnedLeaf();
    await leaf.openFile(file);
  }
  /**
   * Dispose le service et nettoie les ressources
   */
  dispose() {
    this.cache.dispose();
  }
};

// src/services/PluginIntegrationManager.ts
var PluginIntegrationManager = class {
  constructor(app, logger) {
    this.observers = [];
    this.eventCleanupFunctions = [];
    this.app = app;
    this.logger = logger;
  }
  /**
   * Configure le support universel des plugins pour un container
   * @param container - Container oÃ¹ surveiller les plugins
   * @param onContentChange - Callback lors de changement de contenu
   * @param sourcePath - Chemin du fichier source pour le contexte
   */
  setupUniversalPluginSupport(container, onContentChange, sourcePath) {
    this.logger.info("\u{1F50C} Configuration support universel plugins");
    this.setupMutationObserver(container, sourcePath);
    this.setupEventDelegation(container, onContentChange, sourcePath);
    this.setupContextCorrection(container, sourcePath);
    this.applyPluginFallbacks(container);
  }
  /**
   * Surveille les changements DOM pour dÃ©tecter les nouveaux plugins
   */
  setupMutationObserver(container, sourcePath) {
    const observer = new MutationObserver((mutations) => {
      let hasPluginChanges = false;
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (this.isPluginElement(element)) {
                this.logger.debug("\u{1F50C} Nouveau plugin d\xE9tect\xE9:", element.className);
                hasPluginChanges = true;
              }
            }
          });
        }
        if (mutation.type === "attributes") {
          const element = mutation.target;
          if (this.isPluginElement(element)) {
            this.logger.debug("\u{1F504} Plugin modifi\xE9:", element.className);
            hasPluginChanges = true;
          }
        }
      });
      if (hasPluginChanges) {
        setTimeout(() => this.refreshPluginSupport(container, sourcePath), 100);
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["class", "data-task", "data-plugin", "data-dataview"]
    });
    this.observers.push(observer);
  }
  /**
   * Configure la dÃ©lÃ©gation d'Ã©vÃ©nements universelle
   */
  setupEventDelegation(container, onContentChange, sourcePath) {
    const eventTypes = ["click", "change", "input", "keyup", "blur", "focus"];
    eventTypes.forEach((eventType) => {
      const handler = (event) => {
        this.handleUniversalEvent(event, onContentChange, sourcePath);
      };
      container.addEventListener(eventType, handler, true);
      this.eventCleanupFunctions.push(() => {
        container.removeEventListener(eventType, handler, true);
      });
    });
  }
  /**
   * Gestionnaire universel d'Ã©vÃ©nements
   */
  handleUniversalEvent(event, onContentChange, sourcePath) {
    const target = event.target;
    if (this.isNavigationEvent(event, target)) {
      this.logger.debug("\u{1F9ED} \xC9v\xE9nement de navigation ignor\xE9:", event.type);
      return;
    }
    if (this.isContentModificationEvent(event, target)) {
      this.logger.debug("\u270F\uFE0F Modification d\xE9tect\xE9e:", event.type, target.tagName);
      setTimeout(() => {
        try {
          const newContent = this.extractCurrentContent(event.currentTarget);
          if (newContent !== null) {
            this.logger.debug("\u{1F504} Contenu modifi\xE9 par plugin, mise \xE0 jour");
            onContentChange(newContent);
          }
        } catch (error) {
          this.logger.warn("\u26A0\uFE0F Erreur extraction contenu apr\xE8s modification", error);
        }
      }, 150);
    }
  }
  /**
   * DÃ©termine si un Ã©vÃ©nement est de navigation (ne doit pas dÃ©clencher l'Ã©dition)
   */
  isNavigationEvent(event, target) {
    if (target.matches("a, a *, .internal-link, .internal-link *, .external-link, .external-link *")) {
      return true;
    }
    if (target.matches(".plugin-button, .dataview-button, .nav-button, .clickable-icon")) {
      return true;
    }
    if (target.matches(".tag, .tag *, .cm-hashtag, .cm-hashtag *")) {
      return true;
    }
    if (target.matches(".widget-button, .collapse-button, .expand-button")) {
      return true;
    }
    if (target.hasAttribute("data-href") || target.closest("[data-href]")) {
      return true;
    }
    return false;
  }
  /**
   * DÃ©termine si un Ã©vÃ©nement modifie le contenu
   */
  isContentModificationEvent(event, target) {
    if (target.matches('input[type="checkbox"]') && event.type === "change") {
      return true;
    }
    if (target.matches('[contenteditable="true"]') && ["input", "blur"].includes(event.type)) {
      return true;
    }
    if (target.matches('input[type="text"], input[type="number"], textarea, select') && ["change", "blur"].includes(event.type)) {
      return true;
    }
    if (target.matches("[data-editable], [data-modifiable]") && ["change", "click"].includes(event.type)) {
      return true;
    }
    if (target.matches(".task-toggle, .dataview-edit, .plugin-edit") && event.type === "click") {
      return true;
    }
    return false;
  }
  /**
   * Extrait le contenu actuel du container sous forme markdown
   */
  extractCurrentContent(container) {
    try {
      return this.convertHtmlToMarkdown(container);
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur extraction contenu", error);
      return null;
    }
  }
  /**
   * Convertit HTML gÃ©nÃ©rÃ© par Obsidian vers Markdown
   */
  convertHtmlToMarkdown(container) {
    return this.smartHtmlToMarkdownConversion(container);
  }
  /**
   * Conversion intelligente HTML â†’ Markdown
   */
  smartHtmlToMarkdownConversion(container) {
    const lines = [];
    this.walkNodes(container, (node) => {
      var _a;
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const markdown = this.convertElementToMarkdown(element);
        if (markdown) {
          lines.push(markdown);
        }
      } else if (node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) == null ? void 0 : _a.trim())) {
        const text = node.textContent.trim();
        if (text && !this.isWhitespaceOnly(text)) {
          lines.push(text);
        }
      }
    });
    return lines.filter((line) => line.trim().length > 0).join("\n").replace(/\n\n+/g, "\n\n");
  }
  /**
   * Parcourt les nÅ“uds de maniÃ¨re intelligente
   */
  walkNodes(container, callback) {
    Array.from(container.childNodes).forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        if (!element.matches("script, style, .hover-popover")) {
          callback(node);
        }
      } else {
        callback(node);
      }
    });
  }
  /**
   * Convertit un Ã©lÃ©ment HTML spÃ©cifique en Markdown
   */
  convertElementToMarkdown(element) {
    if (element.matches(".sr-only, .screen-reader-text, script, style")) {
      return "";
    }
    if (element.matches('.task-list-item, li:has(input[type="checkbox"])')) {
      return this.convertTaskToMarkdown(element);
    }
    if (element.matches("ul, ol")) {
      return this.convertListToMarkdown(element);
    }
    if (element.matches("p")) {
      return this.getTextContent(element);
    }
    if (element.matches("h1, h2, h3, h4, h5, h6")) {
      const level = parseInt(element.tagName.substring(1));
      return "#".repeat(level) + " " + this.getTextContent(element);
    }
    if (element.matches("pre, .cm-editor")) {
      const code = this.getTextContent(element);
      const language = this.detectCodeLanguage(element);
      return language ? `\`\`\`${language}
${code}
\`\`\`` : `\`\`\`
${code}
\`\`\``;
    }
    if (element.matches("code") && !element.closest("pre")) {
      return `\`${this.getTextContent(element)}\``;
    }
    if (this.isPluginElement(element)) {
      return this.preservePluginContent(element);
    }
    return this.getTextContent(element);
  }
  /**
   * Convertit une tÃ¢che en Markdown (compatible tous plugins)
   */
  convertTaskToMarkdown(element) {
    const checkbox = element.querySelector('input[type="checkbox"]');
    const isChecked = checkbox ? checkbox.checked : false;
    const checkState = isChecked ? "[x]" : "[ ]";
    let taskText = "";
    const dataTask = element.getAttribute("data-task");
    if (dataTask) {
      taskText = dataTask;
    } else {
      const clonedElement = element.cloneNode(true);
      const clonedCheckbox = clonedElement.querySelector('input[type="checkbox"]');
      if (clonedCheckbox) {
        clonedCheckbox.remove();
      }
      taskText = this.getTextContent(clonedElement).trim();
    }
    return `- ${checkState} ${taskText}`;
  }
  /**
   * Convertit une liste en Markdown
   */
  convertListToMarkdown(element) {
    const isOrdered = element.tagName.toLowerCase() === "ol";
    const items = [];
    const listItems = Array.from(element.children).filter(
      (child) => child.tagName.toLowerCase() === "li"
    );
    listItems.forEach((li, index) => {
      const prefix = isOrdered ? `${index + 1}.` : "-";
      const content = this.convertElementToMarkdown(li);
      if (content) {
        items.push(`${prefix} ${content}`);
      }
    });
    return items.join("\n");
  }
  /**
   * DÃ©tecte le langage d'un bloc de code
   */
  detectCodeLanguage(element) {
    const classList = Array.from(element.classList);
    for (const className of classList) {
      if (className.startsWith("language-")) {
        return className.substring(9);
      }
      if (className.startsWith("cm-")) {
        return className.substring(3);
      }
    }
    const lang = element.getAttribute("data-language") || element.getAttribute("data-lang");
    if (lang)
      return lang;
    return "";
  }
  /**
   * PrÃ©serve le contenu d'un Ã©lÃ©ment de plugin
   */
  preservePluginContent(element) {
    const originalMarkdown = element.getAttribute("data-original-markdown");
    if (originalMarkdown) {
      return originalMarkdown;
    }
    if (element.matches(".dataview, .block-language-dataview")) {
      return this.reconstructDataviewMarkdown(element);
    }
    if (element.matches(".tasks-plugin, [data-task], .block-language-tasks")) {
      return this.reconstructTasksMarkdown(element);
    }
    if (element.matches(".kanban-plugin")) {
      return this.reconstructKanbanMarkdown(element);
    }
    return this.getTextContent(element);
  }
  /**
   * Reconstruit le markdown Dataview
   */
  reconstructDataviewMarkdown(element) {
    var _a;
    const query = element.getAttribute("data-query") || ((_a = element.querySelector(".dataview-query")) == null ? void 0 : _a.textContent) || element.getAttribute("data-dv-query");
    if (query) {
      return "```dataview\n" + query + "\n```";
    }
    const content = this.getTextContent(element);
    if (content.includes("TABLE") || content.includes("LIST") || content.includes("TASK")) {
      return "```dataview\n" + content + "\n```";
    }
    return content;
  }
  /**
   * Reconstruit le markdown Tasks
   */
  reconstructTasksMarkdown(element) {
    var _a;
    const query = element.getAttribute("data-tasks-query") || ((_a = element.querySelector(".tasks-query")) == null ? void 0 : _a.textContent) || element.getAttribute("data-query");
    if (query) {
      return "```tasks\n" + query + "\n```";
    }
    const content = this.getTextContent(element);
    if (content.includes("not done") || content.includes("done") || content.includes("due")) {
      return "```tasks\n" + content + "\n```";
    }
    return content;
  }
  /**
   * Reconstruit le markdown Kanban
   */
  reconstructKanbanMarkdown(element) {
    const config = element.getAttribute("data-kanban-config");
    if (config) {
      return "```kanban\n" + config + "\n```";
    }
    return this.getTextContent(element);
  }
  /**
   * Obtient le contenu textuel d'un Ã©lÃ©ment de maniÃ¨re sÃ©curisÃ©e
   */
  getTextContent(element) {
    var _a;
    try {
      return ((_a = element.textContent) == null ? void 0 : _a.trim()) || "";
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur extraction textContent", error);
      return "";
    }
  }
  /**
   * VÃ©rifie si une chaÃ®ne ne contient que des espaces
   */
  isWhitespaceOnly(text) {
    return /^\s*$/.test(text);
  }
  /**
   * DÃ©termine si un Ã©lÃ©ment appartient Ã  un plugin
   */
  isPluginElement(element) {
    const pluginIndicators = [
      // Classes gÃ©nÃ©riques de plugins
      ".dataview",
      ".tasks-plugin",
      ".pomodoro-timer",
      ".kanban-plugin",
      ".calendar-plugin",
      ".templater-plugin",
      ".quickadd-plugin",
      // Attributs de donnÃ©es
      "[data-plugin]",
      "[data-task]",
      "[data-dataview]",
      "[data-kanban]",
      // Blocs de code de plugins
      ".block-language-dataview",
      ".block-language-tasks",
      ".block-language-kanban",
      ".block-language-mermaid",
      // PrÃ©fixes de classes
      ".plugin-",
      ".widget-",
      ".obsidian-",
      // Ã‰lÃ©ments interactifs de plugins
      ".task-list-item",
      ".dataview-table",
      ".dataview-list",
      ".tasks-widget",
      ".calendar-widget",
      // Conteneurs de plugins
      '[data-type="plugin"]',
      ".plugin-content",
      ".widget-content"
    ];
    return pluginIndicators.some((selector) => {
      try {
        return element.matches(selector);
      } catch (error) {
        return false;
      }
    });
  }
  /**
   * RafraÃ®chit le support des plugins
   */
  refreshPluginSupport(container, sourcePath) {
    this.logger.debug("\u{1F504} Rafra\xEEchissement support plugins");
    const pluginElements = container.querySelectorAll(
      ".dataview, .tasks-plugin, .pomodoro-timer, [data-plugin], .plugin-"
    );
    this.logger.debug(`\u{1F50C} ${pluginElements.length} \xE9l\xE9ments de plugins d\xE9tect\xE9s apr\xE8s rafra\xEEchissement`);
    this.setupContextCorrection(container, sourcePath);
  }
  /**
   * Configure la correction de contexte pour les plugins
   */
  setupContextCorrection(container, sourcePath) {
    setTimeout(() => {
      const pluginElements = container.querySelectorAll("[data-plugin], .plugin-content, .dataview, .tasks-plugin");
      pluginElements.forEach((element) => {
        try {
          if (!element.getAttribute("data-source-path")) {
            element.setAttribute("data-source-path", sourcePath);
          }
          if (!element.getAttribute("data-app-context")) {
            element.setAttribute("data-app-context", "agile-board");
          }
        } catch (error) {
          this.logger.warn("\u26A0\uFE0F Erreur ajout contexte plugin", error);
        }
      });
    }, 200);
  }
  /**
   * Applique des fallbacks pour plugins problÃ©matiques
   */
  applyPluginFallbacks(container) {
    setTimeout(() => {
      const brokenDataview = container.querySelectorAll(".block-language-dataview:empty, .dataview:empty");
      brokenDataview.forEach((element) => {
        var _a;
        if (!((_a = element.textContent) == null ? void 0 : _a.trim())) {
          element.innerHTML = "<em>\u{1F4CA} Dataview en cours de chargement...</em>";
        }
      });
    }, 2e3);
    setTimeout(() => {
      const brokenTasks = container.querySelectorAll(".block-language-tasks:empty, .tasks-plugin:empty");
      brokenTasks.forEach((element) => {
        var _a;
        if (!((_a = element.textContent) == null ? void 0 : _a.trim())) {
          element.innerHTML = "<em>\u2705 Tasks en cours de chargement...</em>";
        }
      });
    }, 2e3);
    setTimeout(() => {
      try {
        const event = new CustomEvent("obsidian:plugin-reload", {
          detail: { container, timestamp: Date.now() }
        });
        document.dispatchEvent(event);
      } catch (error) {
        this.logger.warn("\u26A0\uFE0F Erreur dispatch \xE9v\xE9nement plugin-reload", error);
      }
    }, 3e3);
  }
  /**
   * Nettoie les ressources
   */
  dispose() {
    this.logger.debug("\u{1F9F9} Nettoyage PluginIntegrationManager");
    this.observers.forEach((observer) => {
      try {
        observer.disconnect();
      } catch (error) {
        this.logger.warn("\u26A0\uFE0F Erreur disconnect observer", error);
      }
    });
    this.observers = [];
    this.eventCleanupFunctions.forEach((cleanup) => {
      try {
        cleanup();
      } catch (error) {
        this.logger.warn("\u26A0\uFE0F Erreur cleanup event listener", error);
      }
    });
    this.eventCleanupFunctions = [];
  }
  /**
   * Statistiques pour debugging
   */
  getStats() {
    return {
      observers: this.observers.length,
      eventListeners: this.eventCleanupFunctions.length
    };
  }
};

// src/services/ServiceContainer.ts
var ServiceContainer = class {
  constructor(app, plugin, settings) {
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.logger = new LoggerService(plugin, settings.debug);
    this.cache = new FileCache();
    this.layout = new LayoutService(plugin);
    this.file = new FileService(this.app, this.layout, this.logger);
    this.pluginIntegration = new PluginIntegrationManager(this.app, this.logger);
  }
  /**
   * Initialise tous les services
   */
  async initialize() {
    this.logger.info("Initialisation du container de services avec support universel plugins");
    try {
      this.layout.load();
      this.logger.success("Container de services initialis\xE9 avec support universel", {
        layoutsCount: this.layout.getAllModelNames().length,
        cacheStats: this.cache.getStats(),
        pluginSupportEnabled: true
      });
    } catch (error) {
      this.logger.error("Erreur initialisation container", error);
      throw error;
    }
  }
  /**
   * Met Ã  jour les paramÃ¨tres
   */
  updateSettings(settings) {
    this.logger.updateSettings(settings.debug);
  }
  /**
   * Dispose tous les services
   */
  dispose() {
    this.logger.info("Nettoyage du container de services");
    try {
      this.pluginIntegration.dispose();
      this.file.dispose();
      this.cache.dispose();
      this.logger.info("\u2705 Container de services nettoy\xE9 avec succ\xE8s");
    } catch (error) {
      this.logger.error("\u274C Erreur lors du nettoyage du container", error);
    }
  }
  /**
   * Statistiques pour debugging
   */
  getStats() {
    return {
      layouts: this.layout.getAllModelNames().length,
      cache: this.cache.getStats(),
      pluginIntegration: this.pluginIntegration.getStats(),
      logger: {
        level: this.settings.debug.logLevel,
        enabled: this.settings.debug.enabled
      }
    };
  }
};

// src/utils/settings.ts
var DEFAULT_SETTINGS = {
  autoCreateSections: true,
  defaultLayouts: ["layout_kanban", "layout_eisenhower", "layout_gtd"],
  debug: {
    enabled: false,
    // Debug dÃ©sactivÃ© par dÃ©faut (production)
    logLevel: 3 /* INFO */,
    // Niveau INFO par dÃ©faut
    showTimestamps: true,
    // Affichage des timestamps
    showSourceLocation: true,
    // Affichage de la source des logs
    logToFile: false,
    // Pas de sauvegarde fichier par dÃ©faut
    logToConsole: true,
    // Console activÃ©e par dÃ©faut
    logFileName: "agile-board-debug.log",
    // Nom du fichier de log
    maxLogFileSize: 5 * 1024 * 1024,
    // 5MB maximum avant rotation
    autoSaveInterval: 5
    // Sauvegarde automatique toutes les 5 minutes
  },
  // âœ… NOUVEAU : Configuration du support universel des plugins
  pluginSupport: {
    enabled: true,
    // Support universel activÃ© par dÃ©faut
    loadTimeout: 1e4,
    // 10 secondes pour charger les plugins
    fallbackDelay: 2e3,
    // 2 secondes avant fallback
    supportedPlugins: [
      // Plugins explicitement supportÃ©s
      "dataview",
      "tasks",
      "calendar",
      "kanban",
      "templater",
      "quickadd",
      "pomodoro-timer",
      "mermaid",
      "excalidraw",
      "charts"
    ],
    ignoredPlugins: [
      // Plugins Ã  ignorer
      "workspaces",
      "file-explorer",
      "search",
      "command-palette"
    ],
    debugMode: false
    // Debug plugins dÃ©sactivÃ© par dÃ©faut
  },
  ui: {
    theme: "auto",
    showThumbnails: true,
    compactMode: false,
    // âœ… NOUVEAU : Options d'interface pour les plugins
    pluginUI: {
      showPluginIndicators: true,
      // Afficher les indicateurs de plugins
      showPluginTooltips: true,
      // Afficher les tooltips d'aide
      pluginTheme: "auto"
      // ThÃ¨me automatique pour les plugins
    }
  }
};
var DEVELOPMENT_SETTINGS = {
  debug: {
    enabled: true,
    logLevel: 5 /* VERBOSE */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: false,
    // Console uniquement pour dev
    logToConsole: true,
    logFileName: "agile-board-dev.log",
    maxLogFileSize: 2 * 1024 * 1024,
    // 2MB pour le dev
    autoSaveInterval: 1
    // Sauvegarde toutes les 1 minute pour dev
  },
  // âœ… Configuration dÃ©veloppement pour plugins
  pluginSupport: {
    enabled: true,
    loadTimeout: 15e3,
    // Plus de temps en dev
    fallbackDelay: 1e3,
    // Fallback plus rapide
    debugMode: true,
    // Debug plugins activÃ© en dev
    supportedPlugins: ["*"],
    // Tous les plugins en dev
    ignoredPlugins: []
    // Aucun plugin ignorÃ© en dev
  }
};
var DIAGNOSTIC_SETTINGS = {
  debug: {
    enabled: true,
    logLevel: 4 /* DEBUG */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: true,
    // Fichier pour partager les logs
    logToConsole: false,
    // Pas de pollution console en diagnostic
    logFileName: "agile-board-diagnostic.log",
    maxLogFileSize: 1024 * 1024,
    // 1MB pour diagnostic
    autoSaveInterval: 5
    // Sauvegarde toutes les 5 minutes
  },
  // âœ… Configuration diagnostic pour plugins
  pluginSupport: {
    enabled: true,
    loadTimeout: 2e4,
    // Timeout Ã©tendu pour diagnostic
    fallbackDelay: 5e3,
    // Fallback retardÃ©
    debugMode: true,
    // Debug activÃ© pour diagnostic
    supportedPlugins: ["*"],
    // Tous les plugins
    ignoredPlugins: []
    // Aucun ignorÃ© pour diagnostic complet
  }
};
var PRODUCTION_SETTINGS = {
  debug: {
    enabled: true,
    // Logs d'erreurs seulement
    logLevel: 1 /* ERROR */,
    showTimestamps: false,
    // Moins verbeux
    showSourceLocation: false,
    logToFile: true,
    // Garder les erreurs en fichier
    logToConsole: false,
    // Pas de pollution console
    logFileName: "agile-board-errors.log",
    maxLogFileSize: 512 * 1024,
    // 512KB pour erreurs seulement
    autoSaveInterval: 10
    // Sauvegarde toutes les 10 minutes
  },
  // âœ… Configuration production pour plugins (optimisÃ©e)
  pluginSupport: {
    enabled: true,
    loadTimeout: 8e3,
    // Timeout rÃ©duit en production
    fallbackDelay: 1500,
    // Fallback rapide
    debugMode: false,
    // Pas de debug en production
    supportedPlugins: [
      // Plugins essentiels uniquement
      "dataview",
      "tasks",
      "calendar",
      "kanban"
    ],
    ignoredPlugins: [
      // Ignorer les plugins non-essentiels
      "workspaces",
      "file-explorer",
      "search",
      "command-palette",
      "audio-recorder",
      "slides"
    ]
  }
};
var PLUGIN_TESTING_SETTINGS = {
  debug: {
    enabled: true,
    logLevel: 5 /* VERBOSE */,
    showTimestamps: true,
    showSourceLocation: true,
    logToFile: true,
    logToConsole: true,
    logFileName: "agile-board-plugin-test.log",
    maxLogFileSize: 10 * 1024 * 1024,
    // 10MB pour tests approfondis
    autoSaveInterval: 1
  },
  pluginSupport: {
    enabled: true,
    loadTimeout: 3e4,
    // 30 secondes pour les tests
    fallbackDelay: 500,
    // Fallback trÃ¨s rapide pour voir les erreurs
    debugMode: true,
    supportedPlugins: ["*"],
    // Tous les plugins pour tests
    ignoredPlugins: []
  },
  ui: {
    theme: "auto",
    showThumbnails: true,
    compactMode: false,
    pluginUI: {
      showPluginIndicators: true,
      showPluginTooltips: true,
      pluginTheme: "enhanced"
      // Interface enrichie pour les tests
    }
  }
};
var SettingsUtils = class {
  /**
   * Fusionne des configurations de maniÃ¨re sÃ©curisÃ©e
   */
  static mergeSettings(base, override) {
    var _a, _b;
    return {
      ...base,
      ...override,
      debug: {
        ...base.debug,
        ...override.debug
      },
      pluginSupport: {
        ...base.pluginSupport,
        ...override.pluginSupport
      },
      ui: {
        ...base.ui,
        ...override.ui,
        pluginUI: {
          ...(_a = base.ui) == null ? void 0 : _a.pluginUI,
          ...(_b = override.ui) == null ? void 0 : _b.pluginUI
        }
      }
    };
  }
  /**
   * Valide une configuration de plugin
   */
  static validatePluginConfig(config) {
    if (!config)
      return false;
    if (config.loadTimeout && (config.loadTimeout < 1e3 || config.loadTimeout > 6e4)) {
      return false;
    }
    if (config.fallbackDelay && (config.fallbackDelay < 100 || config.fallbackDelay > 1e4)) {
      return false;
    }
    if (config.supportedPlugins && !Array.isArray(config.supportedPlugins)) {
      return false;
    }
    if (config.ignoredPlugins && !Array.isArray(config.ignoredPlugins)) {
      return false;
    }
    return true;
  }
  /**
   * Obtient la configuration optimale selon l'environnement
   */
  static getOptimalSettings(environment) {
    const base = DEFAULT_SETTINGS;
    switch (environment) {
      case "development":
        return SettingsUtils.mergeSettings(base, DEVELOPMENT_SETTINGS);
      case "production":
        return SettingsUtils.mergeSettings(base, PRODUCTION_SETTINGS);
      case "testing":
        return SettingsUtils.mergeSettings(base, PLUGIN_TESTING_SETTINGS);
      case "diagnostic":
        return SettingsUtils.mergeSettings(base, DIAGNOSTIC_SETTINGS);
      default:
        return base;
    }
  }
  /**
   * DÃ©tecte automatiquement l'environnement
   */
  static detectEnvironment() {
    if (true) {
      return "development";
    }
    if (false) {
      return "testing";
    }
    if (localStorage.getItem("agile-board-diagnostic") === "true") {
      return "diagnostic";
    }
    return "production";
  }
};

// src/views/BoardView.ts
var import_obsidian2 = require("obsidian");

// src/components/MarkdownFrame.ts
var MarkdownFrame = class {
  // ===========================================================================
  // CONSTRUCTEUR ET INITIALISATION
  // ===========================================================================
  constructor(app, container, file, section, onChange, logger) {
    this.app = app;
    this.container = container;
    this.file = file;
    this.section = section;
    this.onChange = onChange;
    // ===========================================================================
    // PROPRIÃ‰TÃ‰S D'Ã‰TAT DU COMPOSANT
    // ===========================================================================
    this.isEditing = false;
    // âœ… NOUVEAU : Ã‰tats de rendu amÃ©liorÃ©s
    this.isInErrorState = false;
    this.renderAttempts = 0;
    this.MAX_RENDER_ATTEMPTS = 3;
    this.logger = logger;
    try {
      this.validateConstructorParams();
      this.content = section.lines.join("\n");
      this.pluginManager = new PluginIntegrationManager(this.app, this.logger);
      this.initializeFrame();
      this.logger.info("\u2705 MarkdownFrame initialis\xE9 avec support universel plugins", {
        sectionName: section.name,
        contentLength: this.content.length
      });
    } catch (error) {
      this.logger.error("\u274C Erreur critique lors de l'initialisation de MarkdownFrame", error);
      this.initializeErrorState();
    }
  }
  /**
   * âœ… Validation des paramÃ¨tres du constructeur
   */
  validateConstructorParams() {
    if (!this.app) {
      throw new Error("App Obsidian requis");
    }
    if (!this.container) {
      throw new Error("Container DOM requis");
    }
    if (!this.file) {
      throw new Error("Fichier TFile requis");
    }
    if (!this.section) {
      throw new Error("Section FileSection requise");
    }
    if (!this.onChange || typeof this.onChange !== "function") {
      throw new Error("Callback onChange requis");
    }
    if (!this.logger) {
      throw new Error("Logger requis");
    }
  }
  /**
   * âœ… Initialise un Ã©tat d'erreur de base
   */
  initializeErrorState() {
    try {
      this.isInErrorState = true;
      this.container.empty();
      const errorDiv = this.container.createDiv("markdown-frame-error");
      errorDiv.innerHTML = `
        <div style="
          color: var(--text-error);
          background: var(--background-secondary);
          border: 1px solid var(--background-modifier-border);
          border-radius: 4px;
          padding: 1rem;
          text-align: center;
        ">
          <h4>\u26A0\uFE0F Erreur de composant</h4>
          <p>Impossible d'initialiser cette section.</p>
          <button onclick="location.reload()" style="
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
          ">
            \u{1F504} Recharger
          </button>
        </div>
      `;
    } catch (fallbackError) {
      this.logger.error("\u274C Erreur critique dans initializeErrorState", fallbackError);
      this.container.textContent = "\u26A0\uFE0F Erreur critique - Veuillez recharger la page";
    }
  }
  /**
   * Initialise complÃ¨tement l'interface du composant
   */
  initializeFrame() {
    try {
      this.setupContainer();
      this.createPreviewContainer();
      this.createEditorContainer();
      this.showPreview();
    } catch (error) {
      this.logger.error("\u274C Erreur lors de l'initialisation de la frame", error);
      this.initializeErrorState();
    }
  }
  /**
   * Configure le conteneur principal du composant
   */
  setupContainer() {
    try {
      this.container.empty();
      this.container.style.cssText = `
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
      `;
    } catch (error) {
      this.logger.error("\u274C Erreur setupContainer", error);
      throw error;
    }
  }
  // ===========================================================================
  // CRÃ‰ATION DES INTERFACES PREVIEW ET Ã‰DITION
  // ===========================================================================
  /**
   * CrÃ©e et configure le conteneur de preview (affichage rendu)
   */
  createPreviewContainer() {
    try {
      this.previewContainer = this.container.createDiv("markdown-preview");
      this.previewContainer.style.cssText = `
        width: 100%;
        height: 100%;
        overflow: auto;
        padding: 0.5rem;
        cursor: text;
        box-sizing: border-box;
      `;
      this.renderContent();
      this.setupPreviewEvents();
    } catch (error) {
      this.logger.error("\u274C Erreur createPreviewContainer", error);
      throw error;
    }
  }
  /**
   * CrÃ©e et configure le conteneur d'Ã©dition (textarea)
   */
  createEditorContainer() {
    try {
      this.editorContainer = this.container.createDiv("markdown-editor");
      this.editorContainer.style.cssText = `
        width: 100%;
        height: 100%;
        display: none;
        box-sizing: border-box;
      `;
      this.textArea = this.editorContainer.createEl("textarea");
      this.textArea.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
        resize: none;
        font-family: var(--font-text);
        font-size: var(--font-size-normal);
        background: transparent;
        color: var(--text-normal);
        padding: 0.5rem;
        box-sizing: border-box;
        line-height: 1.6;
      `;
      this.textArea.value = this.content;
      this.setupEditorEvents();
    } catch (error) {
      this.logger.error("\u274C Erreur createEditorContainer", error);
      throw error;
    }
  }
  // ===========================================================================
  // MOTEUR DE RENDU MARKDOWN AVEC SUPPORT UNIVERSEL PLUGINS
  // ===========================================================================
  /**
   * âœ… NOUVEAU : Rend le contenu markdown avec support universel des plugins
   */
  async renderContent() {
    if (this.renderAttempts >= this.MAX_RENDER_ATTEMPTS) {
      this.logger.warn("\u{1F6AB} Nombre maximum de tentatives de rendu atteint", {
        attempts: this.renderAttempts,
        sectionName: this.section.name
      });
      this.renderPermanentFallback();
      return;
    }
    this.renderAttempts++;
    try {
      this.validateRenderState();
      this.previewContainer.empty();
      if (!this.content.trim()) {
        this.renderEmptyState();
        this.resetRenderAttempts();
        return;
      }
      await this.attemptUniversalRender();
      this.resetRenderAttempts();
      this.isInErrorState = false;
      this.logger.info("\u2705 Contenu rendu avec support universel plugins", {
        contentLength: this.content.length,
        attempt: this.renderAttempts
      });
    } catch (error) {
      this.logger.error("\u274C Erreur lors du rendu du contenu", {
        error: error.message,
        attempt: this.renderAttempts,
        sectionName: this.section.name
      });
      await this.handleRenderError(error);
    }
  }
  /**
   * âœ… Validation de l'Ã©tat avant rendu
   */
  validateRenderState() {
    if (!this.previewContainer) {
      throw new Error("previewContainer non initialis\xE9");
    }
    if (this.content === null || this.content === void 0) {
      throw new Error("Contenu invalide");
    }
    if (!this.file || !this.file.path) {
      throw new Error("Fichier invalide");
    }
  }
  /**
   * âœ… NOUVEAU : Tentative de rendu avec support universel des plugins
   */
  async attemptUniversalRender() {
    var _a;
    try {
      const obsidianModules = await this.safeRequireObsidian();
      if (!obsidianModules) {
        throw new Error("Modules Obsidian non disponibles");
      }
      const { MarkdownRenderer, Component } = obsidianModules;
      const component = new Component();
      component.load();
      const renderContext = {
        sourcePath: this.file.path,
        frontmatter: ((_a = this.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.frontmatter) || {},
        component
      };
      await Promise.race([
        MarkdownRenderer.renderMarkdown(
          this.content,
          this.previewContainer,
          this.file.path,
          component
        ),
        this.createTimeoutPromise(1e4)
        // 10 secondes pour les plugins
      ]);
      await this.waitForPluginsAndSetupSupport();
    } catch (error) {
      throw new Error(`Rendu universel \xE9chou\xE9: ${error.message}`);
    }
  }
  /**
   * âœ… NOUVEAU : Attend les plugins et configure le support universel
   */
  async waitForPluginsAndSetupSupport() {
    return new Promise((resolve) => {
      setTimeout(() => {
        try {
          this.pluginManager.setupUniversalPluginSupport(
            this.previewContainer,
            (newContent) => {
              this.handleContentChangeFromPlugin(newContent);
            },
            this.file.path
          );
          const pluginElements = this.previewContainer.querySelectorAll(
            ".dataview, .tasks-plugin, .task-list-item, [data-plugin], .plugin-"
          );
          this.logger.debug(`\u2705 Support universel configur\xE9 - ${pluginElements.length} \xE9l\xE9ments de plugins d\xE9tect\xE9s`);
          resolve();
        } catch (error) {
          this.logger.warn("\u26A0\uFE0F Erreur configuration support universel", error);
          resolve();
        }
      }, 600);
    });
  }
  /**
   * âœ… NOUVEAU : GÃ¨re les changements de contenu provenant des plugins
   */
  handleContentChangeFromPlugin(newContent) {
    try {
      if (newContent !== this.content) {
        this.content = newContent;
        if (this.isEditing && this.textArea) {
          this.textArea.value = newContent;
        }
        clearTimeout(this.changeTimeout);
        this.changeTimeout = setTimeout(() => {
          try {
            this.onChange(this.content);
          } catch (error) {
            this.logger.error("\u274C Erreur callback onChange depuis plugin", error);
          }
        }, 300);
        this.logger.debug("\u{1F504} Contenu mis \xE0 jour depuis plugin");
      }
    } catch (error) {
      this.logger.error("\u274C Erreur handleContentChangeFromPlugin", error);
    }
  }
  /**
   * âœ… Import sÃ©curisÃ© des modules Obsidian
   */
  async safeRequireObsidian() {
    try {
      return require("obsidian");
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Modules Obsidian non disponibles via require", error);
      if (this.app && this.app.MarkdownRenderer) {
        return {
          MarkdownRenderer: this.app.MarkdownRenderer,
          Component: this.app.Component || class Component {
            load() {
            }
          }
        };
      }
      return null;
    }
  }
  /**
   * âœ… CrÃ©e une promesse de timeout
   */
  createTimeoutPromise(ms) {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Timeout apr\xE8s ${ms}ms`)), ms);
    });
  }
  /**
   * âœ… Gestion intelligente des erreurs de rendu
   */
  async handleRenderError(error) {
    const errorMessage = error.message.toLowerCase();
    if (errorMessage.includes("timeout")) {
      this.logger.warn("\u23F1\uFE0F Timeout de rendu - Passage en mode simple");
      this.renderSimpleFallback();
    } else if (errorMessage.includes("module") || errorMessage.includes("require")) {
      this.logger.warn("\u{1F4E6} Erreur de module - Passage en rendu de base");
      this.renderBasicMarkdown();
    } else if (this.renderAttempts < this.MAX_RENDER_ATTEMPTS) {
      this.logger.warn("\u{1F504} Nouvelle tentative de rendu dans 1 seconde");
      setTimeout(() => this.renderContent(), 1e3);
    } else {
      this.logger.error("\u{1F4A5} \xC9chec d\xE9finitif du rendu - Mode texte brut");
      this.renderPermanentFallback();
    }
  }
  /**
   * âœ… Fallback simple avec markdown de base
   */
  renderSimpleFallback() {
    try {
      this.previewContainer.empty();
      this.previewContainer.innerHTML = this.renderSimpleMarkdown(this.content);
      const indicator = this.previewContainer.createDiv("fallback-indicator");
      indicator.style.cssText = `
        position: absolute;
        top: 4px;
        right: 4px;
        background: var(--background-modifier-warning);
        color: var(--text-warning);
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.7em;
        opacity: 0.7;
      `;
      indicator.textContent = "\u26A0\uFE0F Mode simplifi\xE9";
    } catch (error) {
      this.logger.error("\u274C Erreur dans renderSimpleFallback", error);
      this.renderPermanentFallback();
    }
  }
  /**
   * âœ… Fallback avec markdown basique
   */
  renderBasicMarkdown() {
    try {
      this.previewContainer.empty();
      const lines = this.content.split("\n");
      for (const line of lines) {
        const lineEl = this.previewContainer.createDiv("basic-line");
        lineEl.style.marginBottom = "0.5em";
        lineEl.textContent = line || " ";
      }
    } catch (error) {
      this.logger.error("\u274C Erreur dans renderBasicMarkdown", error);
      this.renderPermanentFallback();
    }
  }
  /**
   * âœ… Fallback permanent en cas d'Ã©chec total
   */
  renderPermanentFallback() {
    try {
      this.isInErrorState = true;
      this.previewContainer.empty();
      const errorContainer = this.previewContainer.createDiv("permanent-fallback");
      errorContainer.innerHTML = `
        <div style="
          color: var(--text-error);
          background: var(--background-secondary);
          border: 1px dashed var(--background-modifier-border);
          border-radius: 4px;
          padding: 1rem;
          margin-bottom: 1rem;
        ">
          <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
            <span style="margin-right: 0.5rem;">\u26A0\uFE0F</span>
            <strong>Erreur de rendu</strong>
          </div>
          <p style="margin: 0; opacity: 0.8;">
            Affichage du contenu en mode texte brut. 
            <button onclick="location.reload()" style="
              background: none; 
              border: none; 
              color: var(--text-accent); 
              text-decoration: underline; 
              cursor: pointer;
            ">Recharger</button>
          </p>
        </div>
      `;
      const contentEl = errorContainer.createEl("pre");
      contentEl.style.cssText = `
        white-space: pre-wrap;
        font-family: var(--font-text);
        font-size: var(--font-size-normal);
        color: var(--text-normal);
        background: var(--background-primary);
        padding: 1rem;
        border-radius: 4px;
        overflow: auto;
      `;
      contentEl.textContent = this.content;
    } catch (finalError) {
      this.logger.error("\u274C Erreur critique dans renderPermanentFallback", finalError);
      this.previewContainer.textContent = `\u26A0\uFE0F ERREUR CRITIQUE

${this.content}`;
    }
  }
  /**
   * Reset sÃ©curisÃ© du compteur de tentatives
   */
  resetRenderAttempts() {
    this.renderAttempts = 0;
  }
  /**
   * Moteur de rendu markdown simple (fallback)
   */
  renderSimpleMarkdown(content) {
    try {
      let html = content;
      html = html.replace(/\[\[([^\]]+)\]\]/g, '<span class="internal-link">$1</span>');
      html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
      html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
      html = html.replace(/^[\s]*[-*+] (.+)$/gm, "<li>$1</li>");
      const lines = html.split("\n");
      let result = "";
      let inList = false;
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.includes("<li>")) {
          if (!inList) {
            result += "<ul>\n";
            inList = true;
          }
          result += line + "\n";
        } else {
          if (inList) {
            result += "</ul>\n";
            inList = false;
          }
          if (trimmed === "") {
            result += "<br>\n";
          } else {
            result += `<p>${trimmed}</p>
`;
          }
        }
      }
      if (inList) {
        result += "</ul>\n";
      }
      return result;
    } catch (error) {
      this.logger.error("\u274C Erreur renderSimpleMarkdown", error);
      return `<pre>${content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
    }
  }
  /**
   * Affiche un Ã©tat vide engageant
   */
  renderEmptyState() {
    try {
      const placeholder = this.previewContainer.createDiv("empty-placeholder");
      placeholder.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 80px;
        color: var(--text-muted);
        font-style: italic;
        cursor: text;
      `;
      placeholder.textContent = "Cliquez pour commencer \xE0 \xE9crire...";
    } catch (error) {
      this.logger.error("\u274C Erreur renderEmptyState", error);
      this.previewContainer.textContent = "Cliquez pour \xE9crire...";
    }
  }
  // ===========================================================================
  // GESTION DES Ã‰VÃ‰NEMENTS SIMPLIFIÃ‰E (VERSION UNIVERSELLE)
  // ===========================================================================
  /**
   * âœ… NOUVEAU : Configuration des Ã©vÃ©nements simplifiÃ©e avec support universel
   */
  setupPreviewEvents() {
    try {
      this.previewContainer.addEventListener("click", (event) => {
        try {
          const target = event.target;
          if (this.pluginManager.isPluginElement(target)) {
            this.logger.debug("\u{1F50C} Clic sur plugin, pas de mode \xE9dition");
            event.stopPropagation();
            return;
          }
          if (this.isBasicInteractiveElement(target)) {
            this.logger.debug("\u{1F3AF} Clic sur \xE9l\xE9ment interactif basique");
            event.stopPropagation();
            return;
          }
          this.logger.info("\u{1F5B1}\uFE0F Clic sur preview \u2192 mode \xE9dition");
          this.enterEditMode();
        } catch (error) {
          this.logger.error("\u274C Erreur dans gestionnaire clic preview", error);
        }
      });
    } catch (error) {
      this.logger.error("\u274C Erreur setupPreviewEvents", error);
    }
  }
  /**
   * âœ… NOUVEAU : DÃ©tection d'Ã©lÃ©ments interactifs basiques (non-plugins)
   */
  isBasicInteractiveElement(element) {
    var _a;
    try {
      if (!element)
        return false;
      let current = element;
      while (current && current !== this.previewContainer) {
        const tagName = ((_a = current.tagName) == null ? void 0 : _a.toLowerCase()) || "";
        if (["input", "button", "a", "select", "textarea"].includes(tagName)) {
          return true;
        }
        if (current.matches(".internal-link, .external-link, .tag, .cm-hashtag")) {
          return true;
        }
        if (current.hasAttribute("href") || current.hasAttribute("data-href")) {
          return true;
        }
        current = current.parentElement;
      }
      return false;
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur isBasicInteractiveElement", error);
      return false;
    }
  }
  /**
   * Configure les Ã©vÃ©nements du mode Ã©dition
   */
  setupEditorEvents() {
    try {
      this.textArea.addEventListener("input", () => {
        try {
          this.content = this.textArea.value;
          clearTimeout(this.changeTimeout);
          this.changeTimeout = setTimeout(() => {
            try {
              this.onChange(this.content);
            } catch (error) {
              this.logger.error("\u274C Erreur callback onChange dans input", error);
            }
          }, 1e3);
        } catch (error) {
          this.logger.error("\u274C Erreur dans gestionnaire input", error);
        }
      });
      this.textArea.addEventListener("blur", () => {
        try {
          this.logger.info("\u{1F4DD} Blur sur textarea \u2192 mode preview");
          this.exitEditMode();
        } catch (error) {
          this.logger.error("\u274C Erreur dans gestionnaire blur", error);
        }
      });
      this.textArea.addEventListener("keydown", (event) => {
        try {
          if (event.key === "Escape") {
            this.logger.info("\u2328\uFE0F Escape \u2192 mode preview");
            this.exitEditMode();
          }
        } catch (error) {
          this.logger.error("\u274C Erreur dans gestionnaire keydown", error);
        }
      });
    } catch (error) {
      this.logger.error("\u274C Erreur setupEditorEvents", error);
    }
  }
  // ===========================================================================
  // GESTION DES MODES (PREVIEW â†” Ã‰DITION)
  // ===========================================================================
  /**
   * Bascule vers le mode Ã©dition
   */
  enterEditMode() {
    try {
      if (this.isInErrorState) {
        this.logger.warn("\u26A0\uFE0F Impossible de passer en mode \xE9dition - \xE9tat d'erreur");
        return;
      }
      if (!this.textArea || !this.editorContainer) {
        throw new Error("Composants d'\xE9dition non initialis\xE9s");
      }
      this.isEditing = true;
      this.previewContainer.style.display = "none";
      this.editorContainer.style.display = "block";
      this.textArea.value = this.content;
      setTimeout(() => {
        try {
          if (this.textArea && this.isEditing) {
            this.textArea.focus();
          }
        } catch (error) {
          this.logger.warn("\u26A0\uFE0F Erreur focus textarea", error);
        }
      }, 10);
      this.logger.info("\u270F\uFE0F Mode \xE9dition activ\xE9");
    } catch (error) {
      this.logger.error("\u274C Erreur enterEditMode", error);
      this.forcePreviewMode();
    }
  }
  /**
   * Bascule vers le mode preview
   */
  exitEditMode() {
    try {
      if (!this.isEditing)
        return;
      if (!this.previewContainer || !this.editorContainer) {
        throw new Error("Composants de preview non initialis\xE9s");
      }
      this.isEditing = false;
      this.content = this.textArea.value;
      this.editorContainer.style.display = "none";
      this.previewContainer.style.display = "block";
      this.renderContent().catch((error) => {
        this.logger.error("\u274C Erreur re-rendu apr\xE8s \xE9dition", error);
      });
      this.logger.info("\u{1F441}\uFE0F Mode preview activ\xE9");
    } catch (error) {
      this.logger.error("\u274C Erreur exitEditMode", error);
      this.forcePreviewMode();
    }
  }
  /**
   * Force le mode preview en cas d'erreur
   */
  forcePreviewMode() {
    try {
      this.isEditing = false;
      if (this.editorContainer) {
        this.editorContainer.style.display = "none";
      }
      if (this.previewContainer) {
        this.previewContainer.style.display = "block";
      }
      this.logger.info("\u{1F527} Mode preview forc\xE9 apr\xE8s erreur");
    } catch (error) {
      this.logger.error("\u274C Erreur critique dans forcePreviewMode", error);
      this.initializeErrorState();
    }
  }
  /**
   * Force l'affichage du mode preview
   */
  showPreview() {
    try {
      if (this.previewContainer && this.editorContainer) {
        this.previewContainer.style.display = "block";
        this.editorContainer.style.display = "none";
        this.isEditing = false;
      }
    } catch (error) {
      this.logger.error("\u274C Erreur showPreview", error);
    }
  }
  // ===========================================================================
  // API PUBLIQUE DU COMPOSANT
  // ===========================================================================
  /**
   * Met Ã  jour le contenu de la section
   */
  updateContent(section) {
    try {
      if (!section) {
        throw new Error("Section requise pour updateContent");
      }
      if (!section.lines || !Array.isArray(section.lines)) {
        throw new Error("Section.lines requis et doit \xEAtre un tableau");
      }
      this.section = section;
      this.content = section.lines.join("\n");
      if (this.isEditing) {
        if (this.textArea) {
          this.textArea.value = this.content;
        }
      } else {
        this.renderContent().catch((error) => {
          this.logger.error("\u274C Erreur re-rendu dans updateContent", error);
        });
      }
      this.logger.info("\u2705 Contenu mis \xE0 jour", {
        sectionName: section.name,
        contentLength: this.content.length
      });
    } catch (error) {
      this.logger.error("\u274C Erreur updateContent", error);
    }
  }
  /**
   * Obtient le contenu actuel de la section
   */
  getContent() {
    try {
      if (this.isEditing && this.textArea) {
        return this.textArea.value;
      }
      return this.content || "";
    } catch (error) {
      this.logger.error("\u274C Erreur getContent", error);
      return this.content || "";
    }
  }
  /**
   * Obtient l'Ã©tat du composant pour debugging
   */
  getState() {
    var _a, _b, _c;
    try {
      const pluginStats = (_a = this.pluginManager) == null ? void 0 : _a.getStats();
      return {
        isEditing: this.isEditing,
        isInErrorState: this.isInErrorState,
        renderAttempts: this.renderAttempts,
        contentLength: ((_b = this.content) == null ? void 0 : _b.length) || 0,
        hasPreviewContainer: !!this.previewContainer,
        hasEditorContainer: !!this.editorContainer,
        hasTextArea: !!this.textArea,
        sectionName: ((_c = this.section) == null ? void 0 : _c.name) || "unknown",
        pluginSupport: {
          enabled: !!this.pluginManager,
          ...pluginStats
        }
      };
    } catch (error) {
      this.logger.error("\u274C Erreur getState", error);
      return { error: "Unable to get state" };
    }
  }
  /**
   * Tente une rÃ©cupÃ©ration en cas d'Ã©tat incohÃ©rent
   */
  recover() {
    try {
      this.logger.info("\u{1F527} Tentative de r\xE9cup\xE9ration du composant");
      this.isInErrorState = false;
      this.renderAttempts = 0;
      this.container.empty();
      this.initializeFrame();
      this.logger.info("\u2705 R\xE9cup\xE9ration r\xE9ussie");
    } catch (error) {
      this.logger.error("\u274C \xC9chec de la r\xE9cup\xE9ration", error);
      this.initializeErrorState();
    }
  }
  /**
   * DÃ©truit proprement le composant
   */
  destroy() {
    try {
      if (this.changeTimeout) {
        clearTimeout(this.changeTimeout);
        this.changeTimeout = null;
      }
      if (this.pluginManager) {
        this.pluginManager.dispose();
      }
      if (this.container) {
        this.container.empty();
      }
      this.previewContainer = null;
      this.editorContainer = null;
      this.textArea = null;
      this.isEditing = false;
      this.isInErrorState = false;
      this.renderAttempts = 0;
      this.logger.info("\u{1F5D1}\uFE0F MarkdownFrame d\xE9truite proprement avec support universel");
    } catch (error) {
      this.logger.error("\u274C Erreur lors de la destruction", error);
      try {
        if (this.container) {
          this.container.innerHTML = "";
        }
      } catch (finalError) {
        console.error("Erreur critique destruction MarkdownFrame:", finalError);
      }
    }
  }
};

// src/views/BoardView.ts
var BOARD_VIEW_TYPE = "agile-board-view";
var BoardView = class extends import_obsidian2.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.gridContainer = null;
    this.frames = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.logger = plugin.logger;
    this.logger.info("\u{1F3AF} BoardView constructor appel\xE9");
  }
  getViewType() {
    return BOARD_VIEW_TYPE;
  }
  getDisplayText() {
    return this.file ? `${this.file.basename} (Board)` : "Agile Board";
  }
  getIcon() {
    return "layout-grid";
  }
  async onLoadFile(file) {
    this.logger.info("\u{1F4C2} onLoadFile appel\xE9 pour:", file.basename);
    await this.renderBoardLayout();
  }
  async onUnloadFile(file) {
    this.logger.info("\u{1F4C2} onUnloadFile appel\xE9 pour:", file.basename);
    this.cleanup();
  }
  // MÃ©thode publique pour recharger le board
  async renderBoardLayout() {
    this.logger.info("\u{1F3A8} renderBoardLayout d\xE9but");
    if (!this.file) {
      this.logger.info("\u274C Pas de fichier dans renderBoardLayout");
      return;
    }
    this.logger.info("\u{1F4C4} Fichier actuel:", this.file.basename);
    this.cleanup();
    try {
      const services = this.plugin.getServices ? this.plugin.getServices() : null;
      if (services) {
        this.logger.info("\u{1F527} Utilisation du nouveau syst\xE8me de services");
        await this.renderWithServices(services);
      }
    } catch (error) {
      this.logger.error("\u274C Erreur dans renderBoardLayout:", error);
      this.showError("Erreur lors du rendu du tableau");
    }
  }
  /**
   * Rendu avec ServiceContainer
   */
  async renderWithServices(services) {
    var _a;
    try {
      const fileCache = this.app.metadataCache.getFileCache(this.file);
      const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
      if (!layoutName) {
        this.showError("Ce fichier n'a pas de layout agile-board");
        return;
      }
      const layout = services.layout.getModel(layoutName);
      if (!layout) {
        this.showError(`Layout "${layoutName}" non trouv\xE9`);
        return;
      }
      const analysis = await services.file.analyzeFile(this.file);
      this.logger.info("\u{1F50D} DEBUG Layout :");
      if (layout) {
        this.logger.info("\u{1F4CB} Sections trouv\xE9es dans le layout:");
        layout.forEach((block, index) => {
          this.logger.info(`  ${index + 1}. "${block.title}" (x:${block.x}, y:${block.y}, w:${block.w}, h:${block.h})`);
        });
      }
      this.logger.info("\u{1F50D} DEBUG Sections dans le fichier:", analysis.existingSections);
      if (analysis.existingSections) {
        analysis.existingSections.forEach((section, index) => {
          var _a2;
          this.logger.info(`  ${index + 1}. "${section.name}" (${((_a2 = section.lines) == null ? void 0 : _a2.length) || 0} lignes)`);
        });
      }
      this.logger.info("\u{1F50D} DEBUG Correspondances:");
      layout.forEach((block) => {
        const normalize = (str) => str.trim().toLowerCase();
        analysis.existingSections.forEach((section) => {
          this.logger.info(
            `[DEBUG] Compare "${normalize(section.name)}" <-> "${normalize(block.title)}"`
          );
        });
        const matchingSection = analysis.existingSections.find(
          (s) => normalize(s.name) === normalize(block.title)
        );
        this.logger.info(`  Layout "${block.title}" \u2192 Section "${(matchingSection == null ? void 0 : matchingSection.name) || "NON TROUV\xC9E"}"`);
        if (matchingSection) {
          this.logger.info("    Contenu section:", matchingSection);
        }
      });
      if (analysis.missingSections.length > 0) {
        this.logger.info("\u26A0\uFE0F Sections manquantes:", analysis.missingSections);
        this.showMissingSectionsError(analysis.missingSections);
        return;
      }
      const convertedSections = analysis.existingSections.map((section) => ({
        name: section.name,
        content: section.content,
        lines: section.lines || section.content.split("\n"),
        startLine: section.startLine || 0,
        endLine: section.endLine || 0,
        isFromLayout: section.isFromLayout || true
      }));
      await this.createBoard(layout, convertedSections);
    } catch (error) {
      this.logger.error("\u274C Erreur dans renderWithServices:", error);
      throw error;
    }
  }
  /**
   * CrÃ©e le tableau avec les sections
   */
  async createBoard(layout, sections) {
    this.logger.debug(
      "\u{1F3D7}\uFE0F Cr\xE9ation du board avec ${layout.length} blocs et ${sections.length} sections",
      {
        layoutCount: layout.length,
        sectionsCount: sections.length
      }
    );
    this.gridContainer = null;
    this.contentEl.empty();
    this.gridContainer = this.contentEl.createDiv("agile-board-grid");
    this.gridContainer.style.cssText = ` 
      display: grid;
      grid-template-columns: repeat(24, 1fr);
      gap: 0.5rem;
      padding: 1rem;
      height: 100%;
      overflow: auto;
      `;
    this.logger.debug("\u{1F7E6} gridContainer cr\xE9\xE9:", this.gridContainer);
    this.logger.debug("\u{1F7E6} gridContainer cr\xE9\xE9 (HTML):", this.gridContainer.outerHTML);
    for (const block of layout) {
      const normalize = (str) => str.trim().toLowerCase();
      const section = sections.find((s) => normalize(s.name) === normalize(block.title));
      if (section) {
        await this.createFrame(block, section);
      } else {
        this.logger.warn(`\u26A0\uFE0F Section "${block.title}" non trouv\xE9e`);
      }
    }
    this.logger.info("\u2705 Board cr\xE9\xE9 avec succ\xE8s");
  }
  /**
   * CrÃ©e une frame pour une section
   */
  async createFrame(layout, section) {
    this.logger.info(`\u{1F3AF} Cr\xE9ation frame pour "${layout.title}"`);
    try {
      const frameContainer = this.gridContainer.createDiv("agile-board-frame");
      frameContainer.style.gridColumn = `${layout.x + 1} / span ${layout.w}`;
      frameContainer.style.gridRow = `${layout.y + 1} / span ${layout.h}`;
      frameContainer.style.border = "1px solid var(--background-modifier-border)";
      frameContainer.style.minHeight = "100px";
      frameContainer.style.display = "flex";
      frameContainer.style.flexDirection = "column";
      frameContainer.style.overflow = "hidden";
      this.logger.info("\u{1F7E6} Frame DOM ajout\xE9e frame:", frameContainer);
      this.logger.info("\u{1F7E6} Frame DOM ajout\xE9e frame (HTML):", frameContainer.outerHTML);
      const titleEl = frameContainer.createDiv("frame-title");
      titleEl.textContent = layout.title;
      titleEl.style.fontWeight = "bold";
      titleEl.style.marginBottom = "0.5rem";
      titleEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      titleEl.style.color = "var(--text-accent)";
      const contentContainer = frameContainer.createDiv("frame-content");
      contentContainer.style.flex = "1";
      contentContainer.style.overflowY = "auto";
      contentContainer.style.padding = "0.5rem";
      const frameSection = {
        start: section.startLine || 0,
        end: section.endLine || 0,
        lines: section.lines || section.content.split("\n"),
        name: section.name,
        content: section.content
      };
      this.logger.info("\u{1F7E6} Frame DOM ajout\xE9e Section:", frameSection);
      const frame = new MarkdownFrame(
        this.app,
        contentContainer,
        // On passe le conteneur dÃ©diÃ©, pas le cadre entier        
        this.file,
        frameSection,
        (content) => this.onFrameContentChanged(frameSection.name || section.name, content),
        this.plugin.logger
      );
      this.frames.set(layout.title, frame);
      this.logger.info(`\u2705 Frame "${layout.title}" cr\xE9\xE9e`);
    } catch (error) {
      this.logger.error(`\u274C Erreur cr\xE9ation frame "${layout.title}":`, error);
      throw error;
    }
  }
  /**
   * Gestionnaire de changement de contenu
   */
  async onFrameContentChanged(sectionName, newContent) {
    try {
      this.logger.info(`\u{1F4BE} Sauvegarde section "${sectionName}"`);
      const services = this.plugin.getServices ? this.plugin.getServices() : null;
      if (services && services.file.updateSectionContent) {
        await services.file.updateSectionContent(this.file, sectionName, newContent);
      } else if (this.plugin.fileService && this.plugin.fileService.updateSectionContent) {
        await this.plugin.fileService.updateSectionContent(this.file, sectionName, newContent);
      }
    } catch (error) {
      this.logger.error(`\u274C Erreur sauvegarde section "${sectionName}":`, error);
    }
  }
  /**
   * Affiche une erreur avec sections manquantes
   */
  showMissingSectionsError(missingSections) {
    this.contentEl.empty();
    const errorContainer = this.contentEl.createDiv("agile-board-error");
    errorContainer.createEl("h3", { text: "\u26A0\uFE0F Sections manquantes" });
    errorContainer.createEl("p", {
      text: `Ce fichier ne contient pas toutes les sections requises :`
    });
    const list = errorContainer.createEl("ul");
    missingSections.forEach((section) => {
      list.createEl("li", { text: `\u2022 ${section}` });
    });
    const button = errorContainer.createEl("button", {
      text: "\u2728 Cr\xE9er les sections manquantes",
      cls: "mod-cta"
    });
    button.addEventListener("click", async () => {
      try {
        const services = this.plugin.getServices ? this.plugin.getServices() : null;
        this.logger.info("\u{1F50D} DEBUG avant test services renderBoardLayout");
        if (services) {
          await services.file.createMissingSections(this.file);
        }
        this.logger.info("\u{1F50D} DEBUG avant renderBoardLayout");
        await this.renderBoardLayout();
      } catch (error) {
        this.logger.error("Erreur cr\xE9ation sections:", error);
      }
    });
  }
  /**
   * Affiche une erreur gÃ©nÃ©rique
   */
  showError(message) {
    this.contentEl.empty();
    const errorEl = this.contentEl.createDiv("agile-board-error");
    errorEl.createEl("h3", { text: "\u274C Erreur" });
    errorEl.createEl("p", { text: message });
  }
  /**
   * Nettoie les ressources
   */
  cleanup() {
    var _a;
    this.frames.forEach((frame) => frame.destroy());
    this.frames.clear();
    (_a = this.gridContainer) == null ? void 0 : _a.remove();
    this.gridContainer = null;
    this.logger.info("\u{1F50D} DEBUG cleanup");
  }
};

// src/managers/ViewSwitcher.ts
var import_obsidian3 = require("obsidian");
var ViewSwitcher = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.updateTimer = null;
    this.DEBOUNCE_DELAY = 150;
    // DÃ©lai pour Ã©viter les appels multiples
    this.lastProcessedFile = null;
    this.lastViewType = null;
    /**
     * Programme une mise Ã  jour avec debouncing intelligent
     */
    this.isUpdating = false;
    this.logger = plugin.logger;
    this.addSwitchButton();
    this.updateSwitchButton();
  }
  // ===========================================================================
  // MÃ‰THODES DE BASCULEMENT ENTRE VUES (CORRIGÃ‰ES)
  // ===========================================================================
  /**
   * Bascule vers la vue Board avec mise Ã  jour forcÃ©e des boutons
   */
  async switchToBoardView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      this.logger.info("\u{1F3AF} Basculement vers Board View pour:", { file: file.basename });
      await activeLeaf.setViewState({
        type: BOARD_VIEW_TYPE,
        state: { file: file.path }
      });
      this.scheduleButtonUpdate(file, "board-switch");
    }
  }
  /**
   * Bascule vers la vue Markdown avec mise Ã  jour forcÃ©e des boutons
   */
  async switchToMarkdownView(file) {
    const activeLeaf = this.plugin.app.workspace.activeLeaf;
    if (activeLeaf) {
      this.logger.info("\u{1F4DD} Basculement vers Markdown View pour:", { file: file.basename });
      await activeLeaf.setViewState({
        type: "markdown",
        state: { file: file.path }
      });
      this.scheduleButtonUpdate(file, "markdown-switch");
    }
  }
  // ===========================================================================
  // DÃ‰TECTION DE CONTEXTE (AMÃ‰LIORÃ‰E)
  // ===========================================================================
  /**
   * VÃ©rifie si la vue actuelle est notre BoardView
   */
  isCurrentViewBoardView() {
    const boardView = this.plugin.app.workspace.getActiveViewOfType(BoardView);
    return boardView !== null;
  }
  /**
   * VÃ©rifie si la vue actuelle est la MarkdownView standard
   */
  isCurrentViewMarkdownView() {
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    return markdownView !== null;
  }
  /**
   * Obtient le type de vue actuel de maniÃ¨re sÃ©curisÃ©e
   */
  getCurrentViewType() {
    try {
      const activeLeaf = this.plugin.app.workspace.activeLeaf;
      return (activeLeaf == null ? void 0 : activeLeaf.view.getViewType()) || null;
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur lors de la d\xE9tection du type de vue:", error);
      return null;
    }
  }
  /**
   * VÃ©rifie si un fichier a un layout agile-board (avec cache)
   */
  hasAgileBoardLayout(file) {
    var _a, _b;
    if (!file)
      return false;
    try {
      const fileCache = this.plugin.app.metadataCache.getFileCache(file);
      const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
      if (!layoutName)
        return false;
      const layout = (_b = this.plugin.layoutService) == null ? void 0 : _b.getModel(layoutName);
      return !!layout;
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur lors de la v\xE9rification du layout:", error);
      return false;
    }
  }
  // ===========================================================================
  // GESTION DES Ã‰VÃ‰NEMENTS (CORRIGÃ‰E)
  // ===========================================================================
  /**
   * Configure les Ã©couteurs d'Ã©vÃ©nements avec debouncing amÃ©liorÃ©
   */
  addSwitchButton() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", (leaf) => {
        this.scheduleButtonUpdate(null, "active-leaf-change");
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        if (file) {
          this.scheduleButtonUpdate(file, "file-open");
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.path === file.path) {
          this.scheduleButtonUpdate(file, "metadata-changed");
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", () => {
        this.scheduleButtonUpdate(null, "layout-change");
      })
    );
    this.scheduleButtonUpdate(null, "initialization");
  }
  async scheduleButtonUpdate(file = null, trigger) {
    if (this.isUpdating)
      return;
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = window.setTimeout(async () => {
      this.isUpdating = true;
      try {
        const targetFile = file || this.plugin.app.workspace.getActiveFile();
        if (targetFile) {
          await this.updateSwitchButtonForFile(targetFile);
        }
      } finally {
        this.isUpdating = false;
        this.updateTimer = null;
      }
    }, this.DEBOUNCE_DELAY);
  }
  /**
   * Met Ã  jour les boutons pour un fichier spÃ©cifique (logique corrigÃ©e)
   */
  updateSwitchButtonForFile(file) {
    try {
      if (!file) {
        this.logger.info("\u26A0\uFE0F Pas de fichier pour mise \xE0 jour boutons");
        this.removeSwitchButtons();
        return;
      }
      const hasLayout = this.hasAgileBoardLayout(file);
      const currentViewType = this.getCurrentViewType();
      const isMarkdownView = this.isCurrentViewMarkdownView();
      const isBoardView = this.isCurrentViewBoardView();
      this.logger.info(`\u{1F50D} \xC9tat actuel:`, {
        fileName: file.basename,
        hasLayout,
        currentViewType,
        isMarkdownView,
        isBoardView
      });
      const fileKey = `${file.path}-${currentViewType}`;
      if (this.lastProcessedFile === fileKey) {
        this.logger.info("\u23ED\uFE0F M\xEAme \xE9tat, pas de mise \xE0 jour n\xE9cessaire");
        return;
      }
      this.lastProcessedFile = fileKey;
      if (!hasLayout) {
        this.logger.info("\u274C Pas de layout agile-board, suppression des boutons");
        this.removeSwitchButtons();
        return;
      }
      if (isMarkdownView && currentViewType === "markdown") {
        this.logger.info("\u{1F4DD} Vue Markdown d\xE9tect\xE9e \u2192 Afficher bouton Board");
        this.removeSwitchButtons();
        setTimeout(() => this.ensureBoardModeButton(), 50);
      } else if (isBoardView && currentViewType === BOARD_VIEW_TYPE) {
        this.logger.info("\u{1F4CA} Vue Board d\xE9tect\xE9e \u2192 Afficher bouton Markdown");
        this.removeSwitchButtons();
        setTimeout(() => this.ensureNormalModeButton(), 50);
      } else {
        this.logger.info(`\u2753 Vue non reconnue (${currentViewType}) \u2192 Supprimer boutons`);
        this.removeSwitchButtons();
      }
    } catch (error) {
      this.logger.error("\u274C Erreur lors de la mise \xE0 jour des boutons:", error);
      this.removeSwitchButtons();
    }
  }
  /**
   * Met Ã  jour les boutons selon le contexte actuel (mÃ©thode principale)
   */
  updateSwitchButton() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    this.updateSwitchButtonForFile(activeFile);
  }
  // ===========================================================================
  // CRÃ‰ATION ET GESTION DES BOUTONS (CORRIGÃ‰ES)
  // ===========================================================================
  /**
   * S'assure qu'un bouton "Mode Board" est prÃ©sent en vue Markdown
   */
  ensureBoardModeButton() {
    try {
      const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!markdownView) {
        this.logger.info("\u26A0\uFE0F Pas de vue Markdown active pour ajouter le bouton Board");
        return;
      }
      const viewActions = markdownView.containerEl.querySelector(".view-actions");
      if (!viewActions) {
        this.logger.info("\u26A0\uFE0F Zone view-actions non trouv\xE9e");
        return;
      }
      const existingButton = viewActions.querySelector(".agile-board-switch-button");
      if (existingButton) {
        this.logger.info("\u{1F9F9} Suppression bouton existant");
        existingButton.remove();
      }
      const button = markdownView.addAction("layout-grid", "Basculer vers la vue Board", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.logger.info("\u{1F3AF} Clic bouton Board \u2192 Basculement");
          this.switchToBoardView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "board-mode");
      button.setAttribute("data-tooltip", "Vue Board (Agile Board)");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      this.logger.info("\u2705 Bouton Mode Board ajout\xE9");
    } catch (error) {
      this.logger.error("\u274C Erreur lors de l'ajout du bouton Mode Board:", error);
    }
  }
  /**
   * S'assure qu'un bouton "Mode Markdown" est prÃ©sent en vue Board
   */
  ensureNormalModeButton() {
    try {
      const boardView = this.plugin.app.workspace.getActiveViewOfType(BoardView);
      if (!boardView) {
        this.logger.info("\u26A0\uFE0F Pas de vue Board active pour ajouter le bouton Markdown");
        return;
      }
      const viewActions = boardView.containerEl.querySelector(".view-actions");
      if (!viewActions) {
        this.logger.info("\u26A0\uFE0F Zone view-actions non trouv\xE9e dans BoardView");
        return;
      }
      const existingButton = viewActions.querySelector(".agile-board-switch-button");
      if (existingButton) {
        this.logger.info("\u{1F9F9} Suppression bouton existant");
        existingButton.remove();
      }
      const button = boardView.addAction("document", "Basculer vers la vue Markdown", () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile) {
          this.logger.info("\u{1F4DD} Clic bouton Markdown \u2192 Basculement");
          this.switchToMarkdownView(activeFile);
        }
      });
      button.addClass("agile-board-switch-button");
      button.setAttribute("data-agile-board-button", "normal-mode");
      button.setAttribute("data-tooltip", "Vue Markdown (Standard)");
      button.style.cssText = `
        background-color: var(--interactive-accent);
        color: var(--text-on-accent);
        border-radius: 3px;
        opacity: 1;
      `;
      this.logger.info("\u2705 Bouton Mode Markdown ajout\xE9");
    } catch (error) {
      this.logger.error("\u274C Erreur lors de l'ajout du bouton Mode Markdown:", error);
    }
  }
  /**
   * Supprime tous les boutons de basculement (mÃ©thode amÃ©liorÃ©e)
   */
  removeSwitchButtons() {
    try {
      const buttons = document.querySelectorAll(".agile-board-switch-button");
      buttons.forEach((button) => {
        this.logger.info("\u{1F5D1}\uFE0F Suppression bouton trouv\xE9");
        button.remove();
      });
      const views = [
        this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView),
        this.plugin.app.workspace.getActiveViewOfType(BoardView)
      ].filter((view) => view !== null);
      views.forEach((view) => {
        const viewActions = view.containerEl.querySelector(".view-actions");
        if (viewActions) {
          const buttons2 = viewActions.querySelectorAll(".agile-board-switch-button");
          buttons2.forEach((button) => button.remove());
        }
      });
    } catch (error) {
      this.logger.error("\u274C Erreur lors de la suppression des boutons:", error);
    }
  }
  // ===========================================================================
  // MÃ‰THODES DE DEBUGGING ET MAINTENANCE
  // ===========================================================================
  /**
   * Force une mise Ã  jour complÃ¨te (pour le debugging)
   */
  forceUpdate() {
    this.logger.info("\u{1F504} Force update des boutons ViewSwitcher");
    this.lastProcessedFile = null;
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (activeFile) {
      this.updateSwitchButtonForFile(activeFile);
    }
  }
  /**
   * Diagnostique l'Ã©tat actuel du ViewSwitcher
   */
  getDiagnostics() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    const currentViewType = this.getCurrentViewType();
    return {
      activeFile: (activeFile == null ? void 0 : activeFile.basename) || "none",
      currentViewType,
      isMarkdownView: this.isCurrentViewMarkdownView(),
      isBoardView: this.isCurrentViewBoardView(),
      hasLayout: activeFile ? this.hasAgileBoardLayout(activeFile) : false,
      lastProcessedFile: this.lastProcessedFile,
      updateTimerActive: this.updateTimer !== null,
      buttonsPresent: document.querySelectorAll(".agile-board-switch-button").length
    };
  }
  /**
   * Nettoie les ressources utilisÃ©es par le ViewSwitcher
   */
  stop() {
    this.logger.info("\u{1F6D1} Arr\xEAt du ViewSwitcher");
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    this.removeSwitchButtons();
    this.lastProcessedFile = null;
  }
};

// src/managers/ModelDetector.ts
var ModelDetector = class {
  /**
   * CONSTRUCTEUR avec injection de dÃ©pendance
   * 
   * @param plugin - Instance du plugin principal
   * 
   * DÃ‰PENDANCES UTILISÃ‰ES :
   * - plugin.app : Pour accÃ©der aux APIs Obsidian
   * - plugin.layoutService : Pour valider les layouts
   * - plugin.viewSwitcher : Pour mettre Ã  jour l'interface
   * - plugin.registerEvent : Pour l'abonnement sÃ©curisÃ© aux Ã©vÃ©nements
   */
  constructor(plugin) {
    this.plugin = plugin;
    /**
     * Cache des fichiers dÃ©jÃ  traitÃ©s
     * 
     * STRUCTURE DE DONNÃ‰ES :
     * Set<string> pour un accÃ¨s O(1) et Ã©viter les doublons.
     * 
     * CLÃ‰ DE CACHE :
     * "chemin-du-fichier-timestamp" pour invalidation automatique
     * quand le fichier est modifiÃ©.
     * 
     * AVANTAGES :
     * - Ã‰vite les retraitements inutiles
     * - Performance optimisÃ©e pour les gros vaults
     * - Invalidation automatique lors des modifications
     */
    this.processedFiles = /* @__PURE__ */ new Set();
    this.logger = plugin.logger;
  }
  // ===========================================================================
  // MÃ‰THODES DE CYCLE DE VIE
  // ===========================================================================
  /**
   * Initialise la surveillance des Ã©vÃ©nements Obsidian
   * 
   * Ã‰VÃ‰NEMENTS SURVEILLÃ‰S :
   * 1. metadataCache.on('changed') : Modification des mÃ©tadonnÃ©es
   * 2. workspace.on('file-open') : Ouverture de fichier
   * 3. workspace.on('active-leaf-change') : Changement d'onglet actif
   * 
   * DÃ‰LAIS D'INITIALISATION :
   * DÃ©lai de 1 seconde pour laisser Obsidian finir son initialisation
   * avant de traiter les fichiers dÃ©jÃ  ouverts.
   * 
   * PATTERN REGISTER-EVENT :
   * Utilise plugin.registerEvent() pour un nettoyage automatique
   * des Ã©couteurs lors du dÃ©chargement du plugin.
   * 
   * @example
   * modelDetector.onLoad();
   * // Ã€ partir de maintenant, les changements sont dÃ©tectÃ©s automatiquement
   */
  onLoad() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        this.handleMetadataChanged(file);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", () => {
        setTimeout(() => {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          if (activeFile) {
            this.handleFileOpen(activeFile);
          }
        }, 100);
      })
    );
    setTimeout(() => {
      this.processAllOpenFiles();
    }, 1e3);
  }
  /**
   * Nettoie les ressources utilisÃ©es par le dÃ©tecteur
   * 
   * APPELÃ‰E PAR :
   * Le plugin principal lors de son dÃ©chargement (onunload).
   * 
   * NETTOYAGE :
   * - Vide le cache des fichiers traitÃ©s
   * - Les Ã©couteurs d'Ã©vÃ©nements sont automatiquement nettoyÃ©s par Obsidian
   * 
   * IMPORTANCE :
   * Ã‰vite les fuites mÃ©moire et prÃ©pare un rechargement propre du plugin.
   */
  onUnload() {
    this.processedFiles.clear();
  }
  // ===========================================================================
  // GESTIONNAIRES D'Ã‰VÃ‰NEMENTS PRIVÃ‰S
  // ===========================================================================
  /**
   * GÃ¨re les changements de mÃ©tadonnÃ©es d'un fichier
   * 
   * DÃ‰CLENCHEMENT :
   * Quand l'utilisateur modifie le frontmatter d'un fichier.
   * Par exemple, ajouter ou changer "agile-board: layout_kanban".
   * 
   * LOGIQUE :
   * Les mÃ©tadonnÃ©es changÃ©es peuvent affecter l'affichage des boutons,
   * donc on relance le traitement du fichier.
   * 
   * @param file - Fichier dont les mÃ©tadonnÃ©es ont changÃ©
   * 
   * @example
   * // L'utilisateur ajoute dans le frontmatter :
   * // agile-board: layout_eisenhower
   * // â†’ handleMetadataChanged() est appelÃ©e
   * // â†’ Les boutons de basculement apparaissent
   */
  handleMetadataChanged(file) {
    this.logger.info("\u{1F4DD} M\xE9tadonn\xE9es chang\xE9es pour:", file.basename);
    this.processFile(file);
  }
  /**
   * GÃ¨re l'ouverture d'un fichier
   * 
   * DÃ‰CLENCHEMENT :
   * - Ouverture d'un nouveau fichier
   * - Basculement vers un onglet existant
   * - Navigation par liens internes
   * 
   * @param file - Fichier qui vient d'Ãªtre ouvert/activÃ©
   */
  handleFileOpen(file) {
    this.logger.info("\u{1F4C2} Fichier ouvert:", file.basename);
    this.processFile(file);
  }
  /**
   * Traite tous les fichiers dÃ©jÃ  ouverts au dÃ©marrage
   * 
   * UTILISATION :
   * AppelÃ©e une fois lors de l'initialisation pour traiter les fichiers
   * qui Ã©taient dÃ©jÃ  ouverts avant l'activation du plugin.
   * 
   * MÃ‰THODE OBSIDIAN :
   * iterateAllLeaves() parcourt tous les onglets ouverts dans l'espace de travail.
   * 
   * FILTRAGE :
   * Seuls les onglets avec vue markdown et fichier valide sont traitÃ©s.
   * 
   * @example
   * // Au dÃ©marrage d'Obsidian avec 3 fichiers ouverts :
   * // processAllOpenFiles() va traiter les 3 fichiers
   * // et afficher les boutons appropriÃ©s
   */
  processAllOpenFiles() {
    this.logger.info("\u{1F50D} Traitement initial de tous les fichiers ouverts...");
    this.plugin.app.workspace.iterateAllLeaves((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === "markdown" && view.file) {
        this.processFile(view.file);
      }
    });
  }
  // ===========================================================================
  // LOGIQUE MÃ‰TIER PRINCIPALE
  // ===========================================================================
  /**
   * Traite un fichier individuel et met Ã  jour l'interface si nÃ©cessaire
   * 
   * ALGORITHME :
   * 1. Filtrer les fichiers non-markdown
   * 2. GÃ©nÃ©rer une clÃ© de cache unique
   * 3. VÃ©rifier si dÃ©jÃ  traitÃ© (cache hit)
   * 4. DÃ©tecter si le fichier a un layout agile-board
   * 5. Mettre Ã  jour l'interface via ViewSwitcher
   * 6. Nettoyer le cache si nÃ©cessaire
   * 
   * OPTIMISATION DE CACHE :
   * La clÃ© inclut le timestamp de modification (mtime) pour invalider
   * automatiquement le cache quand le fichier change.
   * 
   * @param file - Fichier Ã  traiter
   * 
   * @example
   * // PremiÃ¨re fois : traitement complet
   * processFile(myFile); // Cache miss â†’ traitement
   * 
   * // DeuxiÃ¨me fois (fichier inchangÃ©) : cache hit
   * processFile(myFile); // Cache hit â†’ pas de traitement
   * 
   * // AprÃ¨s modification du fichier : cache invalidÃ©
   * processFile(myFile); // Cache miss â†’ traitement
   */
  processFile(file) {
    if (!file.path.endsWith(".md"))
      return;
    const fileKey = `${file.path}-${file.stat.mtime}`;
    if (this.processedFiles.has(fileKey))
      return;
    this.processedFiles.add(fileKey);
    this.cleanupProcessedFiles();
    const hasLayout = this.hasAgileBoardLayout(file);
    this.logger.debug(`V\xE9rification du Layout pour le fichier`, {
      file: file.basename,
      hasLayout
    });
  }
  /**
   * VÃ©rifie si un fichier a un layout agile-board valide
   * 
   * VALIDATION EN DEUX Ã‰TAPES :
   * 1. VÃ©rifier la prÃ©sence du champ 'agile-board' dans le frontmatter
   * 2. VÃ©rifier que le layout existe dans le LayoutService
   * 
   * GESTION D'ERREURS :
   * Si un layout est spÃ©cifiÃ© mais n'existe pas, log un warning
   * mais retourne false (traitement gracieux).
   * 
   * @param file - Fichier Ã  vÃ©rifier
   * @returns boolean - true si le fichier a un layout valide
   * 
   * @example
   * // Fichier avec frontmatter valide :
   * // ---
   * // agile-board: layout_eisenhower
   * // ---
   * hasAgileBoardLayout(file); // true
   * 
   * // Fichier avec layout inexistant :
   * // ---
   * // agile-board: layout_inexistant
   * // ---
   * hasAgileBoardLayout(file); // false + warning
   */
  hasAgileBoardLayout(file) {
    var _a;
    const fileCache = this.plugin.app.metadataCache.getFileCache(file);
    const layoutName = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a["agile-board"];
    if (!layoutName)
      return false;
    const layout = this.plugin.layoutService.getModel(layoutName);
    if (!layout) {
      this.logger.warn(`\u26A0\uFE0F Layout "${layoutName}" sp\xE9cifi\xE9 mais non trouv\xE9`);
      return false;
    }
    return true;
  }
  // ===========================================================================
  // GESTION DU CACHE ET OPTIMISATIONS
  // ===========================================================================
  /**
   * Nettoie le cache pour Ã©viter une croissance excessive
   * 
   * STRATÃ‰GIE DE NETTOYAGE :
   * - Limite : 100 entrÃ©es maximum dans le cache
   * - MÃ©thode : Garder les 50 entrÃ©es les plus rÃ©centes
   * - DÃ©clenchement : Ã€ chaque ajout dans le cache
   * 
   * POURQUOI NETTOYER :
   * - Ã‰viter la fuite mÃ©moire avec de gros vaults
   * - Maintenir des performances optimales
   * - Les anciennes entrÃ©es sont probablement obsolÃ¨tes
   * 
   * ALGORITHME LRU SIMPLE :
   * Les entrÃ©es sont dans l'ordre d'insertion dans le Set.
   * On garde les derniÃ¨res ajoutÃ©es (= les plus rÃ©cemment utilisÃ©es).
   * 
   * @example
   * // Cache avec 100+ entrÃ©es
   * cleanupProcessedFiles();
   * // â†’ Cache rÃ©duit Ã  50 entrÃ©es les plus rÃ©centes
   */
  cleanupProcessedFiles() {
    if (this.processedFiles.size > 100) {
      const entries = Array.from(this.processedFiles);
      const toKeep = entries.slice(-50);
      this.processedFiles.clear();
      toKeep.forEach((entry) => this.processedFiles.add(entry));
      this.logger.info("\u{1F9F9} Cache nettoy\xE9: gard\xE9 50 entr\xE9es sur", entries.length);
    }
  }
  // ===========================================================================
  // MÃ‰THODES UTILITAIRES PUBLIQUES
  // ===========================================================================
  /**
   * Force une mise Ã  jour complÃ¨te de tous les fichiers ouverts
   * 
   * UTILISATION :
   * - Commande de dÃ©bogage
   * - AprÃ¨s rechargement de layouts
   * - RÃ©cupÃ©ration d'Ã©tat incohÃ©rent
   * 
   * PROCESSUS :
   * 1. Vider complÃ¨tement le cache
   * 2. Retraiter tous les fichiers ouverts
   * 3. Mettre Ã  jour toute l'interface
   * 
   * PERFORMANCE :
   * OpÃ©ration coÃ»teuse, Ã  utiliser avec parcimonie.
   * 
   * @example
   * // L'utilisateur utilise la commande "Force Update Board Buttons"
   * modelDetector.forceUpdate();
   * // â†’ Tous les boutons sont recalculÃ©s et mis Ã  jour
   */
  forceUpdate() {
    this.processedFiles.clear();
    this.processAllOpenFiles();
    this.logger.info("\u{1F504} Mise \xE0 jour forc\xE9e termin\xE9e");
  }
};

// src/components/SettingsTab.ts
var import_obsidian4 = require("obsidian");
var AgileBoardSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Agile Board - Configuration" });
    this.createDebugSection(containerEl);
    this.createGeneralSection(containerEl);
  }
  /**
   * CrÃ©e la section de configuration du debug
   */
  createDebugSection(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F527} Configuration du Debug" });
    const debugDesc = containerEl.createEl("div", { cls: "setting-item-description" });
    debugDesc.innerHTML = `
            <p>Configurez le niveau de verbosit\xE9 et les options de debug du plugin.</p>
            <p><strong>Conseil :</strong> Gardez le debug <em>d\xE9sactiv\xE9</em> en usage normal pour optimiser les performances.</p>
        `;
    new import_obsidian4.Setting(containerEl).setName("Activer le debug").setDesc("Active ou d\xE9sactive compl\xE8tement le syst\xE8me de debug").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.enabled).onChange(async (value) => {
      this.plugin.settings.debug.enabled = value;
      await this.plugin.saveSettings();
      new import_obsidian4.Notice(`Debug ${value ? "activ\xE9" : "d\xE9sactiv\xE9"}`);
      this.display();
    }));
    if (this.plugin.settings.debug.enabled) {
      this.createDebugAdvancedOptions(containerEl);
    }
  }
  /**
   * CrÃ©e les options avancÃ©es de debug (quand activÃ©)
   */
  createDebugAdvancedOptions(containerEl) {
    new import_obsidian4.Setting(containerEl).setName("Niveau de verbosit\xE9").setDesc("Contr\xF4le la quantit\xE9 d'informations affich\xE9es dans les logs").addDropdown((dropdown) => dropdown.addOption(1 /* ERROR */.toString(), "\u274C Erreurs uniquement").addOption(2 /* WARN */.toString(), "\u26A0\uFE0F Erreurs + Avertissements").addOption(3 /* INFO */.toString(), "\u2139\uFE0F Informations importantes (recommand\xE9)").addOption(4 /* DEBUG */.toString(), "\u{1F527} Debug d\xE9taill\xE9").addOption(5 /* VERBOSE */.toString(), "\u{1F50D} Tout afficher (tr\xE8s verbeux)").setValue(this.plugin.settings.debug.logLevel.toString()).onChange(async (value) => {
      this.plugin.settings.debug.logLevel = parseInt(value);
      await this.plugin.saveSettings();
      new import_obsidian4.Notice(`Niveau de debug: ${LogLevel[parseInt(value)]}`);
    }));
    new import_obsidian4.Setting(containerEl).setName("Afficher les timestamps").setDesc("Ajoute l'heure pr\xE9cise \xE0 chaque message de log").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.showTimestamps).onChange(async (value) => {
      this.plugin.settings.debug.showTimestamps = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Afficher la source").setDesc("Indique le fichier source de chaque message de log").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.showSourceLocation).onChange(async (value) => {
      this.plugin.settings.debug.showSourceLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Sauvegarder dans un fichier").setDesc("Enregistre automatiquement les logs dans un fichier de votre vault").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug.logToFile).onChange(async (value) => {
      this.plugin.settings.debug.logToFile = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.debug.logToFile) {
      this.createFileLoggingOptions(containerEl);
    }
    this.createDebugActions(containerEl);
  }
  /**
   * CrÃ©e les options de sauvegarde fichier
   */
  createFileLoggingOptions(containerEl) {
    new import_obsidian4.Setting(containerEl).setName("Nom du fichier de log").setDesc("Nom du fichier o\xF9 sauvegarder les logs (dans la racine du vault)").addText((text) => text.setPlaceholder("agile-board-debug.log").setValue(this.plugin.settings.debug.logFileName).onChange(async (value) => {
      this.plugin.settings.debug.logFileName = value || "agile-board-debug.log";
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Intervalle de sauvegarde auto").setDesc("Intervalle en minutes pour sauvegarder automatiquement les logs").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.debug.autoSaveInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.debug.autoSaveInterval = value;
      await this.plugin.saveSettings();
      this.plugin.logger.info(`Intervalle de sauvegarde des logs mis \xE0 jour: ${value} minute(s)`);
    }));
    new import_obsidian4.Setting(containerEl).setName("Taille maximale du fichier").setDesc("Taille maximale en KB avant rotation automatique").addSlider((slider) => slider.setLimits(100, 1e4, 100).setValue(this.plugin.settings.debug.maxLogFileSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.debug.maxLogFileSize = value;
      await this.plugin.saveSettings();
    }));
  }
  /**
   * CrÃ©e les boutons d'action pour le debug
   */
  createDebugActions(containerEl) {
    const actionsContainer = containerEl.createDiv("debug-actions");
    actionsContainer.style.cssText = `
            margin-top: 20px;
            padding: 15px;
            background-color: var(--background-secondary);
            border-radius: 6px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        `;
    const testButton = actionsContainer.createEl("button", {
      text: "\u{1F9EA} Tester le syst\xE8me",
      cls: "mod-cta"
    });
    testButton.onclick = () => {
      this.plugin.logger.testSystem();
      new import_obsidian4.Notice("Test de debug ex\xE9cut\xE9 - v\xE9rifiez la console (F12)", 3e3);
    };
    if (this.plugin.settings.debug.logToFile) {
      const saveButton = actionsContainer.createEl("button", {
        text: "\u{1F4BE} Sauvegarder maintenant"
      });
      saveButton.onclick = async () => {
        await this.plugin.logger.saveLogsToFile();
        new import_obsidian4.Notice("Logs sauvegard\xE9s", 2e3);
      };
    }
    const statsButton = actionsContainer.createEl("button", {
      text: "\u{1F4CA} Statistiques"
    });
    statsButton.onclick = () => this.showDebugStats();
    const clearButton = actionsContainer.createEl("button", {
      text: "\u{1F5D1}\uFE0F Vider le buffer"
    });
    clearButton.onclick = () => {
      this.plugin.logger.clearBuffer();
      new import_obsidian4.Notice("Buffer de logs vid\xE9", 2e3);
    };
  }
  /**
   * Affiche les statistiques de debug dans une notification
   */
  showDebugStats() {
    const stats = this.plugin.logger.getStats();
    const message = `\u{1F4CA} Statistiques de Debug:

\u2022 Statut: ${stats.isEnabled ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9"}
\u2022 Niveau: ${stats.currentLevel}
\u2022 Buffer: ${stats.bufferSize} entr\xE9es
\u2022 Fichier: ${stats.fileLoggingEnabled ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9"}`;
    new import_obsidian4.Notice(message, 6e3);
  }
  /**
   * CrÃ©e la section de configuration gÃ©nÃ©rale
   */
  createGeneralSection(containerEl) {
    containerEl.createEl("h2", { text: "\u2699\uFE0F Param\xE8tres G\xE9n\xE9raux" });
    new import_obsidian4.Setting(containerEl).setName("Cr\xE9ation automatique des sections").setDesc("Cr\xE9e automatiquement les sections manquantes lors de l'ouverture d'un board").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCreateSections).onChange(async (value) => {
      this.plugin.settings.autoCreateSections = value;
      await this.plugin.saveSettings();
      this.plugin.logger.config("Auto-cr\xE9ation sections modifi\xE9e", { enabled: value });
    }));
    const layoutDesc = containerEl.createEl("div", { cls: "setting-item-description" });
    layoutDesc.innerHTML = `
            <p><strong>Layouts disponibles:</strong> Eisenhower, Kanban, GTD, Weekly Planner, Daily Planner, Project Board, Cornell Notes, Tasks Dashboard</p>
        `;
  }
};

// src/main.ts
var AgileBoardPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.logSaveInterval = null;
  }
  async onload() {
    try {
      await this.initializeCore();
      this.logger.startup("\u{1F680} Chargement Agile Board Plugin v0.9.0 avec support universel plugins");
      await this.initializeServices();
      await this.initializeUI();
      this.setupLogAutoSave();
      this.logDetectedPlugins();
      this.logger.info("\u2705 Agile Board Plugin charg\xE9 avec succ\xE8s - Support universel des plugins activ\xE9");
    } catch (error) {
      console.error("\u274C Erreur chargement plugin:", error);
      new import_obsidian5.Notice("\u274C Erreur lors du chargement du plugin Agile Board");
    }
  }
  async onunload() {
    var _a, _b, _c, _d;
    (_a = this.logger) == null ? void 0 : _a.info("Arr\xEAt du plugin Agile Board");
    (_b = this.modelDetector) == null ? void 0 : _b.onUnload();
    (_c = this.viewSwitcher) == null ? void 0 : _c.stop();
    (_d = this.services) == null ? void 0 : _d.dispose();
    this.logger.info("\u{1F6D1} Agile Board Plugin arr\xEAt\xE9");
  }
  /**
   * Initialise les composants de base
   */
  async initializeCore() {
    await this.loadSettings();
    this.optimizeSettingsForEnvironment();
    this.logger = new LoggerService(this, this.settings.debug);
    this.services = new ServiceContainer(this.app, this, this.settings);
  }
  /**
   * âœ… NOUVEAU : Optimise les paramÃ¨tres selon l'environnement dÃ©tectÃ©
   */
  optimizeSettingsForEnvironment() {
    var _a, _b, _c;
    const environment = SettingsUtils.detectEnvironment();
    const optimizedSettings = SettingsUtils.getOptimalSettings(environment);
    this.settings = SettingsUtils.mergeSettings(optimizedSettings, this.settings);
    (_c = this.logger) == null ? void 0 : _c.config("Param\xE8tres optimis\xE9s pour environnement", {
      environment,
      pluginSupportEnabled: (_a = this.settings.pluginSupport) == null ? void 0 : _a.enabled,
      debugMode: (_b = this.settings.pluginSupport) == null ? void 0 : _b.debugMode
    });
  }
  /**
   * Initialise tous les services
   */
  async initializeServices() {
    await this.services.initialize();
    this.viewSwitcher = new ViewSwitcher(this);
    this.modelDetector = new ModelDetector(this);
    this.modelDetector.onLoad();
    this.viewSwitcher.addSwitchButton();
    const stats = this.services.getStats();
    this.logger.info("\u{1F4CA} Services initialis\xE9s avec support universel", stats);
  }
  /**
   * Initialise l'interface utilisateur
   */
  async initializeUI() {
    this.registerView(
      BOARD_VIEW_TYPE,
      (leaf) => new BoardView(leaf, this)
    );
    this.registerCommands();
    this.addSettingTab(new AgileBoardSettingsTab(this.app, this));
  }
  /**
   * Enregistre toutes les commandes
   */
  registerCommands() {
    const layouts = this.services.layout.getAllModelsInfo();
    layouts.forEach((layout) => {
      this.addCommand({
        id: `create-${layout.name.replace("layout_", "")}-note`,
        name: `Cr\xE9er ${layout.displayName}`,
        callback: () => this.createNote(layout.name)
      });
    });
    this.addCommand({
      id: "switch-to-board-view",
      name: "Basculer vers la vue Board",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.viewSwitcher.switchToBoardView(activeFile);
        } else {
          new import_obsidian5.Notice("\u274C Aucun fichier actif");
        }
      }
    });
    this.addCommand({
      id: "create-missing-sections",
      name: "Cr\xE9er les sections manquantes",
      callback: () => this.createMissingSections()
    });
    this.addCommand({
      id: "refresh-plugin-support",
      name: "Actualiser le support des plugins",
      callback: () => this.refreshPluginSupport()
    });
    this.addCommand({
      id: "toggle-plugin-debug",
      name: "Basculer le debug des plugins",
      callback: () => this.togglePluginDebug()
    });
    this.addCommand({
      id: "show-plugin-diagnostics",
      name: "Afficher les diagnostics des plugins",
      callback: () => this.showPluginDiagnostics()
    });
  }
  /**
   * CrÃ©e une nouvelle note avec layout (utilise ServiceContainer)
   */
  async createNote(layoutName) {
    try {
      await this.services.file.createNoteWithLayout({
        layoutName,
        autoOpen: true
      });
    } catch (error) {
      this.logger.error("Erreur cr\xE9ation note", error);
    }
  }
  /**
   * CrÃ©e les sections manquantes (utilise ServiceContainer)
   */
  async createMissingSections() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian5.Notice("\u274C Aucun fichier actif");
      return;
    }
    try {
      await this.services.file.createMissingSections(activeFile);
    } catch (error) {
      this.logger.error("Erreur cr\xE9ation sections", error);
    }
  }
  // ===================================================================
  // âœ… NOUVELLES MÃ‰THODES POUR LE SUPPORT DES PLUGINS
  // ===================================================================
  /**
   * âœ… NOUVEAU : Log les plugins Obsidian dÃ©tectÃ©s
   */
  logDetectedPlugins() {
    var _a;
    try {
      const enabledPlugins = Object.keys(this.app.plugins.enabledPlugins || {});
      const manifests = this.app.plugins.manifests || {};
      const supportedPlugins = ((_a = this.settings.pluginSupport) == null ? void 0 : _a.supportedPlugins) || [];
      const detectedSupportedPlugins = enabledPlugins.filter(
        (pluginId) => supportedPlugins.includes(pluginId) || supportedPlugins.includes("*")
      );
      this.logger.info("\u{1F50C} Plugins Obsidian d\xE9tect\xE9s", {
        totalEnabled: enabledPlugins.length,
        supportedDetected: detectedSupportedPlugins.length,
        supportedPlugins: detectedSupportedPlugins,
        allEnabled: enabledPlugins
      });
      detectedSupportedPlugins.forEach((pluginId) => {
        const manifest = manifests[pluginId];
        if (manifest) {
          this.logger.debug(`\u{1F4E6} Plugin support\xE9: ${manifest.name} v${manifest.version}`, {
            id: pluginId,
            author: manifest.author,
            description: manifest.description
          });
        }
      });
    } catch (error) {
      this.logger.warn("\u26A0\uFE0F Erreur lors de la d\xE9tection des plugins", error);
    }
  }
  /**
   * âœ… NOUVEAU : Actualise le support des plugins
   */
  async refreshPluginSupport() {
    try {
      this.logger.info("\u{1F504} Actualisation du support des plugins...");
      if (this.services.pluginIntegration) {
        this.services.pluginIntegration.dispose();
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.logDetectedPlugins();
      const boardViews = this.app.workspace.getLeavesOfType(BOARD_VIEW_TYPE);
      for (const leaf of boardViews) {
        const view = leaf.view;
        if (view.renderBoardLayout) {
          await view.renderBoardLayout();
        }
      }
      new import_obsidian5.Notice("\u2705 Support des plugins actualis\xE9");
      this.logger.success("Support des plugins actualis\xE9 avec succ\xE8s");
    } catch (error) {
      this.logger.error("\u274C Erreur lors de l'actualisation du support des plugins", error);
      new import_obsidian5.Notice("\u274C Erreur lors de l'actualisation du support des plugins");
    }
  }
  /**
   * âœ… NOUVEAU : Bascule le mode debug des plugins
   */
  async togglePluginDebug() {
    var _a;
    try {
      const currentDebugMode = ((_a = this.settings.pluginSupport) == null ? void 0 : _a.debugMode) || false;
      if (!this.settings.pluginSupport) {
        this.settings.pluginSupport = { ...this.settings.pluginSupport };
      }
      this.settings.pluginSupport.debugMode = !currentDebugMode;
      await this.saveSettings();
      const newState = this.settings.pluginSupport.debugMode ? "activ\xE9" : "d\xE9sactiv\xE9";
      new import_obsidian5.Notice(`\u{1F527} Debug des plugins ${newState}`);
      this.logger.config("Debug des plugins modifi\xE9", {
        debugMode: this.settings.pluginSupport.debugMode
      });
    } catch (error) {
      this.logger.error("\u274C Erreur lors du basculement du debug des plugins", error);
    }
  }
  /**
   * âœ… NOUVEAU : Affiche les diagnostics des plugins
   */
  showPluginDiagnostics() {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const stats = this.services.getStats();
      const pluginStats = stats.pluginIntegration;
      const enabledPlugins = Object.keys(this.app.plugins.enabledPlugins || {});
      const supportedPlugins = ((_a = this.settings.pluginSupport) == null ? void 0 : _a.supportedPlugins) || [];
      const diagnostics = {
        "Support universel": ((_b = this.settings.pluginSupport) == null ? void 0 : _b.enabled) ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9",
        "Mode debug": ((_c = this.settings.pluginSupport) == null ? void 0 : _c.debugMode) ? "\u2705 Activ\xE9" : "\u274C D\xE9sactiv\xE9",
        "Plugins install\xE9s": enabledPlugins.length.toString(),
        "Plugins support\xE9s": supportedPlugins.length.toString(),
        "Observers actifs": ((_d = pluginStats == null ? void 0 : pluginStats.observers) == null ? void 0 : _d.toString()) || "0",
        "Event listeners": ((_e = pluginStats == null ? void 0 : pluginStats.eventListeners) == null ? void 0 : _e.toString()) || "0",
        "Timeout chargement": `${((_f = this.settings.pluginSupport) == null ? void 0 : _f.loadTimeout) || 0}ms`,
        "D\xE9lai fallback": `${((_g = this.settings.pluginSupport) == null ? void 0 : _g.fallbackDelay) || 0}ms`
      };
      let message = "\u{1F50D} Diagnostics du support des plugins:\n\n";
      Object.entries(diagnostics).forEach(([key, value]) => {
        message += `\u2022 ${key}: ${value}
`;
      });
      const detectedSupportedPlugins = enabledPlugins.filter(
        (pluginId) => supportedPlugins.includes(pluginId) || supportedPlugins.includes("*")
      );
      if (detectedSupportedPlugins.length > 0) {
        message += `
\u{1F4E6} Plugins support\xE9s d\xE9tect\xE9s:
`;
        detectedSupportedPlugins.forEach((pluginId) => {
          message += `  \u2022 ${pluginId}
`;
        });
      }
      new import_obsidian5.Notice(message, 1e4);
      this.logger.info("\u{1F4CA} Diagnostics du support des plugins", {
        settings: this.settings.pluginSupport,
        stats: pluginStats,
        enabledPlugins,
        detectedSupportedPlugins
      });
    } catch (error) {
      this.logger.error("\u274C Erreur lors de l'affichage des diagnostics", error);
      new import_obsidian5.Notice("\u274C Erreur lors de l'affichage des diagnostics des plugins");
    }
  }
  /**
   * Configure un intervalle pour sauvegarder les logs
   */
  setupLogAutoSave() {
    if (this.logSaveInterval) {
      clearInterval(this.logSaveInterval);
    }
    if (this.settings.debug.enabled && this.settings.debug.logToFile) {
      const intervalInMinutes = this.settings.debug.autoSaveInterval;
      const intervalInMs = intervalInMinutes * 60 * 1e3;
      this.logSaveInterval = this.registerInterval(
        window.setInterval(() => {
          this.logger.saveLogsToFile();
        }, intervalInMs)
      );
      this.logger.info("\u{1F4DD} Intervalle de sauvegarde des logs configur\xE9", {
        intervalMinutes: intervalInMinutes
      });
    }
  }
  // ===================================================================
  // GETTERS DE COMPATIBILITÃ‰ (pour BoardView qui attend les anciens services)
  // ===================================================================
  /**
   * Getter pour layoutService (compatibilitÃ© BoardView)
   */
  get layoutService() {
    return this.services.layout;
  }
  /**
   * Getter pour fileService (compatibilitÃ© BoardView)
   */
  get fileService() {
    return this.services.file;
  }
  /**
   * Getter pour sectionManager (compatibilitÃ© BoardView)
   */
  get sectionManager() {
    return {
      createMissingSections: async (file) => {
        return await this.services.file.createMissingSections(file);
      }
    };
  }
  // ===================================================================
  // GESTION DES PARAMÃˆTRES
  // ===================================================================
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.pluginSupport && !SettingsUtils.validatePluginConfig(this.settings.pluginSupport)) {
      this.settings.pluginSupport = DEFAULT_SETTINGS.pluginSupport;
      console.warn("\u26A0\uFE0F Configuration des plugins invalide, utilisation des param\xE8tres par d\xE9faut");
    }
  }
  async saveSettings() {
    var _a, _b, _c, _d, _e;
    await this.saveData(this.settings);
    (_a = this.services) == null ? void 0 : _a.updateSettings(this.settings);
    (_b = this.logger) == null ? void 0 : _b.updateSettings(this.settings.debug);
    this.setupLogAutoSave();
    (_e = this.logger) == null ? void 0 : _e.config("Param\xE8tres sauvegard\xE9s", {
      pluginSupportEnabled: (_c = this.settings.pluginSupport) == null ? void 0 : _c.enabled,
      debugMode: (_d = this.settings.pluginSupport) == null ? void 0 : _d.debugMode
    });
  }
  // ===================================================================
  // API PUBLIQUE
  // ===================================================================
  getServices() {
    return this.services;
  }
  getSettings() {
    return this.settings;
  }
  async updateSettings(updates) {
    this.settings = { ...this.settings, ...updates };
    await this.saveSettings();
  }
  getLogger() {
    return this.logger;
  }
  // âœ… NOUVELLES MÃ‰THODES D'API POUR LES PLUGINS
  /**
   * âœ… NOUVEAU : Obtient les statistiques du support des plugins
   */
  getPluginSupportStats() {
    var _a, _b;
    return ((_b = (_a = this.services) == null ? void 0 : _a.getStats()) == null ? void 0 : _b.pluginIntegration) || {};
  }
  /**
   * âœ… NOUVEAU : VÃ©rifie si un plugin spÃ©cifique est supportÃ©
   */
  isPluginSupported(pluginId) {
    var _a;
    const supportedPlugins = ((_a = this.settings.pluginSupport) == null ? void 0 : _a.supportedPlugins) || [];
    return supportedPlugins.includes(pluginId) || supportedPlugins.includes("*");
  }
  /**
   * âœ… NOUVEAU : Active/dÃ©sactive le support d'un plugin spÃ©cifique
   */
  async togglePluginSupport(pluginId, enabled) {
    if (!this.settings.pluginSupport) {
      this.settings.pluginSupport = { ...DEFAULT_SETTINGS.pluginSupport };
    }
    const supportedPlugins = [...this.settings.pluginSupport.supportedPlugins || []];
    if (enabled && !supportedPlugins.includes(pluginId)) {
      supportedPlugins.push(pluginId);
    } else if (!enabled) {
      const index = supportedPlugins.indexOf(pluginId);
      if (index > -1) {
        supportedPlugins.splice(index, 1);
      }
    }
    this.settings.pluginSupport.supportedPlugins = supportedPlugins;
    await this.saveSettings();
    this.logger.config(`Support du plugin ${pluginId} ${enabled ? "activ\xE9" : "d\xE9sactiv\xE9"}`);
  }
};
